УСТАНОВКА ДЖАНГО, СОЗДАНИЕ ПРОЕКТА, ПРЕДСТАВЛЕНИЯ И МАРШРУТИЗАЦИЯ


Урок 1 УСТАНОВКА ДЖАНГО

для запуска проекта на джанго сначала нам нужно создать репозиторий проекта и в нём поставить виртуальное окружение venv
далее ставим джанго внутри окружения ~ pip install django==4.2.1 
можно посмотреть какие команды доступны в ядре джанго ~ django-admin 
далее создаём сайт на котором будем работать ~ django-admin startproject <имя сайта>
после создания, видим внутри проекта папку с названием сайта и в нём python файлы, включая manage.py
чтобы запустить сервер сайта нужно выполнить команду внутри папки сайта ~ python manage.py runserver 
при обновлении програмного кода, браузер может не подгрузить изменения, тогда нам нужно отключить соединение в терминале и подключиться снова



Урок 2 СОЗДАНИЕ ПРИЛОЖЕНИЯ В ДЖАНГО

сначала напомним что происходит под капотом сайта когда пользователь делает запрос на сайт:
- на сервер приходит запрос и он ищет щаблоны схожие с запросом пользователя
- при нахождении шаблона активируется представление в джанге
- представление это функция или класс в питоне, которые при активации дастаёт необходимые данные из бд и шаблонов html, объединяет их и отрправляет пользователю в виде html страницы

на сайте может быть реализованно множество логических независимых приложений, каждое из них является программой внутри сайта и все эти программы хранятся в нашем проекте джанго. Каждая из них должна быть зарегестрированна (прописана) в settings.py внутри INSTALLED_APPS

приложение создаётся в терминале внутри проекта джанго ~ python manage.py startapp <имя приложения> 



УРОК 3 СОЗДАНИЕ ФУНКЦИЙ-ПРЕДСТАВЛЕНИЙ И ИХ МАРШРУТИЗАЦИЯ 

Как уже говорилось ранее представление это функция или класс которая возвращает данные, как правило, в виде html страницы
Сами представления создаются и хранятся в файле views.py внутри репозитория приложения

Но чтобы эта функция вернулась пользователю её нужно как-то передать. Процесс передачи называется - маршрутизация
Маршрутизация осуществляется при помощи джанговой функции path() из джанговой библиотеки, она принимает "суфикс" урл котороый будет в адресе той страницы на которую мы переходим и функцию (или класс) - представление, которая и возвращает страницую

все маршруты хранятся в переменной urlpatterns как элементы списка, внутри файла urls.py
Такой файл по дефолту есть только в основном приложении, а для созданных приложений его нужно создавать отдельно.
Если мы используем маршрут из созданного приложения, маршрут нужно прописывать urls.py самого приложеия, а в urls.py основного приложения принимать все пути при помощи функции include() ~ path(<первоначальный суфикс>, include('<имя приложения>.urls')),



УРОК 4 ОТЛАДКА ПРОЕКТА В ПАЙЧАРМ

Если подключаться к серверу через терминал, мы теряем возможность его отлаживать, а еще это не очень удобно.
Мы можем подключаться к нему по кнопке (зелёной, что запускает скрипт) в пайчарме.
Для этого возле той самой кнопки, нажимаем на настройки и в окне указываем: название скрипта, рабочую директорию, интерпритатор пайтон, в котором работает проект и команду скрипта (в этом примере runserver)
После настройки можно: подключаться к серверу по кнопке, а не командой в терминале и делать отладку функций. 
А ещё больше не нужно перезапускать сервер при изменение кода



УРОК 5 ДИНАМИЧЕСКИЕ URL И КОНВЕРТЕРЫ

Динамические урл это урл с несколькими раздаелами пути, где последующие разделы, после основного, могут динамически изменятся и тем самым изменять данные, которые возвращаются в ответе сервера.
эти разделы отображаются при написании представлений и маршрутов динамических урл
Для представлений, если оно выполненно в виде функции, подраздел будет дополнительным аргументов функции, который можно использовать в теле или выводе этой функции.
    def categories_by_slug(request, cat_slug):
        return HttpResponse(f"<h1>Статьи по категориям</h1><p >slug:{ cat_slug }</p>")
В маршруте, подраздел отображается как часть пути, но не статичной строкой, а спец. синтаксисом <тип данных:имя аргумента представления>, а называется это - конвертер
    path('cats/<int:cat_id>/', views.categories),



Для динамичных путей можно использовать несколько типов данных:
    str – любая не пустая строка, исключая символ ‘/’;
    int – любое положительное целое число, включая 0;
    slug – слаг, то есть, латиница ASCII таблицы, цифры, символы дефиса и подчеркивания;
    uuid – цифры, малые латинские символы ASCII, дефис;
    path – любая не пустая строка, включая символ ‘/’. 

Но если нам их не хватает, можно определить свой тип данных и воспользоваться регуляркой.
В таком случае путь в маршруте будет указываться функцией re_path(), а регулярка будет прописана в пути
    re_path(r'^archive/(?P<year>[0-9]{4})/', views.archive),
Но это выглядит не очень, поэтому можно поступить намного круче:
Вместо того чтобы того чтобы прописывать конвертер внутри path можно прописать его в отдельном файле converters.py, предворительно создав его внутри нашего приложения.
В этом файле мы будем хранить все наши конвертеры, а реализовывать их можно в классе и это выглядит очень красиво и удобно:
    class FourDigitYearConverter:
        regex = "[0-9]{4}"  # наша регулярочка
     
        def to_python(self, value):
            return int(value)   # функция делает из строки число (я так понимаю для проверки)
     
        def to_url(self, value):
            return "%04d" % value       # возвращает строку обратно, чтобы использовать в path

И теперь мы можем можем использовать этот конвертер в path().
Причем именно в path, а не re_path
Но перед использованием конвертера, его нужно снасала зарегестрировать в файле urls.py, ну и импортировать конечно же
Чтобы зарегестрировать конвертер нужно воспользоваться функцией register_converter(), которую тоже нужно импортировать из django.urls.
В функцию летит имя конвертера и произвольное имя типа данных который он возваращает
    register_converter(converters.FourDigitYearConverter, "year4")
после этого можно использовать конвертер в path и лицезреть красивый код
    path('archive/<year4:year>/', views.archive),

подробности обо всём этом тут:
https://docs.djangoproject.com/en/4.2/topics/http/urls/


Ещё момент про urlpatterns (список наших урлов)
При запросе всегда отработает тот шаблон, в котором, первым, было найдено совпадение запроса. Т.Е. елси запрос может отработать в нескольких маршрутах, отработает, тот что записон в списке раньше остальных (имеет меньший индекс). 



УРОК 6 GET И POST ЗАПРОСЫ, ОБРАБОТКА ИСКЛЮЧЕНИЙ

УРЛ запросы могут содержать дополнительные параметры в виде GET и POST запросов.
http://127.0.0.1:8000/?name=Gagarina&cat=music 
?name=Gagarina&cat=music  - вот эта часть и есть пост запрос.
Эти запросы можно обрабатывать в джанге, например, в самой вьюшке можно словить его ~ request.GET и далее с ним работать
С пост запросом всё идентично ~ request.POST

ОБРАБОТКА ИСКЛЮЧЕНИЙ:
Порой при запросе, запросе пользователь может словить исключение, разберем на примере 404, когда запрос не находит совпадений в маршрутах и не может ничего вернуть
Если самому сделать подобный запрос, джанго выдаст страницу исключения 404 с данными подсказывающие нам об исключение.
Это происходит потомучто в файле setting.py в папке главного приложения есть переменная DEBUG с параметром TRUE.
Если её отключить (поменять на False) при исключении мы будем получать стандартный вывод 404 браузера
Но помимо отключения дебага нам нужно будет еще прописать хост локального сервера в ALLOWED_HOSTS = [], иначе мы не подключимся к нему и получим ошибку
    ALLOWED_HOSTS = ['127.0.0.1']
Вывод исключений браузера не очень удобный и информативный для пользователя
Мы можем написать собственный обработчик исключений и выводить собственный html в подобных случаях
пишем его в urls.py основного приложения ~ handler404 = page_not_found
обработчик это вызов функции page_not_found сама же функция будет находится во вьюшке приложения women
    def page_not_found(request, exception):
        return HttpResponseNotFound('<h1>Страница не найдена</h1>')
функция принимает запрос и ошибку из джанги и возвращает класс HttpResponseNotFound который мы импортируем из django.http
Теперь при ошибки 404 мы выводим собственный html для пользователя.

обрабатывать запросы можно и в самих вьюшках:
    def archive(request, year):
        if year > 2023:
            raise Http404()
        return HttpResponse(f"<h1>Архив по годам</h1><p >{year}</p>")
Здесь по условию мы генерим исключение Http404(). оно импортируется из django.http. при срабатывание этого исключения сработает наш обработчик 404

Обрабатывать можно не только 404 исключение, но и другие, для каждого нужно писать свой обработчик.
Подробнее тут:
https://docs.djangoproject.com/en/4.2/ref/urls/



УРОК 7 GET И POST ЗАПРОСЫ, ОБРАБОТКА ИСКЛЮЧЕНИЙ

При развитии сайта очень часто некоторые страницы переезжают на други урл адреса.
Чтобы не потерять эти страницы, поисковой системе нужно явно указывать что страница переехала.
После того как мы это сделали, переходя по старому адресу сайт перенаправит нас на новый урл а запрос получит ответ 301 или 302
    301 – страница перемещена на другой постоянный URL-адрес;
    302 – страница перемещена временно на другой URL-адрес. 

В джанго переезд можно оформить функцией redirect(), предварительно импортируя её из django.shortcuts
    from django.shortcuts import render, redirect
функцию мы вставляем в return представления и передаём в неё адрес на которое будет переход
    def archive(request, year):
        if year > 2023:
            return redirect('/')
Вместо указания адреса напрямую можно указать имя функции представления return redirect(index)
По дефолту перенаправление происходит с ответом 302, т.е. временно, чтобы сработал ответ 301, в redirect нужно добавить дополнительный аргумент - permanent со значением True
    return redirect(index, permanent=True)
Писать путь напрямую или имя функции, считается хардкодингом.
Помимо этих двух вариантов функция redirect принимает еще и имя маршрута. И это самый лучший вариант в визуальном стили кода.
Но это имя в маршруте должно присутствовать.
Для этого в маршрут передаём еще один параметр name='имя маршрута'
    path('', views.index, name='home'),
    path('cats/<slug:cat_slug>/', views.categories_by_slug, name='cats'),
и после этого в redirect можно передовать это имя
    return redirect('home', permanent=True)
Если же маршрут перенаправления содержит несколько параметров - в redirect эти параметры также нужно указать
    return redirect('cats', 'music')

Маршрут перенаправления можно вычеслить заранее, до функции redirect используя функцию revers, предворительно, импортируя её из django.urls
В revers можно передать имя маршрута и коллекцию дополнительных подрозделов.
А после передаём функцию в redirect
        url_redirect = reverse('cats', args=('sport',))
        return redirect(url_redirect)

Помимо redirect можно использовать классы HttpResponseRedirect и HttpResponsePermanentRedirect
Работает они почти аналогично redirect(). первый вызывает ответ 302, второй 301
Чем пользоваться тоже, особо разницы нет.
Разница в работе заключается в том, что в классы нельзя передовать названия функций представлений, а ещё redirect может сам вычислять маршрут динамически



ШАБЛОНЫ


УРОК 1 ШАБЛОНЫ, render(), render_to_string()

Шаблоны это готовы html страницы.
До этого мы передовали захардкоженную html внутри функций представления. Но так конечно же делать неправильно
Все шаблоны храняться внутри нашего приложения в директории под названием templates.
Внутри этой директории также необходимо создать директорию с названием нашего приложения и уже в ней хранить наши html файлы
Это делается потому-что, чтобы вытащить html документ, мы должны передать его путь.
Джанго не требует передовать весь путь, он подразумевает, что в каждом приложении, у нас есть папка templates и сам будет искать там html.
Вот только джанго будет проходить по всем приложениям и если у нас в разных приложениях будут храниться html с одинаковыми названиями джанго возьмёт первый найденный.
Для этого и создаётся подпапка в templates, так мы указываем более подробный путь, который не будет совпадать с другими приложениями.

Как же передать этот путь во вьюшке?:
Для этого нам понадобиться функция render_to_string(), которую мы импортируем из django.template.loader.
в неё мы и передадим путь к файлу html, а её саму передадим в вывод вьюшки
    def index(request):
        t = render_to_string('women/index.html')
        return HttpResponse(t)
Но можно сократить эти две строки в одну используя функцию render() из django.shortcuts
В неё передаём request и путь к html
    def about(request):
        return render(request, 'women/about.html')

Теперь а самом шаблонизаторе джанго:
Мы можем изменять его настройки в основной директории приложения в файле settings.py
Там есть коллекция TEMPLATES. она хранит в себе такие ключи: BACKEND, DIRS, APP_DIRS, OPTIONS
'BACKEND': 'django.template.backends.django.DjangoTemplates', - в нём прописан стандартный шаблонизатор джанги
'DIRS': [], - в Этой коллекции мы можем хранить дополнительные пути для поиска шаблонов, если это требуется
'APP_DIRS': True, - этот ключ отвечает, за то что джанго понимает что ей нужно искать в папке templates в каждом приложении.
точнее не в каждом приложении а в каждом инсталированном. т.е. находящийся в коллекции INSTALLED_APPS, в этом же файле
    'women.apps.WomenConfig',



УРОК 2 ПЕРЕДАЧА ДАННЫХ (ПЕРЕМЕННЫХ) В ШАБЛОНЫ

Шаблону не обязательно быть статичным. т.е. данные в нём не обязательно должны быть строго вшиты в html.
Мы можем передовать данные из переменных в коде в html страницу.
Для этого нужно поправить сам html документ и в место куда мы хотим хотим поставить вставлять данные прописать {{}}, а внутрь кавычек вписать имя переменной, значение которой будем вставлять. 
вместо этого
    <title>Главная страница</title>
вот так
    <title>{{title}}</title>
А в коде нам нужно создать данные с таким же названием.
Например, создать словарь с ключём title и значением которое мы хотим подставить html
    data = {'title': 'Главная страница'}
Этот словарь можно создать внутри представления страницы в которую мы будем подставлять данные и передать словарь третим аргументом в функцию рендер, или через именнованный аргумент context
    def index(request):
        data = {'title': 'Главная страница'}
        return render(request, 'women/index.html', data)
А можно создать прямо внутри аргумента напрямую
    def about(request):
        return render(request, 'women/about.html', context={'title' : 'О сайте'})

В html может находиться множество данных, которые нужно подставлять из кода, тогда и словарь будет с множеством ключей.
     data = {
        'title': 'Главная страница',
        'menu': menu,
        'float': 28.56,
        'lst': [1, 2, 'abc', True],
        'set': {1, 1, 2, 3, 2, 5},
        'dict': {'key_1': 'value_1', 'key_2': 'value_2'},
        'obj': MyClass(10, 20),
    }
Тип данных может быть любым, но в html выводиться строковое представление переданных данных
Можно передовать даже коллекции, как целиком, так и части этих коллекций.
Но чтобы передать элемент коллекции в html, нужно это указать в самом html.
И делается это не привычным синтаксисом пайтон
    <p >{dict[key_1]}}</p>
а немного измененным
    <p >{{dict.key_1}}</p>
    <p >{{obj.a}}</p>
В одни фигурные скобки, можно засовывать только один элемент. Если мы хотим передать в тег несколько элементов - каждый нужно обернуть в скобки отдельно
    <p >{{ dict.key_1 }} {{ dict.key_2 }}</p>
Если в html есть имя данных которые мы не передали в render, при выводе страницы в браузере мы не получим ошибку.
В таком случае данные будут просто проигнорированны. т.е. на месте данных ничего не будет

Как вытаскивать элементы из списков и кортежей, будет в дальнейших уроках



УРОК 3 ШАБЛОННЫЕ ФИЛЬТРЫ

Шаблонные фильтры это как методы для объектов пайтон, но для данных в html (те что обёрнуты в кавычки {{}})
Фильтров существует огромное множество, у каждого своё предназначение, и свой тип данных для работы
Если в питоне метод присоединяется определённым синтаксисом obj.method
У html свой синтаксис obj|filter
Если в филтьр нужно передать значение - будет так obj|filter:"value", даже числи летят в кавычки

Разбёрем некоторые фильтры:
 - add - прибовляет к числу переданное число
    <p >{{float|add:"50"}}</p> 
float у нас равен 28.56, а на выводе страницы мы видем 78
Это потому что add работает только с целочисленными значениями и если в него передать вещественное число, он преобразует его в целое
 - capfirst - делает первую букву заглавной
 - upper - делает все буквы заглавными
 - lower - делает все буквы маленькими
 - cut - вырезает из строки все переданные символы.
как и в питоне методы можно комбенировать цепочкой obj.method1.method2.... так и тут можно obj|filter1|filter2...
<h1>{{title|cut:" "|cut:"?"}}</h1>
 - default - создаёт дефолтное значение из переданных данных объекту, если мы не подставили этот объект в коде или передали пустое значение
<title>{{main_title|default:"Без заголовка"}}</title>
 - divisibleby - Возвращает true или false если объект кратен переданному числи, как и add преобразует объект в целочисленное значение
 - first - выводит первый элемент коллекции. как раз тот способ доставание элементов из списков и кортежей
 - last - выводит последний элемент коллекции
 - join выводит все элементы коллекции через переданный разделитель
 <p >{{menu|join:" | "}}</p>
 О сайте | Добавить статью | Обратная связь | Войти 
 - length - показывает длинну коллекции или строки. а-ля функция len()
 - slugify - преобразует строку в формат slug
 <p >{{"The Main Page"|slugify}}</p>
 the-main-page

Больше фильтров и подробностей о них можно узнать в документации
https://docs.djangoproject.com/en/4.2/ref/templates/builtins/ 

Фильтры можно использовать не только в html, но и в самом коде
Необходимый фильтр сначала нужно импортировать
    from django.template.defaultfilters import slugify
А позже его можно использовать как функцию в коде
    'dict': {'key_1': 'value_1', 'key_2': 'value_2'},
        'obj': MyClass(10, 20),
        'url': slugify("The main page"),  # вот он
В html у нас будет просто обычный тег с переданными данными в него, без каких либо фильтров
    <p >{{url}}</p>
Но на странице будет отображаться отфильтрованные данные, аналогичные  <p >{{"The Main Page"|slugify}}</p>



УРОК 4 ТЕГИ ШАБЛОНОВ for И if

Внутри шаблона можно использовать цикл for и проверку if как в питоне, но с немного отличающимся синтаксисом.
И цикл и проверка являются шаблонными тегами, но не стандартными html которые определяют в каком виде выводить данные, а специальными тегами, которые определяют как эти данные выводить.
Такие теги не видно при просмотре страницы в браузере и они пишуться с отличающимся синтаксисом.
    {% <название тега> [параметры] %} 
Для работы мы создали коллекцию в файле представления, а-ля как если бы это было бд
    data_db = [
        {'id': 1, 'title': 'Анджелина Джоли', 'content': 'Биография Анджелины Джоли', 'is_published': True},
        {'id': 2, 'title': 'Марго Робби', 'content': 'Биография Марго Робби', 'is_published': False},
        {'id': 3, 'title': 'Джулия Робертс', 'content': 'Биография Джулия Робертс', 'is_published': True},
    ]
И добавили коллекцию в функцию представления
    def index(request):
        data = {
            'title': 'Главная страница',
            'menu': menu,
            'posts': data_db,
        }
 
        return render(request, 'women/index.html', context=data)

Так вот эти данные мы можем крутить в цикле внутри html и почерёдно выводить их на странице
Вот так это выглядит в шаблоне:
<!DOCTYPE html>
<html>
<head>
         <title>{{ title }}</title>
</head>
<body>
<p >{{ menu|join:" | " }}</p>
<h1>{{ title }}</h1>
 
<ul>
         {% for p in posts %}
         <li>
                   <h2>{{ p.title }}</h2>
                   <p >{{ p.content }}</p>
                   <hr>
         </li>
         {% endfor %}
</ul>
 
</body>
</html>
Мы видим что цикл обёрнут в тег {% %}, но сам цикл пишется точно с таким же синтаксисом как в питоне
После этого идёт тело цикла. в нём создаётся html теги шаблоана, а в них другие вложенные теги, в который мы передаём элементы коллекции, и в конце тег разделитель <hr>
Ещё одно отличае от питона - теги шаблона должны закрываться {% endfor %} для for и {% endif %} для if

И ещё одно отличае:
В отличае от питона, когда мы создаём цикл в шаблоне джанго, у нас под капотом создаётся переменная forloop
forloop напрямую связан с колекцие которую мы прокручиваем и через него, используя методы этой переменной, можно выяснить какая на данный момент происходит итерация и не только.
У forloop множество методов, подробнее тут
https://docs.djangoproject.com/en/4.2/ref/templates/builtins/#for

Нам нужно убрать тег разделитель после последней итерации.
Можно воспользоваться методом forloop.last - он выводит true если это последняя итерация
И сделать это можно проверкой if внутри цикла.
     {% for p in posts %}
     <li>
       <h2>{{p.title}}</h2>
       <p >{{p.content}}</p>
       {% if not forloop.last %}
       <hr>
       {% endif %}
     </li>
Шаблонный тег прописывается в те-же скобки что и for {% if not forloop.last %} и также закрывается, как и for {% endif %}
И точно также сама проверка if пишется полностю питоновским синтаксисом
if not forloop.last - если не последняя итерация
<hr> - ставь разделитель
У тега if есть все те-же конструкции if, elif, else, что и в питоне, каждую из них по аналогии нужно укутывать в скобки, но закрывать нужно только if

Еще в задание требоволось выложить только те строки из бд, в которой колонка is_published имела значение True
Для этого тоже используем if и конечный цикл у нас получается таким:
<ul>
         {% for p in posts %}
         {% if p.is_published %}
         <li>
                   <h2>{{p.title}}</h2>
                   <p >{{p.content}}</p>
                   {% if not forloop.last %}
                   <hr>
                   {% endif %}
         </li>
         {% endif %}
         {% endfor %}
</ul>



УРОК 5 ШАБЛОННЫЙ ТЕГ url

Мы знаем что в html существуют ссылки - тек <a>
<a href="URL-адрес страницы">Название ссылки</a> 

Мы можем брать адреса этих ссылок из кода в джанго-приложение, вместо того чтобы хардкодить их напрямую в теге
Для этого используется шаблонный тег url
Вот его синтаксис ~ {% url 'название маршрута' параметр1 параметр2 %}
Мы видим как шаблонный тег заковывается в кавычки {% %}, далее само название тега - url, 
после идёт название маршрута, это то самое название из маршрута в нашем коде - параметр name= в функции path(), в коллекции маршрутов
А далее идут параметры этого маршрута, т.е. дополнительные динамические подразделы url

Для примера создадим маршрут для нашей коллекции data_db, который будет передовать страницу каждого элемента колекции
    path('post/<int:post_id>/', views.show_post, name='post'),
Ну и конечно же нужно создать функцию представления этой страницы
def show_post(request, post_id):
    return HttpResponse(f"Отображение статьи с id = {post_id}")
Получится динамичный урл, подраздел которого будет привязан к id строки нашего бд

И так у нас есть новая страница в проекте и мы можем добавить ссылку на неё в основной странице нашего сайта, где перечисляются данный data_bd
         {% for p in posts %}
         {% if p.is_published %}
         <li>
             <h2>{{p.title}}</h2>
             <p >{{p.content}}</p>
             <p ><a href="{% url 'post' p.id %}">Читать пост</a></p>  # вот она
                {% if not forloop.last %}
                   <hr>
                {% endif %}
         </li>
Как видим в ссылку мы вставили именно шаблонный тег url, который передали имя маршрута 'post' и параметр маршрута p.id

По уроку далее мы добавили новые маршруты для нашего списка menu, а каждый элемент этого списка сделали словарём с названием маршрута и визуальной частью ссылки для тега <a>, чем и являлись ранее элементы списка menu.
для каждого маршрута, естественно создали представление.
А на главной странице была добавленна ссылка на эту же страницу.
    path('addpage/', views.addpage, name='add_page'),
    path('contact/', views.contact, name='contact'),
    path('login/', views.login, name='login'),


    menu = [{'title': "О сайте", 'url_name': 'about'},
            {'title': "Добавить статью", 'url_name': 'add_page'},
            {'title': "Обратная связь", 'url_name': 'contact'},
            {'title': "Войти", 'url_name': 'login'}
    ]


    def addpage(request):
        return HttpResponse("Добавление статьи")


    def contact(request):
        return HttpResponse("Обратная связь")


    def login(request):
        return HttpResponse("Авторизация")

Теперь можно отобразить коллекцию menu и в html как ссылки на эти маршруты:
<ul>
<li><a href="{% url 'home' %}">Главная</a></li>     # добавляем ссылку на главную страницу
{% for m in menu %}                                 # прокручиваем коллекцию menu
{% if not forloop.last %}<li>{% else %}<li class="last">{% endif %}   # для последнего тега <li> добавили class="last", чтобы в будущем подкрутить стиль
         <a href="{% url m.url_name %}">{{m.title}}</a>   # а вот и тег url, в который передаём имя маршрута, а в тег <a> передаём название страницы
</li>
{% endfor %}
</ul>


Шаблонный тег url можно сравнить с функцией reverse() в джанге
reverse('post', args=(11, )) - reverse принимает имя маршрута и его аргументы, а потом склеивает их в единый url
{% url 'post' 11 %}          - шаблонный тег url принимает тоже самое и делает тоже самое
Именно так и рекомендуется воспринимать шаблонный тег url



УРОК 6 НАСЛЕДОВАНИЕ ШАБЛОНОВ. ШАБЛОННЫЕ ТЕГИ extends, block, include

Код в шаблоне на многих страницах может повторяться, и это не очень правильно и удобночитаемо
поэтому мы можем создать базовый шаблон, в котором будет находиться html код повторяющийся в большинстве страниц
Такие шаблоны нужно хранить в основной директории проекта, для них также создаётся ещё одна директория templates и уже в ней лежать шаблоны
и уже в ней лежат шаблоны.
Важно знать что шаблонизатор не просматривает шаблоны в корневой папке проекта и этот путь нужно прописать в DIRS, в коллекции TEMPLATES setting.py
    BASE_DIR / 'templates'   # BASE_DIR - это как раз путь к корневой папке
Создали директорию, указали путь, а теперь создаём там базовый шаблон который будет содержать в себе весь повторяющий html код каждой страницы
Теперь в уже существующих html документах можно стереть весь этот повторяющийся код и прописать шаблонный тег extends
    {% extends 'base.html' %} вместо этого шаблонного тега подставиться весь html код из переданного в него файла html

Но что делать с тем кодом который является эксклюзивным для наследованной html страницы?:
В бозовом html мы можем выделить место в коде, куда мы будем вставлять какие-то свои правки в html при помощи шаблонного тега block
    {% block content %} {% endblock %}  # параметр тега - это его произвольное название
И уже в нужной нам странице, в произвольном месте нужно создать такойже блок, обязательно, с тем же названием и внутри этого блока поместить наш код
{% block content %}
<h1>{{ title }}</h1>
{% endblock %}

Для наглядности вот как выглядит базовый html:
<!DOCTYPE html>
<html>
<head>
         <title>{{ title }}</title>
</head>
<body>
<ul>
<li><a href="{% url 'home' %}">Главная</a></li>
{% for m in menu %}
{% if not forloop.last %}<li>{% else %}<li class="last">{% endif %}
         <a href="{% url m.url_name %}">{{m.title}}</a>
</li>
{% endfor %}
</ul>
{% block content %} {% endblock %}

</body>
</html>

А вот так страница about:
{% extends 'base.html' %}
{% block content %}
<h1>{{ title }}</h1>
{% endblock %}

тоесть страница about будет выглядит точно так же как страница base но внутри тега block у неё будет содержимое тега block страницы about
Тегов block может быть множество на странице, у каждого должно быть собственное имя, чтобы мы могли сами решать в какой блок нам ложить информацию

Для улучшения проекта сделаем тоже самое и для страницы index
А далее добавим на страницу ещё одну строку с категориями женщин вначале и в конце списка
<nav>
         <a href="#">Актрисы</a> |
         <a href="#">Певицы</a> |
         <a href="#">Спортсменки</a>
</nav>

Теперь у нас есть повторяющийся тег <nav> в одном документе html
И подобные повторения, также можно предотвратить благодаря шаблонному тегу include
Мы можем хранить подобные куски кода html в отдельных html документах.
Создадим специальную директорию для подобных фалов, например такую
women/templates/women/includes
Создадим там html документ и сохраним в него повторяющий тег nav для страницы about
А на самой странице about вместо этого тега, вызовим шаблонный тег include в каждом месте где есть этот шаблон
    {% include 'women/includes/nav.html' %}   # он работает по аналогии тегу extends - тоже подставляет весь код переданной страницы вместо тега, но его можно использовать сколько угодно раз
У тега include есть дополнительные параметры:
only - этот параметр передаёт - не передаёт переменные - всё что в завёрнуто в двойные ковычки {{}}
with - ставиться после only в него можно передать имена тех переменных, которые мы всётаки хотим передать в теге include
    {% include 'women/includes/nav.html' only with title %} - передать всё содержимая файла nav без переменных, кроме переменной title



УРОК 7 ПОДКЛЮЧЕНИЕ СТАТИЧЕСКИХ ФАЙЛОВ

Статические файлы - это файлы css, картинки, и скрипты javascript
В боевом проекте мы конечно же не будем передовать голый шаблон.
Передоваемый шаблон будет связан со статическеми 
И сейчас разберемся как их связывать и передовать:

Мы уже знаем что мы можем запускать тестовый сервер с включеным и отключенным дебаг режимом
Во включенном дебаг режиме статические файлы ищутся, как и шаблоны, в каждом приложении за исключением рабочего каталога и каталога рабочего приложения
В setting.py есть переменная STATIC_URL, в которой по дефолту указан путь к static директории. 
Именно здесь джанго понимает в какой директории искать статические файлы в дебаг режиме.
ещё мы можем создать переменную STATICFILES_DIRS по формату аналогичной STATIC_URL и там прописать путь для нестандартного пути поиска статических файлов джанга. А-ля в директории корневого приложения.
Но в действующем сайте все статические файлы должны быть перенесены в корневую директорию проекта, в директорию static.
Путь к этой директории тоже нужно прописать в переменной, но уже в новой - STATIC_ROOT
А все статик-файлы перенести в эту директорию.
Причем перенос нужно осуществить, перед запуском сайта, благодаря команде ~ python manage.py collectstatic 

Вот наглядное расположение директорий static
sitewomen
    - sitewomen
        - static               # - нестандартный путь

    - women
        -static                # - стандартный путь для режима дебаг
        -templates

    -static                    # - стандартный путь для действующего режима работы сайта

Мы находимся в режиме разработки, а значит наши статические файлы должны лежать в каталоге приложения
Создаём директори static в приложении, в ней, по тем же причинам что и в templates, создаём директорию с именем приложения
И уже в нём создаём 3 директории - css, images, js
Создаём или добавляем уже созданные статические файлы в этих директориях

Чтобы в html можно было вставлять статические файлы их нужно в этот html загрузить
Для этого в самом начале страницы нужно поставить шаблонный тег load static
{% load static %}

Теперь нам нужно подключить эти файлы к нашему шаблону
Статические фалы добавляются в html в теге link, в нём есть параметр href - ссылка на докумемент файла.
Можно напрямую указать ссылку, но это хардкодинг.
Мы будем делать это используя шаблонный тег static.
По аналогии с include, ему нужно передать ссылку на файл ~ {% static 'women/css/styles.css' %}
часть пути - static/ - указывать не нужно, потому что эта часть уже прописана в STATIC_URL
Тег link будет выглядеть так 
    <link type="text/css" href="{% static 'women/css/styles.css' %}" rel="stylesheet" />

Вот и всё. По аналогии добавляем остальные файлы в шаблон, немного шаманим над самим шаблоном и наш сайт преображается в нормальный вид.


По уроку далее можно рассматриваем еще пару шаблонных фильтров: linebreaks, truncatewords, autoescape
Для работы поменяем в нашей бд заначение первой строки, колонки content с этого:
Биография Анджелина Джоли
на это:
'''<h1>Анджелина Джоли</h1> (англ. Angelina Jolie[7], при рождении Войт (англ. Voight), ранее Джоли Питт (англ. Jolie Pitt); род. 4 июня 1975, Лос-Анджелес, Калифорния, США) — американская актриса кино, телевидения и озвучивания, кинорежиссёр, сценаристка, продюсер, фотомодель, посол доброй воли ООН.
Обладательница премии «Оскар», трёх премий «Золотой глобус» (первая актриса в истории, три года подряд выигравшая премию) и двух «Премий Гильдии киноактёров США».'''

Разберём сначала truncatewords - он выводит указанное количество слов в тексте.
т.е. применив этот тег с параметром 20 - truncatewords:20 - в браузере отобразиться только первые двадцать слов текста
- linebreaks - переносит текст вместе с символоми переноса строк. без этого фильтра символа переноса не будет и строки склеются
- autoescape - это шаблонный тег. в нашем тексте есть экранирование текста в формате html <h1>Анджелина Джоли</h1>, и html при передачи такой строки через {{ данные }} не переводит этот текст в нужный формат сам.
Что бы html видел теги как теги а не как текст, нужно весь текст обернуть в шаблонный тег autoescape с параметром off
    {% autoescape off %}
    {{p.content|linebreaks|truncatewords:40}}
    {% endautoescape %}



УРОК 8 ПОЛЬЗОВАТЕЛЬСКИЕ ТЕГИ ШАБЛОНОВ

Помимо уже известных шаблонных тэгов, мы можем создавать свои (куда ж без этого)
Подробная информация о том как это сделать тут:
https://docs.djangoproject.com/en/4.2/howto/custom-template-tags/

Поехали разбираться!
Пользовательские теги могут быть двух типов
 - simple tags – простые теги
 - inclusion tags – включающие теги

Что нужно чтобы создать свой тег?:
Все пользовательские теги должны храниться в директории templatags, внутри приложения и этот каталог должен являться пакетом, т.е. в нём должен присутствовать файл __init__.py
Сами же теги будут храниться в отдельном файле, к примеру women_tags
импортируем всё необходимое:
from django import template - отсюда вытащим экземпляр класса Library который регестрирует наши шаблонные теги
import women.views as views - импорт файл views чтобы тянуть от туда бд по заданию
Далее создаём экземпляк класса Library, через который происходит регистрация собственных шаблонных тегов:
register = template.Library()
Теперь можно создавать шаблоны

Simple Tag:
Простой тег реализованый через функцию которая что-то возвращает, в нашем случае коллекцию
def get_categories():
    return views.cats_db
сама коллекция во вьюшке:
cats_db = [
    {'id': 1, 'name': 'Актрисы'},
    {'id': 2, 'name': 'Певицы'},
    {'id': 3, 'name': 'Спортсменки'},
]   # это та самая коллекция категорий с главной страницы, все категории у нас вшиты на прямую в html, а нам надо тянуть их из бд, что мы и делаем
Следовательно наш шаблонный тег будет возвращать эту коллекцию

Пока-что это просто функция, чтобы эта функция стала шаблонным тегом, на неё нужно навесить декоратьр @register.simple_tag()
@register - это тот самый объект класса Library, а simple_tag() - это его метод который делает нашу функцию шаблонным тегом типа Simple Tag
Теперь мы можем вызывть наш тег в html также как и другие шаблонные теги {% get_categories %}
Но сначала нам нужно в шаблон загрузить файл с нашими шаблонными тегами
{% load women_tags %}
Помним что наш тег возвращает всю коллекцию, тоесть всю строку бд представленную в виде строки.
Значит нам нужно прокрутить эту коллекци циклом.
Но вот только тег крутить не получиться, потому что он не коллекция, а тег.
Мы можем превратить его в переменную синтаксисом as имя_переменной
{% get_categories as categories %} - так мы превратили вывод тега get_categories в переменную categories, которую можно крутить
и далее вместо захардкоденных категорий
    <li><a href="#">актрисы</a></li>
    <li><a href="#">спортсменки</a></li>
    <li><a href="#">певицы</a></li>
крутим нашу коллекцию
    {% for cat in categories %}
        <li><a href="#">{{cat.name}}</a></li>
    {% endfor %}

Наш шаблонный тег не обязательно называть функцией этого тега
в параметры декоратора можно добавить параметр name= и передать ему произвольное имя
@register.simple_tag(name='getcats')
def get_categories():
    return views.cats_db
Тогда и в html нужно обращаться к тегу по указанному имени
{% getcats as categories %}

Далее разберём inclusion tags но сначала сделаем наши категориями нормальными ссылками
пропишим путь для ссылки
    path('category/<int:cat_id>/', views.show_category, name='category'),
и создадим вьюшку
    def show_category(request, cat_id):
        """Функция-заглушка"""
        return index(request)
в тег категории вставим нормальную ссылку на категорию
{% for cat in categories %}
         <li><a href="{% url 'category' cat.id %}">{{cat.name}}</a></li>
{% endfor %}

Inclusion Tag
Включающий тег позволяет дополнительно формировать свой собственный шаблон на основе данных, которые мы хотим передать в html, а сам тег после этого будет возвращать уже готовый html код
Сделаем тоже что и с простым тегом, через включающий тег:
внутри функции создадим коллекцию нашей бд и возвратим эту колекцию как значение ключа другой коллекции
def show_categories():
    cats = views.cats_db
    return {"cats": cats}
и тоже обернём это всё в декоратор, но уже с методом inclusion_tag(), в который нужно передать путь к html документу который и будет являтся шаблоном с данными, которые мы хотим передать
@register.inclusion_tag('women/list_categories.html')
def show_categories():
    cats = views.cats_db
    return {"cats": cats}
Далее создаём этот документ и засовываем в неё тот самый цикл с нашими категориями который использует нашу коллекцию
{% for cat in cats %}
         <li><a href="{% url 'category' cat.id %}">{{cat.name}}</a></li>
{% endfor %}

А в основной шаблон вместо прошлого тега и прокрутки его переменной 
{% getcats as categories %}
{% for cat in cats %}
         <li><a href="{% url 'category' cat.id %}">{{cat.name}}</a></li>
{% endfor %}
просто вставляем наш тег, который передаёт новый шаблон
{% show_categories %}

Передача параметров пользовательским тегам
По заданию мы хотим чтобы выбранная категория выделялась цветом при переходе на её адрес, и переставаля быть ссылкой
Делается это так:
в функцию нашего шаблонного тега добавим параметр с дефолтным значением =0, и в возвращаемой коллекции добавим еще один ключ со значением этого параметра
@register.inclusion_tag('women/list_categories.html')
def show_categories(cat_selected=0):
    cats = views.cats_db
    return {"cats": cats, "cat_selected": cat_selected}
А в шаблоне добавим проверку на значение этого параметра, чтобы если парметр равен id строки бд, что значит, если мы перешли на страницу этой категории,
тогда будем выводить категорию без ссылки (строкой), с подсвечиванием (используя класс)
А если проверка не проходит, будем возвращать старую ссылку
{% for cat in cats %}
         {% if cat.id == cat_selected %}
                   <li class="selected">{{cat.name}}</li>
         {% else %}
                   <li><a href="{% url 'category' cat.id %}">{{cat.name}}</a></li>
         {% endif %}
{% endfor %}
В шаблонный тег тоже нужно добавить наовый параметр
{% show_categories cat_selected %}
Раз добавили новый параметр значит нужно его от кудого-то передовать
Добавим передоваемые данные этот параметр для страницы index и страницы категории
def index(request):
    data = {
        'title': 'Главная страница',
        'menu': menu,
        'posts': data_db,
        'cat_selected': 0,   # не обязательная строчка
    }
--------
def show_category(request, cat_id):
    data = {
        'title': 'Отображение по рубрикам',
        'menu': menu,
        'posts': data_db,
        'cat_selected': cat_id,
    }
Вот так мы и реализовали смену ссылок и подсветку наших категорий, но строка "Все котегории" так и осталось статичной синей строкой.
Потому что она ей и является в html коде.
Сделаем ей проверку на то что мы находимся на главной странице и оставим её в том же виде, а если нет, сделаем из неё ссылку на главную страницу
    {% if cat_selected == 0 or cat_selected is None %}
        <li class="selected">Все категории</li>
    {% else %}
        <li><a href="{% url 'home' %}">Все категории</a></li>
    {% endif %}



ВВЕДЕНИЕ В ORM И МОДЕЛИ



УРОК 1 БД, SQL, ORM. СОЗДАНИЕ МОДЕЛИ

Данные для сайта, в рабочих проектах бычно беруться из баз данных
Джанго поддерживает следующие субд:
PostgreSQL, MariaDB, MySQL, Oracle и SQLite
По дефолту проект джанго уже сожержит файл бд с субд SQLite
настройки для выбора бд и указания его положения находяться в setting.py, в переменной DATABASES
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}
Если мы хотим поменять субд нужно, нужно будет поменять и значение этой переменной.

При работе с джанго нам не обязательно переходить в файл бд для создания, изменения и т.д. таблиц.
Мы можем создать модель таблицы, это что-то типо её представления.
модель создаётся в файле models.py внутри приложения.
И реализуется через класс джанги Model. Внутри файла models.py он уже импортирован.

Чтобы создать модель, нужно создать класс Model с названием как и таблицы в бд
и при помощи методов этого класса создать необходимые поля таблицы.
таблица создаётся как и в бд, построчно создавая каждое поле таблицы отдельно.
Кроме поля id, он создаётся автоматически.
Методов создания полей множество, все методы являются методоми класса model, вот ссылка на них с их подробностями:
https://docs.djangoproject.com/en/4.2/ref/models/fields/
В уроке были разобранны некоторые:
CharField(max_length=255) - CharField - тип значения поля varchar; max_length - максимальная длина значения
TextField(blank=True) - TextField - текстовый тип значения поля; blank=True - позволяет не создавать значение для поля, т.е. может быть равен None
DateTimeField(auto_now_add=True) - DateTimeField - поле с типом данных дата и время; auto_now_add=True - автоматически создаёт значение равное значению даты и время на момент создания записи.
У DateTimeField есть ещё параметр auto_now=True, который добавляет значение равное значению даты и время в момент создания и изменения записи
BooleanField(default=True) - BooleanField - булевый тип данных значения поля; default= - принимает дефолтное значение, на случай если мы не добавим значение в запись.

И так мы создали вот такую модель.
class Women(models.Model):
    title = models.CharField(max_length=255)
    content = models.TextField(blank=True)
    time_create = models.DateTimeField(auto_now_add=True)
    time_update = models.DateTimeField(auto_now=True)
    is_published = models.BooleanField(default=True)

Создание модели, не значит создание таблицы.
Таблица создаётся позже, по нашей модели, методом миграций в джанге, об этом дальше



УРОК 2 МИГРАЦИИ

Миграция - это команда в питоне, которая создаёт в связанной бд таблицу по моделе.
сама же миграция представляет из себя питоновский файл, в нем создаётся класс миграции из пакета model.
Причем и файл и код внутри создаётся автоматически, когда мы запускаем эту миграцию
файлы мыграций находяться в директории migrations.
Их может быть огромное множество.
Всё дело в том что при изменениие нашей модели, после запуска миграции, создаётся новый файл миграции.
Но этот файл не перезаписывает нашу таблицу, а изменяет её.
Т.Е. каждаю миграцию можно воспринимать как коммит в гитхабе и по старым миграциям, мы всегда можем откатиться к прошлому состоянию.
Также в папке migrations есть еще один пайтон файл __init__.py что делает, нашу директорию пакетом.

Чтобы создать миграцию нужно открыть терминал и запустить команду
python manage.py makemigrations 
Файл миграции создан, он выглядит примерно так - 0001_initial.py. но это ещё не означает создание таблицы, миграцию еще нужно применить.
Но прежде чем это сделать мы можем заранее посмотреть какой sql запрос выполнится если мы применим конкретную миграцию
python manage.py sqlmigrate women 0001   # sqlmigrate - команда для просмотра sql запроса; women - название приложения; 
0001 - номер миграции, он есть в название файла миграции 0001_initial.py
После выполнения команды, в терминале покажется sql запрос, который будет произведён в бд.
Чтобы наконец исполнить миграцию в терминале нобходимо запустить следующую команду
python manage.py migrate
После этого мы видем как происходит множество разных процессов.
Всё дело в том, что с нашим джанго приложением, связанно множество дополнительных модулей, которые автоматически подключаются к нему.
И в каждом этом модуле есть свои вспомогательные таблицы и данные, которые тоже обновляются вместе с нашей миграцией.

Заходим в ГУИ СУБД и видим что в файле нашего бд создалось аж 11 таблиц.
это и есть те вспомогательные таблицы джанги.
какие-то создались для админки, какие-то для самой джанги и в конце видим нашу таблицу.
Она называется названиеприложения_названиемодели (women_women)



УРОК 3 ДОБАВЛЕНИЕ ЗАПИСЕЙ В БД

Для начала нужно разъяснить кое-что о нашей модели.
модель которую мы описывали классом представляет из себя структуру таблицы.
А объект этой модели будет являтся строкой этой таблицы.
Один объект - одна строка.
Т.Е. чтобы добавить пять строк, нам нужно будет создать пять объектов этого класса, передать в них данные для строки и добавить строку в таблицу

Добавление записи в таблицу тоже происходит в джанге при помощи ОРМ
Для этого нам необходимо перейти в терминал и вызвать там в консоль фреймворка
    python manage.py shell 
Мы переходим в новую консоль где и создаются строки и передаются в таблицы
Чтобы работать с конкретной таблицей сначала нужно импортировать её модель
    from women.models import Women
Создадим строку для нашей таблицы, т.е. вызовим объект класса таблицы и передадим в него данные
    Women(title='Анджелина Джоли', content='Биография Анджелины Джоли')
имена полей являются параметрами класса в них передаём значения для строки.
В примере мы добавили только те значения, которые не создаются автоматически
объект класса перед записью в таблицу, нужно сохранить в переменну, можно было и сразу конечно, но можно воспользоваться символом _
В этой консоле символ _ является специальной ссылкой в которой сохраняется результат последнй операции
    w1 = _   # так мы добавили прошлую операцию в переменную
Когда мы сохраняем строку в переменную в терминале мы видем запись об этом
    <Women: Women object (None)> 
но запись ещё не попала в таблицу
Чтобы это произашло, нужно воспользоваться командой save()
    w1.save()
После выполнения команды запись попадает в таблицу и мы видем такой вывод в консоле
    <Women: Women object (1)>   # цыфра один это id нашей строки
Мы также можем оперировать данными этой строки в терминале
    w1.id # идентификатор
    w1.title # заголовок
    w1.time_create # время добавления записи
Вместо id можно использовать pk (primary key)
    w1.pk     # значение тоже что и w1.id

Мы можем посмотреть какие запрос произашли в бд внутри во время сессии этой консоли
Для этого нужно импортировать 
    from django.db import connection
И обратиться к колекции
connection.queries
В ответе мы видим вывод всех запросов

Добавим ещё запись
w2 = Women(title='Энн Хэтэуэй', content='Биография Энн Хэтэуэй')
w2.save()

Можно создавать строку поэтапно:
Сначала создадим строку
    w3 = Women()
Потом добавим ей значение title
    w3.title = 'Джулия Робертс'
и значение content
    w3.content = 'Биография Джулии Робертс'
и можно сохранять запись в таблицу
w3.save()

Консоль это конечно хорошо но некрасиво и лапки не любят много печатать
Можно установить в интерпритатор проекта пакет ipython
После его установки появляется подсветка синтаксиса и автодополнение кода

А можно еще круче прокачать консоль
Тоже устанавливаем пакет django-extensions
Далее в setting.py, в коллекции INSTALLED_APPS добавляем строку 
    'django_extensions',
и в консоль мы теперь переходим по команде 
python manage.py shell_plus
а можно еще круче. переходим по этой же команде с флагом --print-sql
python manage.py shell_plus --print-sql 
Теперь когда мы залетаем в консоль все импорты и модели импортируются автоматический
А если мы зашли с флагом --print-sql, когда мы добавляем строку, консоль сразу выводит красивый sql запрос который мы только что сделали

Чтобы выйти из консоли нужно прописать команду 
    exit



УРОК 4 МЕТОДЫ ВЫБОРА ЗАПЕСЕЙ ИЗ ТАБЛИЦЫ. LOOKUP

Каждый класс модели содержит специальный статический объект objects, который наследуется от базового класса Model и представляет собой ссылку на специальный класс Manager.
Благодаря нему мы можем обращаться ко всей таблицы нашей модели
Можно вывести его в терминале
    Women.objects
Этот объект называется "менеджер записей" и у него есть полезные методы
К примеру благодоря нему можно записывать строку в таблицу одной командой в терминале, при помощи его метода create
Women.objects.create(title='Ума Турман', content='Биография Ума Турман') 
мы можем сохранить эту команду в переменную и обращаться к его параметрам, как если бы записали сам объекь класса (т.е. строку таблицы)

У objects много полезных методов:
- all() - показывает список всех объектов класса модели (строк) в таблице
    Women.objects.all() 
На выходе команды получим такой список
    <QuerySet [<Women: Women object (1)>, <Women: Women object (2)>, <Women: Women object (3)>, <Women: Women object (4)>, <Women: Women object (5)>, <Women: Women object (6)>]> 
Он не очень информативен. Но можно сделать его более понятным, поправив саму модель
Добавим в неё магический метод __str__, а выводом метода будет содержимое поля title
    def __str__(self):
        return self.title
Теперь вывод Women.objects.all() будет таким
    <QuerySet [<Women: Анджелина Джоли>, <Women: Энн Хэтэуэй>, <Women: Джулия Робертс>, <Women: Екатерина Гусева>, <Women: Ума Турман>, <Women: Кира Найтли>]> 
К этому списку можно обращаться по индексу, если мы хотим получить конкретное количество записей
    Women.objects.all()[0]
Все эти команды можно сохранять в переменной и обращаться к их атрибутом
Срезами тоже можно пользоваться
    w = Women.objects.all()[:3]
И прокручивать в цикле, мы же всё-таки в питонской консоле
    ws = Women.objects.all()
        for w in ws:
        print(w)
Кстати наша консоль при каждой команде всё еще показывает sql запрос и джанга делает их всегда максимально не нагруженными

- filter() - возвращает список строк где находит совпадение
Women.objects.filter(title='Энн Хэтэуэй')   # вернёт список строк где titile равен Энн Хэтэуэй
В этой команде совпадение должно быть полное, а не частью значения, т.е. так не сработает:
Women.objects.filter(title='Энн')  # вернёт пустой список, потому-что не наёдёт совпадений

Стандартные операторы сравнения и куча чего ещё тут не работает
т.е. так нельзя
Women.objects.filter(pk > 2)   # хотим найти все строки у кого id больше двух, но получим ошибку
Не работает, так как pk – это именованный параметр и ему нужно явно присваивать определенное значение
Поэтому подобниые операции делаются специальными методами, для методов objects
эти подметоды называются lookup’ы
К примеру вот методы сравнения
    <имя атрибута>__gte – сравнение больше или равно (>=);
    <имя атрибута>__gt – сравнение больше (>);
    <имя атрибута>__lte – сравнение меньше или равно (<=);
    <имя атрибута>__lt – сравнение меньше (<). 

Подробная информация о методах и lookup'ах в документации
https://docs.djangoproject.com/en/4.2/ref/models/querysets/#field-lookups 

Вот как сделать операцию Women.objects.filter(pk > 2) в этой программе
    Women.objects.filter(pk__gte=2)

Еще лукапы
__contains - ищет совпадение строки в поле
    Women.objects.filter(title__contains='ли')   # создаёт услови «WHERE title LIKE '%ли%'» в заросе sql
Выведет список всех строк где в title есть подстрока 'ли'
__icontains - тоже что __contains, но игнорирует регистр подстроки 
вот только это лукап не работет для sqlite потому-что, sqlite сама по себе так не умеет =)
__in - ищет строки со значением поля, равное значению элементу переданного списка и выводит все совпадения
Women.objects.filter(pk__in=[2,5,11,12])  # выведет все строки у котрых id равет 2,5,11,12   в нашем случае только 2 и 5

Можно передать через запятую сразу несколько условий совпадения для метода 
это будет значить что мы должны искать совпадения по двум условия с логическим И
    Women.objects.filter(pk__in=[2,5,11,12], is_published=1)  # внизу аналогичный запрос в sql
WHERE ("women_women"."is_published" AND "women_women"."id" IN (2, 5, 11, 12)) 

Ещё методы objects:
- exclude() - обратный метод filter.
т.е. он ищет не совпадения условия
    Women.objects.exclude(pk=2)  # вернет список записи где id не равен двум

- get() - гет делает тоже что и filter но возвращает значени а не список значений, причём только одно
если он найдёт несколько совпадений или не найдёт его вовсе, прилетит исключение
    Women.objects.get(pk=2)  # получем объект модели с идентификатором 2, а не список с одним объектом модели как filter
get удобен ещё и проверкой на то что в таблице существует только одна искомая запись, ведь если он найдёт несколько совпадений - он закрашится

Все лукапы работают со всеми методами objects, если не нарушают логику их работы



УРОК 4 СОРТИРОВКА, ИЗМЕНЕНИЕ, УДАЛЕНИЕ ЗАПИСЕЙ

Внутри нашей любимой консоли, можно делать сортировку как в sql запросе c order by
Это делается методом объекта objects - order_by() =) В него передаётся название поля по которумы мы будем сортировать
    Women.objects.all().order_by('title')  # вернёт все строки отсортировнные по title
строки сортируются по стандарту сортировки sql
    ORDER BY "women_women"."title" ASC
Можно кстати не указвать метод all()
    Women.objects.order_by('title')  # отработает также как и прошлый
метод order_by можно применять в цепочки с другими методами которые возвращают коллекцию QuerySet (список строк)
    Women.objects.filter(pk__lte=4).order_by('title')
Если мы хотим отсортировать в обратном порядке (DESC), вначале названия поля нужно поставить знак минуса
    Women.objects.order_by('-time_update')

Можно сделать так чтобы наша модель всегда была отсортированна по дефолту
Для этого в классе модели, нужно воспользоваться классом вложенным Meta
У этого класса есть множество атрибутов, которые отвечают за разные свойства модели
Например атрибут ordering, который делает дефолтную сортировку таблице
Или indexes, который делает поля индексируемыми, чтобы эта самая сортировка работала быстрее
В оба атрибута передаём список полей и их порядок сортировки/индексации
    class Women(models.Model):
        ...
        class Meta:
            ordering = ['-time_create']
            indexes = [           # для indexes нужно прописать класс models.Index с параметром fields, в который мы и передаём поля с учётом сортировки
                models.Index(fields=['-time_create']),
            ]
 
        def __str__(self):
            return self.title

Подробности о классе Meta и его методов, в документации
https://docs.djangoproject.com/en/4.2/ref/models/options/

После настройки класса модели наши поля всегда будут отсортированны, даже без order_by()
Women.objects.all()  # вернёт отсортированный список строк

Вспоминае про CRUD в SQL и очень хотим узнать как изменять таблицы и удалять данные
Для одной строки можно сохранить строку в переменную и напрямую передать новые значения атрибута объекта модели
    wu = Women.objects.get(pk=2)
    wu.title = 'Марго Робби'
    wu.content = 'Биография Марго Робби'
а потом методом save() изменить данные в таблице, ведь он не только создаёт данные, но и изменяет их
    wu.save()

Но если нам нужно изменить несколько или сразу все строки то нужно воспользоваться методом update в который передадим поле и его новое значение
    Women.objects.update(is_published=0)   # меняем значение is_published на 0 для всех строк
update() как и order_by() можно использовать в цепочки с другими методами
    Women.objects.filter(pk__lte=4).update(is_published=1) 
и она тоже работает только с коллекцией QuerySet (список строк) тоесть она не будет работать с методом get()
    Women.objects.get(pk=5).update(is_published=1)  # ошибка
а ещё update не работает со срезами
    Women.objects.all()[:4].update(is_published=1)   # тоже ошибка

И наконец удаление
Оно осуществляется благодаря методу delete()
Чтобы использовать можно добавить колеекцию QuerySet в переменную и к этой переменной применить метод delete()
wd = Women.objects.filter(pk__gte=5)
wd.delete()
Но можно и цепочкой как update
Women.objects.filter(pk__gte=5).wd.delete()



УРОК 5 SLUG В URL АДРЕСАХ. МЕТОД get_absolut_url()

в url адресах часто присутствуют слаг записи.
такие адреса лучше подходят для работы браузера и выглядят понятнее для пользователей
Адреса постов женщин на сайте используют используют загрлушку вместо нормального адреса.
В эти адреса и нужно добавить слаги, но сначала сделаем их по id

Для начала нужно сделать нормальную функцию представление, потому-что у нас там стоит заглушка
def show_post(request, post_id):
    post = get_object_or_404(Women, pk=post_id)
    data = {
        'title': post.title,
        'menu': menu,
        'post': post,
        'cat_selected': 1,
    }
    return render(request, 'women/post.html', context=data)
Что мы сделали?
воспользовались функцией get_object_or_404()
Она возвращает переданный объект класса (это объект нашей модели), с выбранным критерием
в данном случае этот критерий pk, т.е. идентификатор равный переданному в функцию аргументу post_id
Т.Е. сдесь аргумент функции pk будет говорить какую строку нам передовать изходя из динамического запроса маршрута show_post
Я так понимаю что можно и не передовать никаких аргументов кроме объекта класса, но тогда мы всегда будем получать первую строку модели.
Если же функция get_object_or_404 не может вернуть строку, то она вызовит объект класса Http404.
Далее создаём коллекцию для страници с данными для шаблона, где есть и сама строка модели и её поле title
А в render передаём новую страницу и коллекцию данных

Теперь создадим и шаблон.
В нём ничего нового, только фотку передаём, но это на будущее
{% extends 'base.html' %}
 
{% block content %}
<h1>{{post.title}}</h1>
 
{% if post.photo %}
<p ><img class="img-article-left" src="{{post.photo.url}}"></p>
{% endif %}
 
{{post.content|linebreaks}}
{% endblock %}

Итак мы реализовли урл по айдишнику, теперь можно переделать его по слагу.
Айдишник мы брали из бд pk=post_id, и слаг тоже надо брать от туда, но как?
Добавим новое поле в таблицу где и будем хранить наш слаг для каждо строки
slug = models.SlugField(max_length=255, unique=True, db_index=True)  # вот так он должен выглядеть
Он реалезован через метод SlugField, это строковый тип данных.
В нём есть параметр unique=True - значит он должен быть уникальным
также параметр db_index=True, т.е. мы делаем поле индексируемым, чтобы ускорить выборку
Но если мы сейчас замигрируем изменения в таблицы, то полезут ошибки
Потому что поле создастся пустым, а у нас по дефолту стоит NOT NONE если мы не указываем blank=True
а ещё у нас есть уникальност значений поля, что тоже не даст нам его создать, потому что у нас будут все значения одинаковыми.
Но мы можем создать это поле без уникальности и с разрешение NONE
потом замигрировать его, наполнить данными, соответствующими изначальному виду, и потом изменить поле на нужный нам формат.
Создадим же первую стадию поля и замигрируем его
slug = models.SlugField(max_length=255, db_index=True, blank=True, default='')
А теперь добавим значения в эти поля вручную
Можно сначала накидать каких нибудь значений заглушек.
Например в консоле фреймворка сделать так
    for w in Women.objects.all():
        w.slug = 'slug-'+str(w.pk)
        w.save()
А потом вернуться в модель и поменять поле на нужный нам формат и замигрировать его
slug = models.SlugField(max_length=255, db_index=True, unique=True)

Слаги готовы и теперь можно поменять в наших урл идентификаторы на слаги

Сначала в маршруте поменяем конвертер с post/<int:post_id>/ на post/<slug:post_slug>/

Теперь и во вьюшке поменяем айдишник на слаг
def show_post(request, post_slug):
    post = get_object_or_404(Women, slug=post_slug)

теперь наши посты открываются по урл со слагом 
http://127.0.0.1:8000/post/slug-1/

Всё работает и теперь можно сделать слаги красивыми (можно вручную прямо в dbeaver)
    andzhelina-dzholi
    margo-robbi
    dzhuliya-roberts
    ekaterina-guseva 
Поменяли и урл стали лучше
http://127.0.0.1:8000/post/andzhelina-dzholi/


Теперь можно поправить кнопочки на сайте, ведь наши ссылки в html никто не трогал и они работают по старым данным
<p class="link-read-post"><a href="{% url 'post' p.id %}">Читать пост</a></p>
Но для url со слагом нужно формировать урл не при помощи шаблонного тега url, а при помощи собственного метода модели

Создадим этот метод в моделе
    def get_absolute_url(self):
        return reverse('post', kwargs={'post_slug': self.slug})  # вспоминаем как мы сравнивали тег url с функцией reverse
кстати не забываем импортировать from django.urls import reverse
Название метода и его тело конечно произвольное, но оно образцовое.
т.е. именно так джанго рекомендует называть и и создавать этот метод для того чтобы формировать урл со слагом

Теперь этот метод можно вызывать в шаблоне html
было так - {% url 'post' p.id %}
стало так - {{ p.get_absolute_url }}

Почему надо делать именно так а не просто поменять p.id на p.slug
Если вдруг мы захотим поменять url со слаг варианта, снова на id или на что-то друго. 
то нам придётся менять эту запись во всех тегах где она есть, а их может быть множество во множестве шаблонов.
Но теперь нам достаточно только параметр внутри функции revers, внутри функции get_absolute_url 
и url смениться везде где мы используем эту функцию
Ну и конвертер в маршруте тоже надо будет изменить.

Еще один плюс подобного подхода заключается в том что модули джанго используют эту функцию в своей работе
админ-панель обращается к этому методу для построения ссылок на каждую запись наших моделей.
В дальнейшем мы ещё узнаем об этом

тег url же стоит употреблять только для ссылок не связанных с моделями

Почти всё, осталось только передать нашу модель во вьюшку index
и изменить её коллекцию данных
(Вообще, это как будто бы можно было сделать намного раньше =-) )
def index(request):
    posts = Women.objects.filter(is_published=1)   # передаём строки с is_published равной true
    data = {
        'title': 'Главная страница',
        'menu': menu,
        'posts': posts,     # и добавляем объект модели в коллекцию для шаблона
    }
 
    return render(request, 'women/index.html', context=data)

Теперь у нас и ссылки красивые, и сделаны они как надо, и бд везде подсоеденино



УРОК 6 СОЗДАНИЕ ПОЛЬЗОВАТЕЛЬСКОГО МЕНЕДЖЕРА МОДЕЛИ

Ранее мы обращались к объекту модели благодоря стандартному джанго менеджеру objects.
Но мы можем создать свой собственный менеджер внутри модели, чтобы обращаться через него

Для этого в файле models.py нужно создать класс, относоледованный от класса Manager
и создать в нём метод, который будет возвращать родительский метод класса .get_queryset() который вызывает список записей нашей таблицы.
Тоже делает и сам object, но в своём менеджере мы можем добавить дополнительные методы к вызову, например для фильтрации данных
class PublishedModel(models.Manager):  # создаём класс
    def get_queryset(self):         # создаём метод
        return super().get_queryset().filter(is_published=1)   # вызываем родительский метод get_queryset() и к нему добавляем метод который будет принимать только строки с is_published ровным одному, т.е. True
так наш менеджер будет возвращать только строки с опубликованными статьями

Теперь, внутри модели нужно обявить объект этого класса нашего менджера.
    published = PublishedModel()

Важно знать!
Когда мы создаём модель. менеджер object создаётся автоматически.
Но когда мы создаём в моделе новый менеджер в модели, object перестаёт существовать
Но его существование всёже нужно для работы модели и его объект тоже нужно объявить внутри модели
    objects = models.Manager()
    published = PublishedModel()

У нас есть новый менеджер и теперь нам нужно поменять во всех вьюшках вызов объекта модели со старого на новый
Сначала поменяем в index
def index(request):
    posts = Women.published.all()   # к старому менеджеру мы прицепляли проверку на публикацию, а сейчас нам уже это не требуется
    data = {
        'title': 'Главная страница',
        'menu': menu,
        'posts': posts,
    }
 
    return render(request, 'women/index.html', context=data)

И во вюшке show_category тоже поменям. там кстати мы брали данные из бд заглушки - коллекция data_db, её можно удалить
def show_category(request, cat_id):
    data = {
        'title': 'Отображение по рубрикам',
        'menu': menu,
        'posts': Women.published.all(),
        'cat_selected': cat_id,
    }
 
    return render(request, 'women/index.html', context=data)

В шаблоне index.html мы делали проверку на публикацию записи, её тоже можно больше не делать. Сотрём!

Перечисляемые поля

Мы в нашей модели делаем проверку на публикицию при помощи is_published=1
Но это не очень информативная запись
потому-что, чтобы понять что мы проверяем, нужно лезть в таблицу и смотреть тип данных поля 
Можно сделать внешний вид этой проверки более читаемым
В этом нам поможет класс IntegerChoices он нужен для определения осмысленных имен для непонятных значений

Создадим собственный класс отнаследованный от IntegerChoices внутри модели
А внутри него создадим параметры равные кортежу (значение, описание)
    class Status(models.IntegerChoices):
        DRAFT = 0, 'Черновик'
        PUBLISHED = 1, 'Опубликовано'

По сути мы создали переменную со значением и коментарием о ней и сохранили в неё и значение и комментарий
Теперь можно подставлять эту переменную внутри нашей модели где угодно, вместо самого значения.
По названию этой переменной, легче понять её значение, но мы можем также обратиться и к описанию (комментарию) этой переменной

Поменяем значение в модели
    is_published = models.BooleanField(choices=Status.choices, default=Status.DRAFT)

Если поменяли модель то нужно и миграцию сделать

можно обращаться к этой переменной и внутри консоли фреймворка
w = Women.objects.all()
w.update(is_published=Women.Status.PUBLISHED)

И там же мы можем посмотреть значение и описания для нашего класса Status
Women.Status.choices - посмотреть список кортежей значение, описание  # [(0, 'Черновик'), (1, 'Опубликовано')] 
Women.Status.values - посмотреть список значений # [0, 1] 
Women.Status.labels - посмотреть список описаний # ['Черновик', 'Опубликовано'] 

Теперь значение поля is_published стало понятнее

Добавим новое оформление значение и в менеджер
class PublishedModel(models.Manager):
    def get_queryset(self):
        return super().get_queryset().filter(is_published=Women.Status.PUBLISHED)



СВЯЗИ МЕЖДУ ТАБЛИЦАМИ



УРОК 1 ТИПЫ СВЯЗЕЙ МЕЖДУ МОДЕЛЯМИ

В реальной бд множество таблиц и многие из низ связанны
В модели, поля для связи таблиц определяются следующими следующими классами
    ForeignKey – для связей Many to One (многие к одному);
    ManyToManyField – для связей Many to Many (многие ко многим);
    OneToOneField – для связей One to One (один к одному). 
Подробнее об этом в документации:
https://docs.djangoproject.com/en/4.2/ref/models/fields/#module-django.db.models.fields.related



УРОК 2 СОЗДАНИЕ СВЯЗИ MANY-TO-ONE

Итак, пора делать нашу бд более похожую на бд настоящего проекта
У нас есть список категорий женщин и дожна быть таблица с этими категориями
которая связана с таблицей женьщин по связи many-to-one

Создаём вторую таблицу, а значит, вторую модель в файле models.py
Выглядить будет так
В мадели ничего нового, описаны два поля - название котегории, и её слаг для оброзования url
Айдишник как мы помним создаётся автоматически
Строковое представление объекта модели, будет равно значению поля названия в строке
class Category(models.Model):
    name = models.CharField(max_length=100, db_index=True)
    slug = models.SlugField(max_length=255, unique=True, db_index=True)
 
    def __str__(self):
        return self.name

Чтобы связать таблицы, во вторичной таблице нужно создать поле - вторичный ключ для связующей таблицы
И тут есть маленькие тонкости
Как мы помним тип объекта этого поля должен быть реализован классом ForeignKey
Он принимает в себя два параметра - Объект модели связанной таблицы и тип ограничения при удалении внешней записи
Если мы пропишем объект модели, "то интерпритатор может начать ругаться", потому-что мы еще не создали эту модель, т.е. не замигрировали её
Поэтому, в этом случае можно прописать название класса модели в строковом виде т.е. в кавычках.
ограничения при удалении внешней записи - отвечает за то, что будет происходить со строкой во вторичной таблице если мы удалим связанную строку в первичной таблице.
Эти типы определены функциями и нам нужно передать одну из множества вариантов этих функций во второй аргумент класса ForeignKey под названием on_delete
Вот они эти функции:
    models.CASCADE – удаление всех записей из вторичной модели (например, Women), связанных с удаляемой категорией;
    models.PROTECT – запрещает удаление записи из первичной модели, если она используется во вторичной (выдает исключение);
    models.SET_NULL – при удалении записи первичной модели (Category) устанавливает значение foreign key в NULL у соответствующих записей вторичной модели (Women);
    models.SET_DEFAULT – то же самое, что и SET_NULL, только вместо значения NULL устанавливает значение по умолчанию;
    models.SET() – то же самое, только устанавливает пользовательское значение;
    models.DO_NOTHING – удаление записи в первичной модели (Category) не вызывает никаких действий у вторичных моделей. 
Подробности о этих функциях в документации
https://docs.djangoproject.com/en/4.2/ref/models/fields/#arguments
Создадим же это поле
cat = models.ForeignKey('Category', on_delete=models.PROTECT)
Оброщаем внимание на то, что мы называем объект класса просто cat, а не cat_id какое у неё и должно быть название.
Но ничего страшного - полное название для поля в таблице cat_id, джанго допишет сам
Новые таблицу и поле добавили, но замегрировать их не получиться.
Потому-что у нашего вторичного ключа по дефолту стот настройка NOT NULL, 
а при создании таблицы строк в ней не будет, следовательно и ссылаться не на что 
Поэтому в момент создания таблицы и вторичного ключа, для вторичного ключа разрешим иметь значение null, а когда добавим значения в первичную таблицу уберем разрешение на null
И по итого наше поле в момент создания будет выглядить так:
    cat = models.ForeignKey('Category', on_delete=models.PROTECT, null=True)

Теперь можно делать миграцию

Таблицы и поле созданны и теперь перйдём в консоль фреймворка и добавим в нашу новую таблицу данные, уже знакомым способом
Category.objects.create(name='Актрисы', slug='aktrisy')
Category.objects.create(name='Певицы', slug='pevicy')

А после добавим значения для вторичного ключа в таблице women
w_list = Women.objects.all()
w_list.update(cat_id=1)

И теперь можно выйти из консоли, удалить разрешение на null во вторичном ключе и замигрировать изменения

Можно перейти в консоль и проверить работоспособность наших новых данных
К примеру поробывать удалить первую строку в таблице Category
c = Category.objects.get(pk=1)
c.delete()
Но у нас ничего не выйдет, потому-что не даст параметр PROTECT в классе ForeignKey
Но не связанные строки можно удалять

А вот если бы у нас вместа параметра PROTECT был параметр CASCADE
при удалении строки категории, удалились бы все строки во вторичной таблице, связанные с этой категорией



УРОК 3 ORM КОМАНДЫ ДЛЯ СВЯЗИ MANY-TO-ONE

Как мы знаем наше поле, внутри таблицы, во вториченой модели называется cat_it.
Но сам атрибут класса моделили, называется просто cat
В орм мы можем обращаться к модели и по названию поля таблицы и по атрибуту класса модели
Но при этом мы будем получать разные данные.
При обращение по названию поля в таблице, мы получим значение поля
w = Women.objects.get(pk=1)
w.cat_id  # 1
А при обращение по атрибуту, мы получим объект связанной модели который связан с нашим объектом
w.cat  # вернётся объект модели Category с id равным cat_id
И раз мы можем достучаться через одну модель к другой связанной, то мы также можем и достучаться к её атрибутам
w.cat.name   # Актрисы

Но можно делать и наоборот - взаимодействовать со вторичной моделью через первичную
Когда мы связываем модели, у вторичной модели автоматически появляется встроенный метод который называется - <вторичная модель>_set
через этот метод мы можем подключаться к менеджеру вторичной модели из первичной, он как-бы и есть ссылка на менеджер втроичной модели
Используя его мы можем брать объекты первичной модели и относительно них, подключаться ко вторичной модели
т.е. запрашивать вторичную модель со связанными объектами с объектом объектом первичной модели 
c = Category.objects.get(pk=1)  # сохранили объект менеджера модели Category
c.women_set.all() # возьми все объекты втор. модели связанные с переменной с (Актрисы)

Методу women_set можно придать собственное название.
Делается это в классе первичной модели, для поля вторичного ключа
В класс ForeignKey нужно передать дополнительный аргумент related_name= и строковое значение которое будет являтся название метода women_set
related_name='posts'
cat = models.ForeignKey('Category', on_delete=models.PROTECT, related_name='posts')
Делать миграцию после этого не нужно но может потребоваться перезайти в orm
Теперь мы можем обращаться по этому методу с новым именем
c = Category.objects.get(pk=1)
c.posts.filter(is_published=1)

Так как атрибут cat для второй модели является обектом класса вторичной модели
мы можем делать фильтрацию запросов черз этот обект класса и для него делать лукапы
cats = Category.objects.all()
Women.objects.filter(cat__in=cats)
Это аналог записи
Women.objects.filter(cat_id__in=[1, 2])  # тоже самое
Women.objects.filter(cat__in=[1, 2])     # тоже самое

Мы также можем использовать атрибуты объекта первичной модели, используя их как лукапы
Women.objects.filter(cat__slug='aktrisy')  # покажи все объекты втор. модели связанные с объетом перв. модели у которой значение поля slug равно aktrisy
Можно делать тоже самое но еще и в совакупе с лукапами
Women.objects.filter(cat__name__contains='ы') # покажи все строки women связанные со строкой Category где в поле name есть совпадение с подстрокой 'ы'
И тоже самое можно делать и для перв. модели связывая её с вторичной через метод связи с её менеджером
Category.objects.filter(posts__title__contains='ли')  # покажи все все строки первичной модели которые входят во вторичную модель где в её строке, в поле title есть совпадение с подстрокой 'ли'
В этом запросе мы запрашиваем таблицу category и при одинаковых совпадениях наши строки будут дублироваться
В SQL есть функция distinct которая уберает дублирующие значения в выводе.
В ОРМ есть функция с аналогичным названием, которая добавляет в sql запрос вышеозвученную функцию
Category.objects.filter(posts__title__contains='ли').distinct()



УРОК 4 ОТОБРОЖЕНИЕ ПОСТОВ ПО РУБРИКАМ

В этом уроке нет новой информации по джанго мы просто модернизируем на проект, используя уже знакомые нам методы
Цель урока сделать отображение постов по категориям. т.е. добавить нашу новую таблицу в маршрут категорий и поменять шаблон

сначала изменим маршрут и будем делать его по слаг конвертеру:
path('category/<slug:cat_slug>/', views.show_category, name='category'),

Следом меняем вьюшку
И не забываем импортировать модель Category
def show_category(request, cat_slug):
    category = get_object_or_404(Category, slug=cat_slug)   # сохраняем объект модели Category
    posts = Women.published.filter(cat_id=category.pk)    # и объект модели Women
    data = {
        'title': f'Рубрика: {category.name}', меняем отображение title страницы для шаблона
        'menu': menu,
        'posts': posts,    
        'cat_selected': category.pk,  # меняем id бд заглушки, на id Category 
    }
 
    return render(request, 'women/index.html', context=data)

Вспоминаем что наши рубрики отображаются с помощью пользовательского шаблонного тега (то что мы делали для изменения цвета и ссылки рубрики)
он тут если что templatetags/women_tags.py
там мы брали данные из бд заглушки, а сейчас будем из реальной бд
@register.inclusion_tag('women/list_categories.html')
def show_categories(cat_selected_id=0):
    cats = Category.objects.all()   # берем категории из бд Category 
    return {"cats": cats, "cat_selected": cat_selected_id}
Так как мы добавили нашу модель в этот файл, то её тоже нужно импортировать

Ну и погнали менять шаблон
урл в шаблоне брался из {% url 'category' cat.id %}
а мы воспользуемся нормальной функцией - cat.get_absolute_url
{% for cat in cats %}
         {% if cat.id == cat_selected %}
                   <li class="selected">{{cat.name}}</li>
         {% else %}
                   <li><a href="{{ cat.get_absolute_url }}">{{cat.name}}</a></li>
         {% endif %}
{% endfor %}

МЫ воспользовались функцией get_absolute_url, но ещё не создали её в Category, погнали создавать!
    def get_absolute_url(self):
        return reverse('category', kwargs={'cat_slug': self.slug})

Вот и всё!
Но как же без дополнительных модификаций?

Добавим в наши статьи вывод названия рубрики и время публикации поста:
Бд уже подключена везде где надо, а значит правки нужны только в шаблоне
Отображение будет чуть выше названия поста
тоесть перед строкой <h2>{{p.title}}</h2> в нашем цикле постов нужно внутри шаблона
            <div class="article-panel">
            <p class="first">Категория: {{p.cat.name}}</p>
            <p class="last">Дата: {{p.time_update|date:"d-m-Y H:i:s"}}</p>
            </div>



УРОК 5 ДОБАВЛЯЕМ СВЯЗЬ MANY-TO-MANY

Для создания связи мany-to-many сперва создадим таблицу с которорой будем связываться
это будет таблица с тегами постов (внешние критерии женщин)

Вообще для тегирования данных существует множество модулей в джанго и при реальной задаче удобнее найти и воспользоваться существующем модулем. посмотреть их можно тут
https://django-taggit.readthedocs.io/en/latest/
Но мы всё сделаем вручную

создаём модель, пока ничего нового
class TagPost(models.Model):
    tag = models.CharField(max_length=100, db_index=True)
    slug = models.SlugField(max_length=255, unique=True, db_index=True)
 
    def __str__(self):
        return self.tag


Модель для промежуточной таблицы создавать не нужно, таблица создастся автоматически если джанго поймёт что две таблицы связанны 
А чтобы джанго это понял в поле основной (women) таблицы нужно добавить поле с кассом ManyToManyField
У ManyToManyField из обязательных параметров только название модели с которой будет связь.
Никаких условий при удаление связанных записий писать не нужно, оно и логично
Но мы также можем указать и другие настройки поля, точнее настройки связи
например разрешить значение null или задать имя для менеджера связи с таблицей
Мы создаём поле в модели, но этот класс не создаёт реальную колонку в таблице, ведь связь реализованна в промежуточной таблице
    tags = models.ManyToManyField('TagPost', blank=True, related_name='tags')
Подробнее о классе ManyToManyField в документации

модели и связи созданны значит пора делать миграцию
    python manage.py makemigrations 
    python manage.py migrate 

Всё супер, погнали в ORM добавлять данные в новую таблицу
    TagPost.objects.create(tag='Блондинки', slug='blonde')
    TagPost.objects.create(tag='Брюнетки', slug='brunetky')
    TagPost.objects.create(tag='Оскар', slug='oskar')
    TagPost.objects.create(tag='Олимпиада', slug='olimpiada')
    TagPost.objects.create(tag='Высокие', slug='visokie')
    TagPost.objects.create(tag='Средние', slug='srednie')
    TagPost.objects.create(tag='Низкие', slug='niskie')

Теперь мы можем присвоить наши теги (установить связь) к нашим женщинам
    a = Women.objects.get(pk=1)   # возьмём строку из первой тиблицы женщин
    tag_br = TagPost.objects.all()[1]  # возьмём тег из таблицы тегов
    tag_o, tag_v = TagPost.objects.filter(id__in=[3, 5])  # сохраним ещё пару тегов

Так как мы связали две таблицы у наших объектов для связи появился новый менеджер и мы изначально назвали его tags
Он и осуществляет добавление новых тегов для основной таблицы (связывает данные)
точнее его метод set
    a.tags.set([tag_br, tag_o, tag_v]) # добавим свяжем нашу строку со всеми нашими тегами
Если нужно добавить только один тег для этого используется метод add
    a.tags.add(tag_br)
Если добавить тег который уже и так добавлен, ничего не произайдёт, дублирования не будет
можно удалить тег при помощи метода remove
    a.tags.remove(tag_o)
И просматривать все теги связанные со строкой 
    a.tags.all()
или наоборот посмотреть все строки связанные с тегом
    tag_br.tags.all()

Мы не можем одновременно создавать строку и сразу связывать её с тегом
Women.objects.create(title='Ариана Гранде', slug='ariana-grande', cat_id=2, tags=[tag_br, tag_v])
Потому что, связваются через идентификатор и у создаваемой строки его ещё нет, значит и связь не установить
Поэтому сначала создаём строку, а потом связываем с тегами



УРОК 6 ДОБАВЛЕНИЕ ТЕГОВ НА САЙТ

В этом уроке практически нет ничего нового, мы просто модернизируем сайт по уже знакомым методам

Цель урока сделать меню отображения тегов, как мы делали для меню категорий
А потом сделать отоброжение тегов в посте, тех что с ним связанны конечно

Полетели!
Сначала прописываем маршрут для меню тегов
    path('tag/<slug:tag_slug>/', views.show_tag_postlist, name='tag'),

Создадим функцию get_absolute_url для модели тегов
    def get_absolute_url(self):
        return reverse('tag', kwargs={'tag_slug': self.slug})

Теперь создадим и вьюшку для меню тегов, (не забываем импортировать модель):
    def show_tag_postlist(request, tag_slug):
        tag = get_object_or_404(TagPost, slug=tag_slug)
        posts = tag.tags.filter(is_published=Women.Status.PUBLISHED)  # через менедже tags достаём связанные с ним опубликованные строки из таблицы women
        data = {
            'title': f'Тег: {tag.tag}',   # tag.tag - 1) переменная внутри функции, 2) поле tag внутри таблицы
            'menu': menu,
            'posts': posts,
            'cat_selected': None,
        }
 
        return render(request, 'women/index.html', context=data)

Когда мы будем сортировать посты на сайте через теги, наши категории не должны подсвечиваться, а там сейчас всегда что-светит
Исправим это, но пока только во вюшке index, добавив добавив в пердоваемую коллекцию переменную cat_selected = 0
    def index(request):
        data = {
            'title': 'Главная страница',
            'menu': menu,
            'posts': Women.published.all(),
            'cat_selected': 0,
        }

    return render(request, 'women/index.html', context=data)

И создадим шаблонный тег для отображения меню тегов, как делали для категорий (не забываем импортировать модель)
Он просто передаёт все теги что у нас есть
    @register.inclusion_tag('women/list_tags.html')
    def show_all_tags():
        return {"tags": TagPost.objects.all()}


Полетели создавать html для меню тегов women/list_tags.html
Там всё предельно просто, нужно прокрутить все теги циклом
{% if tags %}
    Теги:</p>
    <ul class="tags-list">
        {% for t in tags %}
        <li><a href="{{t.get_absolute_url}}">{{t.tag}}</a></li>
        {% endfor %}
    </ul>
{% endif %}

Далее меняем базовый шаблон, добавление в сайдбара меню тегов, он будет идти после сайдбара ютуб канала
<li>{% show_all_tags %}</li>
Вот так будет выглядеть весь сайдбар
<!-- Sidebar слева -->
    <td valign="top" class="left-chapters">
        <ul id="leftchapters">
        {% if cat_selected == 0 %}  # Мы убрали проверку cat_selected is None чтобы не святилось когда мы в меню тегов
            <li class="selected">Все категории</li>
        {% else %}
            <li><a href="{% url 'home' %}">Все категории</a></li>
        {% endif %}
        {% show_categories cat_selected %}

        <li class="share">
        <p>Наш канал</p>
        <a class="share-yt" href="https://www.youtube.com/channel/UClJzWfGWuGJL2t-3dYKcHTA/playlists" target="_blank" rel="nofollow"></a>
        </li>
            <li>{% show_all_tags %}</li>   # вот наше меню
    </ul>
</td>
<!-- Конец Sidebar'а -->

Прямо под сайдбаром мы создавали на будущее блок
    <!-- Хлебные крошки -->
    {% block breadcrumbs %}
    {% endblock %}
Мы делали это как раз для того чтобы в постах отображать теги связанные с постом

Меню создано, осталось только добавить отоброжение связанных тегов внутри страницы поста
Прямо в самом начале шаблона post.html (потому-что отоброжение тегов будет вверху) допишим такой код
{% block breadcrumbs %}
<!-- Теги -->
{% with post.tags.all as tags %} # тег with позволяет создавать переменные использую пайтон код
{% if tags %}
<ul class="tags-list">
    <li>Теги:</li>
    {% for t in tags %}
    <li><a href="{{t.get_absolute_url}}">{{t.tag}}</a></li>
    {% endfor %}
</ul>
{% endif %}
{% endwith %}
{% endblock %}



УРОК 7 СВЯЗЬ ONE-TO-ONE

Создаём связь one-to-one
В уроке нам нужно будет создать таблицу для этой связи
и связать наши данные с этой таблицей
Таблица будет хранить данные мужей наших женьщин

Создаём таблицу
class Husband(models.Model):
    name = models.CharField(max_length=100)
    age = models.IntegerField(null=True)
 
    def __str__(self):
        return self.name

И добавляем поле в основную модель для связи таблиц
Связь таблиц о-т-о осуществляется классом OneToOneField
В класс нужно передать имя связанной модели и что делать с если запись в ней удалиться - on_delete
    husband = models.OneToOneField('Husband', on_delete=models.SET_NULL, null=True, blank=True, related_name='wuman')
SET_NULL - делает так чтобы если запись удалилась, начение поля поменялось на null
имя менеджера для обратной связи тоже задали

Мигрируем!

Все создалось и теперь можно перейти в ОРМ и работать с таблицами

Добавим данные в таблицу мужей
    h1 = Husband.objects.create(name="Брэд Питт", age=59)
    h2 = Husband.objects.create(name="Том Акерли", age=31)
    h3 = Husband.objects.create(name="Дэниэл Модер")
    h4 = Husband.objects.create(name="Кук Марони")

Теперь свяжем строки с двух таблиц
    w1 = Women.objects.get(pk=1) # берем джоли
    w1.husband = h1 # к полю husband для джоли присвоем значение равное объекту модели мужей Бреда Питта
    w1.save() # Сохраняем данные

Чекаем таблицу и видем что в поле husband для строки Джоли есть значение равное идентификатору Бреда Питта в его таблице
Можено и в ОРЬ это посмотреть
    w1.husband
Можно посмотреть и жену Питта через менеджер обратной связи
    h1.wuman

Связывать строки таблиц тоже можно через вторую таблицу
    w2 = Women.objects.get(pk=2) 
    h2.wuman = w2 # Присваеваем мужу объект - жену через менеджер
Далее сохраняем, но тут важный момент, так как мы добавляем данные в таблицу женьщин, и сохранять нужно объект женьщин
Хоть мы исвязывали через обект - муж
    w2.save()

Если связать строку в первой таблицы с уже связанной строкой во второй, вылетит ошибка
Ведь связь О-Т-О значит уникальность вторичного ключа
Но мы можем убрать связь строк и после этого можно связывать с ранее занятой строкой из втроой таблицы с другой строкой первой
    w2.husband = None
    w2.save()
    w3.husband = h2
    w3.save()

Конечно же мы можем достучаться до полей второй таблицы через первую
    w1 = Women.objects.get(pk=1)
    w1.husband.name
    w1.husband.age
И даже можем менять так эти значения
    w1.husband.age = 30
    w1.husband.save()
Питту снова 30 лет, теперь он выглядит на свой возраст



ПОГРУЖЕНИЕ В ORM Django



Погружение в ORM Django



УРОК 1 ORM-КОМАНДЫ С КЛАССОМ Q

Когда мы только начинали изучать ОРМ мы внутри методов объектов мы использовали разные услови и иногда их комбинировали
    Women.objects.filter(pk__in=[2,5,7,10], is_published=True) # комбинируем условие pk__in=[2,5,7,10] и is_published=True
При этом комбинация происходила всегда с логическим И

Но у нас есть ещё и логические ИЛИ и НЕ
Как их сделать

Для этого в ОРМ реализован класс Q, благодаря нему мы можем делать все логические операции

Но чтобы им пользоваться нужно импортировать его внутри ОРМ
from django.db.models import Q
Если используем shell_plus, он по дефолту импортируется

Чтобы работать с любым лог. оператором условия внутри методов, нужно обернуть в класс Q - Q(pk__in=[2,5,7,10])
А вместо запятой разделяющий условию нужно поставить спец. символ который и определяет логич. выражение
    & логическое И (приоритет 2);
    | логическое ИЛИ (приоритет 1 – самый низкий);
    ~ логическое НЕ (приоритет 3 – самый высокий). 

Вот как выглядит полная команда
    Women.objects.filter(Q(pk__lt=5) | Q(cat_id=2)) # pk меньше нуля ИЛИ cat_id равен 2

Логическое И тоже можно использовать для класса Q
    Women.objects.filter(Q(pk__lt=5) & Q(cat_id=2))
Как если бы мы это делали и без него
    Women.objects.filter(pk__lt=5, cat_id=2)

Если перед классом поставить знак тильды ~ то к условию добавиться логическа НЕ
    Women.objects.filter(~Q(pk__lt=5) | Q(cat_id=2)) # pk не равно 5 или cat_id равно 2

Q классы можно комбенировать и с условиями без него
    Women.objects.filter(Q(pk__in=[1, 2, 5]) | Q(cat_id=2), title__icontains="ра") 
    # pk__in=[1, 2, 5] ИЛИ cat_id=2 И title__icontains="ра"

Но обычные условия должны идти после классов Q, а не перед ними
Иначе все условия с Q классом не будут отдельными независимыми условия
Они будут находиться внутри одного услови, т.е. в скобках
    Women.objects.filter(title__icontains="ра", Q(pk__in=[1, 2, 5]) | Q(cat_id=2))
    # title__icontains="ра" И ( pk__in=[1, 2, 5] Или cat_id=2 ) - всего два условия
Поэтому лучше сделать так
    Women.objects.filter(Q(title__icontains="ра"), Q(pk__in=[1, 2, 5]) | Q(cat_id=2)) # все условия будут независимыми
А лучше так
    Women.objects.filter(Q(pk__in=[1, 2, 5]) | Q(cat_id=2) & Q(title__icontains="ра"))
потому-что порядок условий важен - он влияет на читаемост и работу SQL запросов,
ведь у логических операций есть свой порядок выполнения, в ОРМ он тот же что и в SQL
сначала выполняется НЕ, затем, И и в последнюю очередь ИЛИ. 



УРОК 2 БОЛЬШЕ МЕТОДОВ ДЛЯ ОРМ!!!

Урок посвещен новым методам в орм для выборки данных

first() - показывает первую запись в таблицы
Women.objects.first()
Не стоит забывать про дефолтную сортировку реализованную в модели классом Meta
Когда мы используем методы для выборки в ОРМ
Мы используем их относительно дефолтной выборки модели, а она реализованна с обратной сортировко,
точнее с сортировко по меньшему значению поля time_create
    class Meta:
        ordering = ['-time_create']
        indexes = [
            models.Index(fields=['-time_create'])
        ]

В таком случае метод first() вернёт нам первое значение относительно сортированной таблицы и все другие методы выборки тоже
Но если мы хотим сделать метод относительно id то можно скомбенировать с функцией сортировки
    Women.objects.order_by("-pk").first()
Или через метод last(), который возвращает последнюю строку
    Women.objects.order_by("pk").last()

earliest() - используется с полями типа данных - datetime, возвращает объект из кверисет с самым меньшим значением datetime
(позднее время), принимае поле с типом datetime по которому и будет искать самою раннюю дату и время
    Women.objects.earliest("time_update")
latest() - обратный метод earliest, ищет самое большее значение datetime (свежая дата), 
    Women.objects.latest("time_update")

get_previous_by_  - возвращает предидущую запись относительно объекта к которому применяется метод
К названию метода нужно дописать имя поля типа datetime, как если бы имя поля было частью названия метода и поставить скобки()
    w = Women.objects.get(pk=2) # сохраняем объект
    w.get_previous_by_time_update() # выбираем следующую более позднюю запись по полю time_update относительно переданной записи
w.get_next_by_ - ну и как же без аналогичного, обратного метода
    .get_next_by_time_update() - возвратит более свежую запись
В эти функции ещё и условия можно запихать, чтобы мы искали запись учитывая эти условия
    w.get_next_by_time_update(pk__gt=3) # вернёт следующую запись, где pk больше трёх

exists() - проверяет есть ли переданный аргумент в применяемому кверисету
в аргументы принимает объект модели, т.е. проверяет наличае строк одной таблицы которые связанны с переданной строкой
показывает True если есть совпадения и False если нет
    c2 = Category.objects.get(pk=2)
    c2.posts.exists() # если что posts это имя менеджера обратной связи для таблицы Women и Category и он как раз возвращает кверисетом все строки с котегорией c2

count() - считает сколько совпадений количество объектов в кверисете
    Women.objects.filter(cat=c2).count()



УРОК 3 КЛАСС F, Value И МЕТОД annotate()

Мы можем передовать в методы в ОРМ разные значения подходящие по логие относительно метода и применяемого объекта
    Women.objects.filter(pk__lte=2) # передали в фильтр и его условие значение 2
И это нормально работает

Но мы не можем передать значением имя поля, чтобы это работало как значение из этого поля
    Women.objects.filter(pk__gt="cat_id") # "cat_id" воспримется как строка и у нас полетит ошибка, потому что сравниваем с pk
Но вообще мы можем так делать.и в этом нам поможет класс F
Сначала его нужно импортировать
    from django.db.models import F
Используя его мы можем просто завернуть "Неподходящее" значение в этот класс и джанга поймет что мы применяем не строку
а значение поля, название которого мы передали в класс F
    Women.objects.filter(pk__gt=F("cat_id")) # так это работает, каждая строка будет сравниваться со своим cat_id

Больше примеров чтобы лучше понять этот класс

Создадим дополнительное поле в модели мужей
    m_count = models.IntegerField(blank=True, default=0) # счетчик женитьб
Мигрируем!

Счетчик по дефолту при создание равен нулю
Го увеличим у всех этот счётчик на один
    Husband.objects.update(m_count=F("m_count")+1)  # в класс F положили не ноль, а значение m_count

Можно увеличить счетчик только для одной записи
    h = Husband.objects.get(pk=1)
    h.m_count = F("m_count") + 1
    h.save()

Метод annotate() - позволяет искуственно создать дополнительное поле, в которое можно передать значение
Значение нужно передать используя класс Value, который тоже надо импортировать
from django.db.models import Value
    lst = Husband.objects.all().annotate(is_married=Value(True)) # ко всем строка таблице Husband добавим дополнительное поле
    с названием is_married и значением True (без Value() не сработает)
Можно прокрутить всю нашу табличук циклом и посмотреть что получилось
    for i, x in enumerate(lst):
        if i == 0:
            print(list(x.__dict__)[1:]) # вот так мы выводим сначала поля
        print(list(x.__dict__.values())[1:]) # потом строки
Получается как-то так
    ['id', 'name', 'age', 'm_count', 'is_married'] # Видим в конце новое поле is_married
    [1, 'Брэд Питт', 30, 4, True]  # И у всех строк в этом поле значение True
    [2, 'Том Акерли', 31, 1, True]
    [3, 'Дэниэл Модер', 54, 1, True]
    [4, 'Кук Марони', 37, 1, True]
    [5, 'Сергей Балакирев', 101, 1, True] 

В класс Value можно вставлять python выражения 
    lst = Husband.objects.all().annotate(is_married=Value(2 + 5)) # у всех полей будет значение 7
    lst = Husband.objects.all().annotate(is_married=Value("hi "*3)) # у всех полей будет значение hihihi
Но значени поля по названию мы передать не можем
    lst = Husband.objects.all().annotate(is_married=Value("m_count"*3)) # будет m_countm_countm_count
Но снова можно воспользоваться классом F, и кстати используя класс F, нам уже не нужен класс Value
    lst = Husband.objects.all().annotate(is_married=F("m_count"))
    lst = Husband.objects.all().annotate(work_age=F("age") - 20) # возраст минус 20
Внутри annotate() можно создавать сразу несколько полей и присваивать им значения, перечисляя их чере запятую
    lst = Husband.objects.all().annotate(work_age=F("age") - 20, salary=F("age") * 1.10) # создаём два поля work_age и salary
    со значениями F("age") - 20 и F("age") * 1.10
Ну и конечно можно использовать в одном выражении сразу несколько полей
    lst = Husband.objects.all().annotate(salary=F("age") * 1.10 - F("m_count") * 5)



УРОК 4 АГРЕГИРУЮЩИЕ ФУНКЦИИ Count, Sum, Avg, Max, Min. МЕТОД values()

С count мы уже знакомы, он вычисляет количество записей в кверисете
    Women.objects.count()

count и есть агрегирующая функция, агрегирующая функция это функция которая проходит по всем переданным полям и возвращает результат в одном значение, а не для каждого поля

Больше агрегирующих функций и информации о них в документации
https://docs.djangoproject.com/en/4.2/ref/models/querysets/#aggregation-functions

Агрегирующая функция, она и в SQL есть, и как раз-таки ORM ничего не придумывает, она просто вызывает такюже функцию внутри sql
а нам возвращает результат её работы

Добавим значение возраста мужьям для демонстрации работы других функций - 25 и 40 лет

Другие функции нужно будет импортировать
    from django.db.models import Count, Sum, Avg, Max, Min
Все эти функции реализованны классами, но работают как и все агрегирующие функции
Вот только они будут работать внутри другой функции aggregate
Она и вызывает одноименную функцию внутри SQL, и возвращает словарь с выводом этой функции
Min - вычисляет минимальное значени переданного поля
    Husband.objects.aggregate(Min("age")) # вычисли минимальный возраст у мужей
в aggregate можно вставить сразу две агрегатные функции и в возвращаемом словаре будут два ключа со значениями
Max - вычисляет максимальное значение переданного поля
    Husband.objects.aggregate(Min("age"), Max("age")) # вычисли минимальное и максимальное значени
    {'age__min': 25, 'age__max': 40} # вывод

Как видим ключем является название функции внутри sql запроса
Но мы можем присвоить друго название
    Husband.objects.aggregate(young=Min("age"), old=Max("age"))
    {'young': 25, 'old': 40} 

Внутри aggregate можно проводить вычислительные операции со значением возвращаемых функций
Но в таком случае обязательно указывать имя для первого значения
    Husband.objects.aggregate(res=Sum("age") - Avg("age"))
    {'res': 31.5} 
Avg - вычисляет среднее значение строк в переданном поле
    Women.objects.aggregate(Avg("id")) # среднее значение айдишников в таблице женщин

Функцию aggregate можно комбинировать с другими функциями которые возвращают кверисеты
    Women.objects.filter(pk__gt=2).aggregate(res=Count("cat_id")) # сколько строк в тблице женщин где id больше 2

Метод values() (не путаем с классом)
когда мы делаем запрос, мы запрашиваем все поля, даже если возвращаем значение только с одного
метод values() - позволяет нам указать в выборке только те поля которые нам нужны для вычисления значения
это сокращает select запрос, делает его менее нагруженным как визуально так и для процессора
он принимает название тех полей который мы хотим доставать select запросом
А возвращает коллекцию, с именами этих полей как ключ и значением этих полей как значение
    Women.objects.values("title", "cat_id").get(pk=1)
    {'title': 'Анджелина Джоли', 'cat_id': 1}
Мы также можем брать данные и из связанных полей
    Women.objects.values("title", "cat__name").get(pk=1)
    {'title': 'Анджелина Джоли', 'cat__name': 'Актрисы'}
Если мы передадим в values множество строк, то вернётся список из словорей
    Women.objects.values("title", "cat__name")
Этот список можно крутануть в цикле
    w = Women.objects.values("title", "cat__name")
    for p in w:
        print(p["title"], p["cat__name"])



УРОК 5 ГРУПИРОВКА СТРОК И ПРИМЕНЕНИЕ К НИМ АГРЕГИРУЮЩИЕ ФУНКЦИИ

Как и в SQL функция count счтает количество строк в переданной таблице.
Но если в неё передать значение (поле), функция будет считать количество разных значений этого поля в таблице
В ОРМ это работает тоже.
В SQL для этого необходимо делать групировку строк
Но в ОРМ - кверисет это исть групировка строк
Без функции values() групировка происходит по всем полям, из-за чего в группу входит только одна строка
т.к. у нас почти никогда не бывает полностью одинаковых строк (хотябы из-за того же айдишника)
Но с values() мы получаем только нужные нам поля и они уже могут дублироваться
values() показывает нам все строки, но если применить к ней агрегационную функцию, она воспримет дублирующие строки как сгрупированные.
В этом случае можно воспринимать что values() и есть групировка по полям, просто её вывод раскладывает эту групировку по всем входящим строкам, чисто для лучшего визуального понимания

Для лучшего понимания пример:
Посчитаем сколько строк таблицы женщин входят в разние категории
передадим все строки таблицы women, будем запрашивать только поле cat_id, 
и применим к этому count с переданным полем, неважно каким, главное чтобы значение было во всех строках
    Women.objects.values("cat_id").annotate(Count("id"))
разные значения cat_id и количество строк входящие в эти категории
    <QuerySet [{'cat_id': 1, 'id__count': 3}, {'cat_id': 2, 'id__count': 2}]> # 3 строки входят в первую категорию и 2 во вторую
Не забываем что мы можем задать собственное имя для вывода агр. функции
    Women.objects.values('cat_id').annotate(total=Count('id'))
    <QuerySet [{'cat_id': 1, 'total': 3}, {'cat_id': 2, 'total': 2}]>

Можно передовать в агр. функцию менеджер обратной связи чтобы вычислить агр. функцию для каждой строки в связанной таблице связанной с переданной таблицей (например считать сколько строк связанно с переданной строкой как в примере)
Мы также можем фильтровать подобные запросы
    lst = Category.objects.annotate(total=Count("posts")).filter(total__gt=0) # условие запрещает выводить данные со значением 0
И раскладывать этот кверисет в цикле
    for i, x in enumerate(lst):
     if i == 0:
         print(list(x.__dict__)[1:])
     print(list(x.__dict__.values())[1:])
-------------------------------------
    ['id', 'name', 'slug', 'total']
    [1, 'Актрисы', 'aktrisy', 3]
    [2, 'Певицы', 'pevicy', 2]

Также будет и стаблицей тегов
    lst = TagPost.objects.annotate(total=Count("tags")).filter(total__gt=0)

Используя полученные знания можно изменить функцию вывода тегов в сайтбаре, так чтобы мы видели только те теги с которыми связаны наши женщины
    @register.inclusion_tag('women/list_tags.html')
    def show_all_tags():
        return {"tags": TagPost.objects.annotate(total=Count("tags")).filter(total__gt=0)}


И тоже самое сделаем для категрорий
    @register.inclusion_tag('women/list_categories.html')
    def show_categories(cat_selected_id=0):
        cats = Category.objects.annotate(total=Count("posts")).filter(total__gt=0)
        return {"cats": cats, "cat_selected": cat_selected_id}

В Джанге существует множество агрегационных и вычислительных функций, смотреть можно в документации
https://docs.djangoproject.com/en/4.2/ref/models/database-functions/

Разберём одну из них
Length - это функция len в SQL, она вычисляет длинну строки
также принимает имя поля и работает по аналогии с другими агр функциями
    lst = Husband.objects.annotate(len_name=Length('name')) # посчитай длинну имён в каждой строке
Разложим в цикле и получим
    ['id', 'name', 'age', 'm_count', 'len_name']
    [1, 'Брэд Питт', 30, 4, 9]
    [2, 'Том Акерли', 31, 1, 10]
    [3, 'Дэниэл Модер', 54, 0, 12]
    [4, 'Кук Марони', 37, 1, 10]
    [5, 'Сергей Балакирев', 101, 0, 16] 



УРОК 6 ОПТИМИЗАЦИЯ САЙТА С Django Debug Toolbar

Сайт который мы разрабатываем всю дорогу, в принцапи уже можно считать за полноценный рабочий сайт.
Но хорошо ли работает этот сайт?
И что вообще даст нам оценку его работы?
Обычно работа сайта оценивается по этим критериеям:
    скорость работы приложения;
    нагрузку на СУБД (частоту и сложность запросов);
    корректность возвращаемых пользователю данных. 

А как определить эти характеристики на нашем сайте?
Поможет инструмент под названием Django Debug Toolbar

Погнали его скачивать!
    pip install django-debug-toolbar 

Теперь его нужно подключить к нашиму сайту, инструкция в документации
https://django-debug-toolbar.readthedocs.io/en/latest/installation.html

Но я конечно же её продублирую тут

Открываем setting.py и проверяем что в коллекции INSTALLED_APPS есть эта строка
    "django.contrib.staticfiles",
А если нет копируем её
Также проверяем наличае пути для статических файлов
STATIC_URL = "static/"

INSTALLED_APPS = [
    # ...
    "django.contrib.staticfiles",
    # ...
]

STATIC_URL = "static/"

Проверяем наличае строк в другой коллекции:
TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "APP_DIRS": True,
        # ...
    }
]

Теперь добавляем данные:
в этом же файле в коллекцию INSTALLED_APPS добавляем строку
    "django.contrib.staticfiles",
INSTALLED_APPS = [
    # ...
    "debug_toolbar",
    # ...
]

Тоже самое для коллекции MIDDLEWARE
MIDDLEWARE = [
    # ...
    "debug_toolbar.middleware.DebugToolbarMiddleware",
    # ...
]

создаём новую коллекцию INTERNAL_IPS и добавляем новую строку
INTERNAL_IPS = [
    '127.0.0.1',
]

Переходим в файл urls.py  пакета конфигурации (sitewomen.urls.py) и добавляем следующий маршрут: 
Но сначала нужно сделать необходимый импорт
    from debug_toolbar.toolbar import debug_toolbar_urls

    path("__debug__/", include("debug_toolbar.urls")),

Всё готово!
Теперь на нашем сайте появилась дополнительная панель со множеством вкладок
Перейдя по этим вкладкам мы можем посмотреть разную информацию о нём
Например во вкладке SQL мы можем посмотреть какие SQL запросы выполняются при переходе на данный урл
Переходим, смотрим, и видим что у нас дублируются запросы
SELECT ••• FROM "women_category" WHERE "women_category"."id" = 1 LIMIT 21
4 similar queries. Duplicated 3 times. 
Это не очень хорошо - дублирующиеся запросы тормозят сайт и от них можно избавиться

А запросы эти дублируются потому-то у нас по дефолту реализована "ленивая" загрузка данных когда мы берем данные из бд
т.е. на основной странице сайта у нас есть данные которые мы берем из таблицы, например категории
Но когда мы переходим на какую нибудь категорию, мы также находимся на главной странице, в которой также отображаются категории
Но данные берутся и для главной страницы и для и для адреса категорий, так они и дублируются

Как это исправить?
Мы можем сделать "жадную" загрузку данных, при помощи метода select_related()
C ним мы будем сохранять данные для передачи их другим страницам
Есть две функции для реализации "жадной" загрузки данных
    select_related(key) – «жадная» загрузка связанных данных по внешнему ключу key, который имеет тип ForeignKey;
    prefetch_related(key) – «жадная» загрузка связанных данных по внешнему ключу key, который имеет тип ManyToManyField. 

Функцию нужно применить к данным в коллекции внутри функций пердставления и вставить в них имя поля модели которое является вторичным ключем в таблице

вот как это выглядит во вьюшке index
def index(request):
    data = {
        'title': 'Главная страница',
        'menu': menu,
        'posts': Women.published.all().select_related('cat'),
        'cat_selected': 0,
    }

тоже самое нужно сделать и для представления категорий, и для тегов



АДМИН ПАНЕЛЬ



УРОК 1  ПОДКЛЮЧЕНИЕ АДМИНКИ И РЕГИСТРАЦИЯ МОДЕЛЕЙ
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
Перейдя по по адресу http://127.0.0.1:8000/admin/ мы попадаем в окно автризации
это окно авторизации админ панели - место где мы можем просматривать и управлять сайтом и его данными
Туда как правило могут попасть только владельцы и работники сайта, внутри проекта джанги настраевается доступ для пользователей

В файле setting.py можно изменить значение переменной LANGUAGE_CODE, для установки руского языка в админ панели
LANGUAGE_CODE = 'ru-RU'

Для входа в админку нужен логгин и пароль пользователя, но пока их нет совсем
Поэтому сначала нужно создать суперпользователя
    python manage.py createsuperuser
После введения команды нам потребуется задать логин суперпользователя, емейл и пароль

Залетаем в админку и видим пустые списки групп и пользователей, но не видим наши таблицы
Это потому-что мы их не зарегистрировали в админ панели

Регистрация моделей в админке происходит внутри приложения в файле admin.py
Чтобы зарегать модель сначала нужно её импортировать
    from .models import Women
А регистрация происходит блогодаря классу site из пакета admin и его метода register(), в который мы передаём модель
    admin.site.register(Women)

Смотрим админку и видим таблицу women
На неё можно перейти, увидить её строки и даже перейти на них и узнать все данные по строке
При этом в данных есть кнопка "смотреть на сайте"
Она реализована благодоря тому, что в нашей модели есть метод get_absolute_url(), без него кнопики не было бы

Можно настраивать админку.
Напиример изменить заголовки первого и второго уровня
    admin.site.site_header = "Панель администрирования" # _header изменяет заголовок первого уровня
    admin.site.index_title = "Известные женщины мира" # _title изменяет заголовок второго уровня

Название таблицы (заголовок), её отображение, её колонки тоже можно менять для отображения в админки
Но делается это уже внутри модели
Чтобы поменять отоброжение в классе Meta, нужно задать параметр verbose_name
а для отображения во множественном числе verbose_name_plural
        verbose_name = 'Известные женщины'
        verbose_name_plural = 'Известные женщины'

Для изменения заголовка нужно перейти в файл apps.py внутри приложения, там уже автоматически создан класс WomenConfig
    class WomenConfig(AppConfig):
        default_auto_field = 'django.db.models.BigAutoField'
        name = 'women'
В него нужно добавить параметр verbose_name и передать имя заголовка
    verbose_name = 'Женщины мира'



УРОК 2  НАСТРОЙКА ОТОБРАЖЕНИЯ СПИСКА СТАТЕЙ В АДМИНКЕ

Помимо настройки отображения админки, мы можем настраивать еще и сами таблицы внутри админки

Можно указывать какие поля таблицы мы хотим видеть внутри таблицы
Для этого нужно воспользоваться классом отображения моделей в файле admin.py
Создаём собственный класс отнаследованный от класс admin.ModelAdmin, предварительно зарегестрировав его в нашем регистраторе
    admin.site.register(Women, WomenAdmin)
    class WomenAdmin(admin.ModelAdmin):
И пердадим в класс параметр list_display который определяет какие поля будут отображаться в таблице, он принимает названия полей
Туда же можо передать параметр list_display_links, который отвечает за то какие поля будут являться ссылками на пост
Кстати, нам не обязательно пользоваться регистратором как списко с моделй
Мы можем использовать его как декоратор, и нам нам не нужно будет всегда пополнять коллекцию зарегестрированных моделей
    @admin.register(Women)
    class WomenAdmin(admin.ModelAdmin):
        list_display = ('id', 'title', 'time_create', 'is_published', 'cat')
        list_display_links = ('id', 'title')

Ещё в эту модель можно передать параметр ordering, котороый отвечает за сартировку таблицы для админ панели, он принимает список полей
Сортировка будет работать как в SQL когда мы передаём туда несколько полей
сначала по первому полю, а при совпадении значения по следующим полям, но в самой админки мы можем менять порядок сортировки
    ordering = ['-time_create', 'title']

Мы также можем изменить названия полей для отображения в админки
Но это делается уже в самой модели таблицы model.py
В классе самого поля, можно передать параметр verbose_name= и передать в него строку которая заменит название поля в админке

class Women(models.Model):
    class Status(models.IntegerChoices):
        DRAFT = 0, 'Черновик'
        PUBLISHED = 1, 'Опубликовано'
 
    title = models.CharField(max_length=255, verbose_name="Заголовок")
    slug = models.SlugField(max_length=255, db_index=True, unique=True)
    content = models.TextField(blank=True, verbose_name="Текст статьи")
    time_create = models.DateTimeField(auto_now_add=True, verbose_name="Время создания")
    time_update = models.DateTimeField(auto_now=True, verbose_name="Время изменения")
    is_published = models.BooleanField(choices=Status.choices, default=Status.DRAFT, verbose_name="Статус")
    cat = models.ForeignKey('Category', on_delete=models.PROTECT, related_name='posts', verbose_name="Категории")
    tags = models.ManyToManyField('TagPost', related_name='tags', verbose_name="Тэги")
    husband = models.OneToOneField('Husbands', on_delete=models.SET_NULL, null=True, blank=True, related_name='wuman', verbose_name="Муж")

Зарегестрируем модель категорий, на забываем импортировать её
    @admin.register(Category)
    class CategoryAdmin(admin.ModelAdmin):
        list_display = ('id', 'name')
        list_display_links = ('id', 'name')

Изменим её названия, создав внутри модели класс Meta и названия поля name для админки
    class Meta:
        verbose_name = 'Категория'
        verbose_name_plural = 'Категории'

    name = models.CharField(max_length=100, db_index=True, verbose_name="Категория")


Можно сделать возможность редактировать значение поля в отображении строк таблице, а не только внутри самого поста
Для этого в зарегестрированной модели нужно добавить параметр list_editable и передать в него картеж с полями для изменения
Важно, чтобы эти поля не были ссылками на пост, т.е. не находились list_display_links
    list_editable = ('is_published', )
Конкретно в этом примере мы добавляем возможность изменять публикацю, и после добавленя этой возможности всё работает как надо,
Но данные стали отображаться не корректно
Всё дело в том что поле is_published имеет булевый тип данных, и в нём реализовано выбор данных через класс models.IntegerChoices
Этот класс работает с числами и передаёт в таблицу число, а sql понимает булевое значение относительно числа
А вот админка не понимает как связать число с булевым значением
А класса для выборки булевых значений, в джанге просто не существует. 
но мы можем сами подменять число на бул написав для этого "костыль" преобразования данных в самом поле модели
    choices=tuple(map(lambda x: (bool(x[0]), x[1]), Status.choices))
Вместо старого
    choices=Status.choices
В итоге поле выглядит так
    is_published = models.BooleanField(choices=tuple(map(lambda x: (bool(x[0]), x[1]), Status.choices)), default=Status.DRAFT, verbose_name="Статус")
Миграция не нужна
После этого данные отображаются корректно

Сделаем возможность изменять еще и поле cat(вторичный ключ) 
    list_editable = ('is_published', 'cat')
Теперь в админки можно изменять и его, при этом есть возможность и удалить значение и изменить его и добавить новое
Т.Е. для изменения значения применился другой виджет
Джанго сам умеет определять какой виджет для каких данных нужно подставлять, и у него из коробке есть всё необходимое

Ещё мы можем сделать пагинацию на странице отображения строк таблицы, чтобы не грузить все строки разом, если у нас из много
в регистрационную модель нужно добавить параметр list_per_page и передать в него число, равное колличиству строк в пагинации
    list_per_page = 5



УРОК 3  ПОЛЬЗОВАТЕЛЬСКИЕ ПОЛЯ И ДЕЙСТВИЯ В АДМИНКЕ

Мы можем создавать собственные поля для отображения в админке
Для этого необходимо, в классе регистрации модели прописать метот.
Метод будет принимать, помимо селф, параметр, с произвольным названием, который принимает объект модели, которую будм расширять
А возвращает значение нового поля.
В данном случае, количество символов поля content
    def brief_info(self, women: Women):
        return f"Описание {len(women.content)} символов."

Создали новое поле, теперь его нужно добавить в всписок отображающих полей
    list_display = ('id', 'title', 'time_create', 'is_published', 'cat', 'brief_info')

Поле со значениями появилось, но назвывается оно как наш метод. Изменим это!
Для этого необходимо наш метод обернуть в декоратор @admin.display()
и передать в него аргумент description= са значением нужного нам названия поля
    @admin.display(description="Краткое описание")
    def brief_info(self, women: Women):
        return f"Описание {len(women.content)} символов."

всё четко, теперь сделаем новое поле сортируемым
В этом же декораторе, добавляем ещё один аргумень ordering и передаём в него название поля по которому будем сортировать
В данном случае по полю content 
    @admin.display(description="Краткое описание", ordering='content')
    def brief_info(self, women: Women):
        return f"Описание {len(women.content)} символов."

Сделали, чекаем, но сортировка какая-то неправельная
Всё потому-что она происходит именно по полю content а не по значению нашего поля
поле content имеет текстовый тип данных и сортируется в лексикографическом порядке, а не по количеству символов

Создание пользовательских действий

Если выделить несколько строк таблицы и перейти во вкладку действий
Мы увидем только одно действие - удалить строки
Но мы можем создать собственное действие для строк

Действие реализуется для каждой таблицы, следовательно, в модели регистрации
Реализация проиводистся как метод класса модели,
Он принимает в себя - self, request и queryset – объект QuerySet с выбранными записями
Именно к queryset мы и применяем функции для изменения модели
    def set_published(self, request, queryset):
    queryset.update(is_published=Women.Status.PUBLISHED)

Каждое пользовательское действие с таблицей нужно внести в список actions, предворительно создав его
Это типо список регистрации пользовательских действий для модели

Создали, внесли - всё работает
Но называется действие как и метод
Чтобы изменить название нужно метод обернуть в декоратор @admin.action, у которого тоже есть параметр description
    @admin.action(description="Опубликовать выбранные записи")
    def set_published(self, request, queryset):
        queryset.update(is_published=Women.Status.PUBLISHED)

Eщё мы можем модифицировать наше действие, добавив функционал вывода сообщения при его использовании
Для этого нужно применить метод message_user к объекту класса (self),
а в метод передать request и текстовое сообщении которое хотим передать
В нашем случае мы хотим передать - сколько записей изменено, а метод update, который мы применяем в методе пользовательского действия, как раз возвращает количество изменённых строк.
В таком случае, обернём функционал нашего метода в переменную и используем её вывод в текстовом сообщении
    @admin.action(description="Опубликовать выбранные записи")
    def set_published(self, request, queryset):
        count = queryset.update(is_published=Women.Status.PUBLISHED)
        self.message_user(request, f"Изменено {count} записи(ей).")


Сделаем ещё одно пользовательское действие, которое будет снимать записи с публикации
    @admin.action(description="Снять с публикации выбранные записи")
    def set_draft(self, request, queryset):
        count = queryset.update(is_published=Women.Status.DRAFT)
        self.message_user(request, f"{count} записи(ей) сняты с публикации!", messages.WARNING)
В целом всё понятно, но мы видим что в методе message_user появился дополнительный аргумент - messages.WARNING
Этот аргумент прикрепляет к нашему сообщению значок "восклицательный знак"
по дефолту в сообщение применяется значек "галочка"



УРОК 4 ДОБАВЛЕНИЕ ПОИСКА И ПАНЕЛИ ФИЛТРАЦИИ ДЛЯ МОДЕЛИ В АДМИНКЕ

Мы можем на странице отображения строк таблицы добавить поисковик
Для этого в моделе регистрации нужно создать список search_fields и передать в него все поля по каторым будет произвадиться поиск
    search_fields = ['title']
Поиск ищет совпадение переданной подстраки во всём поле, но он чувствителен к регистру
Можно добавить и несколько полей, тогда поиск будет отрабатывать по всем переданным полям сразу
Но нельзя передать поля содержащие вторичные ключи
потому-что вторичные ключи возвращают не данные, а объект класса модели
Чтобы передать данные, нужно как в ОРМ воспользоваться синтаксисом двух подчеркиваний, а после прописать имя поля связанной таблицы
    search_fields = ['title', 'cat__name']
Люкапами тоже можно пользоваться 
    search_fields = ['title__startswith', 'cat__name'] # __startswith ищет только вначале строки, а не по всему тексту

Настройка панели фильтрации

Ещё мы можем создать панель филтрации в админке нашей таблички
Делается это по аналогии с поиском - необходимо создать список list_filter и добавить в него поля для фильтрации
    list_filter = ['cat__name', 'is_published']

Мы можем создать собственный фильтр
Так и сделаем - создадим фильтр замужних и незамужнх женщин

Реализуется он классом который наследуется из класса admin.SimpleListFilter
Фильтр создаётся не в моделе, он общий, его, по идеи, можно использовать для любой таблице, если логика фильтра позволяет его применять
Следовательно пишем просто в файле models.py
    class MarriedFilter(admin.SimpleListFilter):
Ему нужно задать имя - параметр title
    title = 'Статус женщин'
А также нужно задать параметр - parameter_name - он нужен для образования урл когда мы его применяем
    parameter_name = 'status'
Далее создаём поля фильтра, т.е. выборку (замужем/не замужем)
Для этого нужно сделать метод нашего класса, который будет применять (помимо self) реквест и саму модель
Аргументы нужны только для его работы, в выводе мы сами создаём параметры фильтра
    def lookups(self, request, model_admin):
        return [
            ('married', 'Замужем'),
            ('single', 'Не замужем'),
        ]
Видим два параметра, представленные в виде кортежа с двумя значениями:
1) то-же что и parameter_name - название параметра для урл
2) второе значение уже для нас - название параметра в панели фильтрова

Осталось прописать логику для каждого параметра фильтра
Для этого в нашем классе нужно определить ещё один метод
Он принимает в себя реквест и кверисет, по той же логике, что и в функции определения пользовательского действия
А в теле метода прописываем саму логику фильтра через if, пайтон кодом
    def queryset(self, request, queryset):
        if self.value() == 'married':  # если значени параметра - замужем
            return queryset.filter(husband__isnull=False) # верни все строки у которых поле husband не равно True
        elif self.value() == 'single': # если значени параметра - не замужем
            return queryset.filter(husband__isnull=True) # верни все строки у которых True
