УСТАНОВКА ДЖАНГО, СОЗДАНИЕ ПРОЕКТА, ПРЕДСТАВЛЕНИЯ И МАРШРУТИЗАЦИЯ


Урок 1 УСТАНОВКА ДЖАНГО

для запуска проекта на джанго сначала нам нужно создать репозиторий проекта и в нём поставить виртуальное окружение venv
далее ставим джанго внутри окружения ~ pip install django==4.2.1 
можно посмотреть какие команды доступны в ядре джанго ~ django-admin 
далее создаём сайт на котором будем работать ~ django-admin startproject <имя сайта>
после создания, видим внутри проекта папку с названием сайта и в нём python файлы, включая manage.py
чтобы запустить сервер сайта нужно выполнить команду внутри папки сайта ~ python manage.py runserver 
при обновлении програмного кода, браузер может не подгрузить изменения, тогда нам нужно отключить соединение в терминале и подключиться снова



Урок 2 СОЗДАНИЕ ПРИЛОЖЕНИЯ В ДЖАНГО

сначала напомним что происходит под капотом сайта когда пользователь делает запрос на сайт:
- на сервер приходит запрос и он ищет щаблоны схожие с запросом пользователя
- при нахождении шаблона активируется представление в джанге
- представление это функция или класс в питоне, которые при активации дастаёт необходимые данные из бд и шаблонов html, объединяет их и отрправляет пользователю в виде html страницы

на сайте может быть реализованно множество логических независимых приложений, каждое из них является программой внутри сайта и все эти программы хранятся в нашем проекте джанго. Каждая из них должна быть зарегестрированна (прописана) в settings.py внутри INSTALLED_APPS

приложение создаётся в терминале внутри проекта джанго ~ python manage.py startapp <имя приложения> 



УРОК 3 СОЗДАНИЕ ФУНКЦИЙ-ПРЕДСТАВЛЕНИЙ И ИХ МАРШРУТИЗАЦИЯ 

Как уже говорилось ранее представление это функция или класс которая возвращает данные, как правило, в виде html страницы
Сами представления создаются и хранятся в файле views.py внутри репозитория приложения

Но чтобы эта функция вернулась пользователю её нужно как-то передать. Процесс передачи называется - маршрутизация
Маршрутизация осуществляется при помощи джанговой функции path() из джанговой библиотеки, она принимает "суфикс" урл котороый будет в адресе той страницы на которую мы переходим и функцию (или класс) - представление, которая и возвращает страницую

все маршруты хранятся в переменной urlpatterns как элементы списка, внутри файла urls.py
Такой файл по дефолту есть только в основном приложении, а для созданных приложений его нужно создавать отдельно.
Если мы используем маршрут из созданного приложения, маршрут нужно прописывать urls.py самого приложеия, а в urls.py основного приложения принимать все пути при помощи функции include() ~ path(<первоначальный суфикс>, include('<имя приложения>.urls')),



УРОК 4 ОТЛАДКА ПРОЕКТА В ПАЙЧАРМ

Если подключаться к серверу через терминал, мы теряем возможность его отлаживать, а еще это не очень удобно.
Мы можем подключаться к нему по кнопке (зелёной, что запускает скрипт) в пайчарме.
Для этого возле той самой кнопки, нажимаем на настройки и в окне указываем: название скрипта, рабочую директорию, интерпритатор пайтон, в котором работает проект и команду скрипта (в этом примере runserver)
После настройки можно: подключаться к серверу по кнопке, а не командой в терминале и делать отладку функций. 
А ещё больше не нужно перезапускать сервер при изменение кода



УРОК 5 ДИНАМИЧЕСКИЕ URL И КОНВЕРТЕРЫ

Динамические урл это урл с несколькими раздаелами пути, где последующие разделы, после основного, могут динамически изменятся и тем самым изменять данные, которые возвращаются в ответе сервера.
эти разделы отображаются при написании представлений и маршрутов динамических урл
Для представлений, если оно выполненно в виде функции, подраздел будет дополнительным аргументов функции, который можно использовать в теле или выводе этой функции.
    def categories_by_slug(request, cat_slug):
        return HttpResponse(f"<h1>Статьи по категориям</h1><p >slug:{ cat_slug }</p>")
В маршруте, подраздел отображается как часть пути, но не статичной строкой, а спец. синтаксисом <тип данных:имя аргумента представления>, а называется это - конвертер
    path('cats/<int:cat_id>/', views.categories),



Для динамичных путей можно использовать несколько типов данных:
    str – любая не пустая строка, исключая символ ‘/’;
    int – любое положительное целое число, включая 0;
    slug – слаг, то есть, латиница ASCII таблицы, цифры, символы дефиса и подчеркивания;
    uuid – цифры, малые латинские символы ASCII, дефис;
    path – любая не пустая строка, включая символ ‘/’. 

Но если нам их не хватает, можно определить свой тип данных и воспользоваться регуляркой.
В таком случае путь в маршруте будет указываться функцией re_path(), а регулярка будет прописана в пути
    re_path(r'^archive/(?P<year>[0-9]{4})/', views.archive),
Но это выглядит не очень, поэтому можно поступить намного круче:
Вместо того чтобы того чтобы прописывать конвертер внутри path можно прописать его в отдельном файле converters.py, предворительно создав его внутри нашего приложения.
В этом файле мы будем хранить все наши конвертеры, а реализовывать их можно в классе и это выглядит очень красиво и удобно:
    class FourDigitYearConverter:
        regex = "[0-9]{4}"  # наша регулярочка
     
        def to_python(self, value):
            return int(value)   # функция делает из строки число (я так понимаю для проверки)
     
        def to_url(self, value):
            return "%04d" % value       # возвращает строку обратно, чтобы использовать в path

И теперь мы можем можем использовать этот конвертер в path().
Причем именно в path, а не re_path
Но перед использованием конвертера, его нужно снасала зарегестрировать в файле urls.py, ну и импортировать конечно же
Чтобы зарегестрировать конвертер нужно воспользоваться функцией register_converter(), которую тоже нужно импортировать из django.urls.
В функцию летит имя конвертера и произвольное имя типа данных который он возваращает
    register_converter(converters.FourDigitYearConverter, "year4")
после этого можно использовать конвертер в path и лицезреть красивый код
    path('archive/<year4:year>/', views.archive),

подробности обо всём этом тут:
https://docs.djangoproject.com/en/4.2/topics/http/urls/


Ещё момент про urlpatterns (список наших урлов)
При запросе всегда отработает тот шаблон, в котором, первым, было найдено совпадение запроса. Т.Е. елси запрос может отработать в нескольких маршрутах, отработает, тот что записон в списке раньше остальных (имеет меньший индекс). 



УРОК 6 GET И POST ЗАПРОСЫ, ОБРАБОТКА ИСКЛЮЧЕНИЙ

УРЛ запросы могут содержать дополнительные параметры в виде GET и POST запросов.
http://127.0.0.1:8000/?name=Gagarina&cat=music 
?name=Gagarina&cat=music  - вот эта часть и есть пост запрос.
Эти запросы можно обрабатывать в джанге, например, в самой вьюшке можно словить его ~ request.GET и далее с ним работать
С пост запросом всё идентично ~ request.POST

ОБРАБОТКА ИСКЛЮЧЕНИЙ:
Порой при запросе, запросе пользователь может словить исключение, разберем на примере 404, когда запрос не находит совпадений в маршрутах и не может ничего вернуть
Если самому сделать подобный запрос, джанго выдаст страницу исключения 404 с данными подсказывающие нам об исключение.
Это происходит потомучто в файле setting.py в папке главного приложения есть переменная DEBUG с параметром TRUE.
Если её отключить (поменять на False) при исключении мы будем получать стандартный вывод 404 браузера
Но помимо отключения дебага нам нужно будет еще прописать хост локального сервера в ALLOWED_HOSTS = [], иначе мы не подключимся к нему и получим ошибку
    ALLOWED_HOSTS = ['127.0.0.1']
Вывод исключений браузера не очень удобный и информативный для пользователя
Мы можем написать собственный обработчик исключений и выводить собственный html в подобных случаях
пишем его в urls.py основного приложения ~ handler404 = page_not_found
обработчик это вызов функции page_not_found сама же функция будет находится во вьюшке приложения women
    def page_not_found(request, exception):
        return HttpResponseNotFound('<h1>Страница не найдена</h1>')
функция принимает запрос и ошибку из джанги и возвращает класс HttpResponseNotFound который мы импортируем из django.http
Теперь при ошибки 404 мы выводим собственный html для пользователя.

обрабатывать запросы можно и в самих вьюшках:
    def archive(request, year):
        if year > 2023:
            raise Http404()
        return HttpResponse(f"<h1>Архив по годам</h1><p >{year}</p>")
Здесь по условию мы генерим исключение Http404(). оно импортируется из django.http. при срабатывание этого исключения сработает наш обработчик 404

Обрабатывать можно не только 404 исключение, но и другие, для каждого нужно писать свой обработчик.
Подробнее тут:
https://docs.djangoproject.com/en/4.2/ref/urls/



УРОК 7 GET И POST ЗАПРОСЫ, ОБРАБОТКА ИСКЛЮЧЕНИЙ

При развитии сайта очень часто некоторые страницы переезжают на други урл адреса.
Чтобы не потерять эти страницы, поисковой системе нужно явно указывать что страница переехала.
После того как мы это сделали, переходя по старому адресу сайт перенаправит нас на новый урл а запрос получит ответ 301 или 302
    301 – страница перемещена на другой постоянный URL-адрес;
    302 – страница перемещена временно на другой URL-адрес. 

В джанго переезд можно оформить функцией redirect(), предварительно импортируя её из django.shortcuts
    from django.shortcuts import render, redirect
функцию мы вставляем в return представления и передаём в неё адрес на которое будет переход
    def archive(request, year):
        if year > 2023:
            return redirect('/')
Вместо указания адреса напрямую можно указать имя функции представления return redirect(index)
По дефолту перенаправление происходит с ответом 302, т.е. временно, чтобы сработал ответ 301, в redirect нужно добавить дополнительный аргумент - permanent со значением True
    return redirect(index, permanent=True)
Писать путь напрямую или имя функции, считается хардкодингом.
Помимо этих двух вариантов функция redirect принимает еще и имя маршрута. И это самый лучший вариант в визуальном стили кода.
Но это имя в маршруте должно присутствовать.
Для этого в маршрут передаём еще один параметр name='имя маршрута'
    path('', views.index, name='home'),
    path('cats/<slug:cat_slug>/', views.categories_by_slug, name='cats'),
и после этого в redirect можно передовать это имя
    return redirect('home', permanent=True)
Если же маршрут перенаправления содержит несколько параметров - в redirect эти параметры также нужно указать
    return redirect('cats', 'music')

Маршрут перенаправления можно вычеслить заранее, до функции redirect используя функцию revers, предворительно, импортируя её из django.urls
В revers можно передать имя маршрута и коллекцию дополнительных подрозделов.
А после передаём функцию в redirect
        url_redirect = reverse('cats', args=('sport',))
        return redirect(url_redirect)

Помимо redirect можно использовать классы HttpResponseRedirect и HttpResponsePermanentRedirect
Работает они почти аналогично redirect(). первый вызывает ответ 302, второй 301
Чем пользоваться тоже, особо разницы нет.
Разница в работе заключается в том, что в классы нельзя передовать названия функций представлений, а ещё redirect может сам вычислять маршрут динамически



ШАБЛОНЫ


УРОК 1 ШАБЛОНЫ, render(), render_to_string()

Шаблоны это готовы html страницы.
До этого мы передовали захардкоженную html внутри функций представления. Но так конечно же делать неправильно
Все шаблоны храняться внутри нашего приложения в директории под названием templates.
Внутри этой директории также необходимо создать директорию с названием нашего приложения и уже в ней хранить наши html файлы
Это делается потому-что, чтобы вытащить html документ, мы должны передать его путь.
Джанго не требует передовать весь путь, он подразумевает, что в каждом приложении, у нас есть папка templates и сам будет искать там html.
Вот только джанго будет проходить по всем приложениям и если у нас в разных приложениях будут храниться html с одинаковыми названиями джанго возьмёт первый найденный.
Для этого и создаётся подпапка в templates, так мы указываем более подробный путь, который не будет совпадать с другими приложениями.

Как же передать этот путь во вьюшке?:
Для этого нам понадобиться функция render_to_string(), которую мы импортируем из django.template.loader.
в неё мы и передадим путь к файлу html, а её саму передадим в вывод вьюшки
    def index(request):
        t = render_to_string('women/index.html')
        return HttpResponse(t)
Но можно сократить эти две строки в одну используя функцию render() из django.shortcuts
В неё передаём request и путь к html
    def about(request):
        return render(request, 'women/about.html')

Теперь а самом шаблонизаторе джанго:
Мы можем изменять его настройки в основной директории приложения в файле settings.py
Там есть коллекция TEMPLATES. она хранит в себе такие ключи: BACKEND, DIRS, APP_DIRS, OPTIONS
'BACKEND': 'django.template.backends.django.DjangoTemplates', - в нём прописан стандартный шаблонизатор джанги
'DIRS': [], - в Этой коллекции мы можем хранить дополнительные пути для поиска шаблонов, если это требуется
'APP_DIRS': True, - этот ключ отвечает, за то что джанго понимает что ей нужно искать в папке templates в каждом приложении.
точнее не в каждом приложении а в каждом инсталированном. т.е. находящийся в коллекции INSTALLED_APPS, в этом же файле
    'women.apps.WomenConfig',



УРОК 2 ПЕРЕДАЧА ДАННЫХ (ПЕРЕМЕННЫХ) В ШАБЛОНЫ

Шаблону не обязательно быть статичным. т.е. данные в нём не обязательно должны быть строго вшиты в html.
Мы можем передовать данные из переменных в коде в html страницу.
Для этого нужно поправить сам html документ и в место куда мы хотим хотим поставить вставлять данные прописать {{}}, а внутрь кавычек вписать имя переменной, значение которой будем вставлять. 
вместо этого
    <title>Главная страница</title>
вот так
    <title>{{title}}</title>
А в коде нам нужно создать данные с таким же названием.
Например, создать словарь с ключём title и значением которое мы хотим подставить html
    data = {'title': 'Главная страница'}
Этот словарь можно создать внутри представления страницы в которую мы будем подставлять данные и передать словарь третим аргументом в функцию рендер, или через именнованный аргумент context
    def index(request):
        data = {'title': 'Главная страница'}
        return render(request, 'women/index.html', data)
А можно создать прямо внутри аргумента напрямую
    def about(request):
        return render(request, 'women/about.html', context={'title' : 'О сайте'})

В html может находиться множество данных, которые нужно подставлять из кода, тогда и словарь будет с множеством ключей.
     data = {
        'title': 'Главная страница',
        'menu': menu,
        'float': 28.56,
        'lst': [1, 2, 'abc', True],
        'set': {1, 1, 2, 3, 2, 5},
        'dict': {'key_1': 'value_1', 'key_2': 'value_2'},
        'obj': MyClass(10, 20),
    }
Тип данных может быть любым, но в html выводиться строковое представление переданных данных
Можно передовать даже коллекции, как целиком, так и части этих коллекций.
Но чтобы передать элемент коллекции в html, нужно это указать в самом html.
И делается это не привычным синтаксисом пайтон
    <p >{dict[key_1]}}</p>
а немного измененным
    <p >{{dict.key_1}}</p>
    <p >{{obj.a}}</p>
В одни фигурные скобки, можно засовывать только один элемент. Если мы хотим передать в тег несколько элементов - каждый нужно обернуть в скобки отдельно
    <p >{{ dict.key_1 }} {{ dict.key_2 }}</p>
Если в html есть имя данных которые мы не передали в render, при выводе страницы в браузере мы не получим ошибку.
В таком случае данные будут просто проигнорированны. т.е. на месте данных ничего не будет

Как вытаскивать элементы из списков и кортежей, будет в дальнейших уроках



УРОК 3 ШАБЛОННЫЕ ФИЛЬТРЫ

Шаблонные фильтры это как методы для объектов пайтон, но для данных в html (те что обёрнуты в кавычки {{}})
Фильтров существует огромное множество, у каждого своё предназначение, и свой тип данных для работы
Если в питоне метод присоединяется определённым синтаксисом obj.method
У html свой синтаксис obj|filter
Если в филтьр нужно передать значение - будет так obj|filter:"value", даже числи летят в кавычки

Разбёрем некоторые фильтры:
 - add - прибовляет к числу переданное число
    <p >{{float|add:"50"}}</p> 
float у нас равен 28.56, а на выводе страницы мы видем 78
Это потому что add работает только с целочисленными значениями и если в него передать вещественное число, он преобразует его в целое
 - capfirst - делает первую букву заглавной
 - upper - делает все буквы заглавными
 - lower - делает все буквы маленькими
 - cut - вырезает из строки все переданные символы.
как и в питоне методы можно комбенировать цепочкой obj.method1.method2.... так и тут можно obj|filter1|filter2...
<h1>{{title|cut:" "|cut:"?"}}</h1>
 - default - создаёт дефолтное значение из переданных данных объекту, если мы не подставили этот объект в коде или передали пустое значение
<title>{{main_title|default:"Без заголовка"}}</title>
 - divisibleby - Возвращает true или false если объект кратен переданному числи, как и add преобразует объект в целочисленное значение
 - first - выводит первый элемент коллекции. как раз тот способ доставание элементов из списков и кортежей
 - last - выводит последний элемент коллекции
 - join выводит все элементы коллекции через переданный разделитель
 <p >{{menu|join:" | "}}</p>
 О сайте | Добавить статью | Обратная связь | Войти 
 - length - показывает длинну коллекции или строки. а-ля функция len()
 - slugify - преобразует строку в формат slug
 <p >{{"The Main Page"|slugify}}</p>
 the-main-page

Больше фильтров и подробностей о них можно узнать в документации
https://docs.djangoproject.com/en/4.2/ref/templates/builtins/ 

Фильтры можно использовать не только в html, но и в самом коде
Необходимый фильтр сначала нужно импортировать
    from django.template.defaultfilters import slugify
А позже его можно использовать как функцию в коде
    'dict': {'key_1': 'value_1', 'key_2': 'value_2'},
        'obj': MyClass(10, 20),
        'url': slugify("The main page"),  # вот он
В html у нас будет просто обычный тег с переданными данными в него, без каких либо фильтров
    <p >{{url}}</p>
Но на странице будет отображаться отфильтрованные данные, аналогичные  <p >{{"The Main Page"|slugify}}</p>



УРОК 4 ТЕГИ ШАБЛОНОВ for И if

Внутри шаблона можно использовать цикл for и проверку if как в питоне, но с немного отличающимся синтаксисом.
И цикл и проверка являются шаблонными тегами, но не стандартными html которые определяют в каком виде выводить данные, а специальными тегами, которые определяют как эти данные выводить.
Такие теги не видно при просмотре страницы в браузере и они пишуться с отличающимся синтаксисом.
    {% <название тега> [параметры] %} 
Для работы мы создали коллекцию в файле представления, а-ля как если бы это было бд
    data_db = [
        {'id': 1, 'title': 'Анджелина Джоли', 'content': 'Биография Анджелины Джоли', 'is_published': True},
        {'id': 2, 'title': 'Марго Робби', 'content': 'Биография Марго Робби', 'is_published': False},
        {'id': 3, 'title': 'Джулия Робертс', 'content': 'Биография Джулия Робертс', 'is_published': True},
    ]
И добавили коллекцию в функцию представления
    def index(request):
        data = {
            'title': 'Главная страница',
            'menu': menu,
            'posts': data_db,
        }
 
        return render(request, 'women/index.html', context=data)

Так вот эти данные мы можем крутить в цикле внутри html и почерёдно выводить их на странице
Вот так это выглядит в шаблоне:
<!DOCTYPE html>
<html>
<head>
         <title>{{ title }}</title>
</head>
<body>
<p >{{ menu|join:" | " }}</p>
<h1>{{ title }}</h1>
 
<ul>
         {% for p in posts %}
         <li>
                   <h2>{{ p.title }}</h2>
                   <p >{{ p.content }}</p>
                   <hr>
         </li>
         {% endfor %}
</ul>
 
</body>
</html>
Мы видим что цикл обёрнут в тег {% %}, но сам цикл пишется точно с таким же синтаксисом как в питоне
После этого идёт тело цикла. в нём создаётся html теги шаблоана, а в них другие вложенные теги, в который мы передаём элементы коллекции, и в конце тег разделитель <hr>
Ещё одно отличае от питона - теги шаблона должны закрываться {% endfor %} для for и {% endif %} для if

И ещё одно отличае:
В отличае от питона, когда мы создаём цикл в шаблоне джанго, у нас под капотом создаётся переменная forloop
forloop напрямую связан с колекцие которую мы прокручиваем и через него, используя методы этой переменной, можно выяснить какая на данный момент происходит итерация и не только.
У forloop множество методов, подробнее тут
https://docs.djangoproject.com/en/4.2/ref/templates/builtins/#for

Нам нужно убрать тег разделитель после последней итерации.
Можно воспользоваться методом forloop.last - он выводит true если это последняя итерация
И сделать это можно проверкой if внутри цикла.
     {% for p in posts %}
     <li>
       <h2>{{p.title}}</h2>
       <p >{{p.content}}</p>
       {% if not forloop.last %}
       <hr>
       {% endif %}
     </li>
Шаблонный тег прописывается в те-же скобки что и for {% if not forloop.last %} и также закрывается, как и for {% endif %}
И точно также сама проверка if пишется полностю питоновским синтаксисом
if not forloop.last - если не последняя итерация
<hr> - ставь разделитель
У тега if есть все те-же конструкции if, elif, else, что и в питоне, каждую из них по аналогии нужно укутывать в скобки, но закрывать нужно только if

Еще в задание требоволось выложить только те строки из бд, в которой колонка is_published имела значение True
Для этого тоже используем if и конечный цикл у нас получается таким:
<ul>
         {% for p in posts %}
         {% if p.is_published %}
         <li>
                   <h2>{{p.title}}</h2>
                   <p >{{p.content}}</p>
                   {% if not forloop.last %}
                   <hr>
                   {% endif %}
         </li>
         {% endif %}
         {% endfor %}
</ul>



УРОК 5 ШАБЛОННЫЙ ТЕГ url

Мы знаем что в html существуют ссылки - тек <a>
<a href="URL-адрес страницы">Название ссылки</a> 

Мы можем брать адреса этих ссылок из кода в джанго-приложение, вместо того чтобы хардкодить их напрямую в теге
Для этого используется шаблонный тег url
Вот его синтаксис ~ {% url 'название маршрута' параметр1 параметр2 %}
Мы видим как шаблонный тег заковывается в кавычки {% %}, далее само название тега - url, 
после идёт название маршрута, это то самое название из маршрута в нашем коде - параметр name= в функции path(), в коллекции маршрутов
А далее идут параметры этого маршрута, т.е. дополнительные динамические подразделы url

Для примера создадим маршрут для нашей коллекции data_db, который будет передовать страницу каждого элемента колекции
    path('post/<int:post_id>/', views.show_post, name='post'),
Ну и конечно же нужно создать функцию представления этой страницы
def show_post(request, post_id):
    return HttpResponse(f"Отображение статьи с id = {post_id}")
Получится динамичный урл, подраздел которого будет привязан к id строки нашего бд

И так у нас есть новая страница в проекте и мы можем добавить ссылку на неё в основной странице нашего сайта, где перечисляются данный data_bd
         {% for p in posts %}
         {% if p.is_published %}
         <li>
             <h2>{{p.title}}</h2>
             <p >{{p.content}}</p>
             <p ><a href="{% url 'post' p.id %}">Читать пост</a></p>  # вот она
                {% if not forloop.last %}
                   <hr>
                {% endif %}
         </li>
Как видим в ссылку мы вставили именно шаблонный тег url, который передали имя маршрута 'post' и параметр маршрута p.id

По уроку далее мы добавили новые маршруты для нашего списка menu, а каждый элемент этого списка сделали словарём с названием маршрута и визуальной частью ссылки для тега <a>, чем и являлись ранее элементы списка menu.
для каждого маршрута, естественно создали представление.
А на главной странице была добавленна ссылка на эту же страницу.
    path('addpage/', views.addpage, name='add_page'),
    path('contact/', views.contact, name='contact'),
    path('login/', views.login, name='login'),


    menu = [{'title': "О сайте", 'url_name': 'about'},
            {'title': "Добавить статью", 'url_name': 'add_page'},
            {'title': "Обратная связь", 'url_name': 'contact'},
            {'title': "Войти", 'url_name': 'login'}
    ]


    def addpage(request):
        return HttpResponse("Добавление статьи")


    def contact(request):
        return HttpResponse("Обратная связь")


    def login(request):
        return HttpResponse("Авторизация")

Теперь можно отобразить коллекцию menu и в html как ссылки на эти маршруты:
<ul>
<li><a href="{% url 'home' %}">Главная</a></li>     # добавляем ссылку на главную страницу
{% for m in menu %}                                 # прокручиваем коллекцию menu
{% if not forloop.last %}<li>{% else %}<li class="last">{% endif %}   # для последнего тега <li> добавили class="last", чтобы в будущем подкрутить стиль
         <a href="{% url m.url_name %}">{{m.title}}</a>   # а вот и тег url, в который передаём имя маршрута, а в тег <a> передаём название страницы
</li>
{% endfor %}
</ul>


Шаблонный тег url можно сравнить с функцией reverse() в джанге
reverse('post', args=(11, )) - reverse принимает имя маршрута и его аргументы, а потом склеивает их в единый url
{% url 'post' 11 %}          - шаблонный тег url принимает тоже самое и делает тоже самое
Именно так и рекомендуется воспринимать шаблонный тег url



УРОК 6 НАСЛЕДОВАНИЕ ШАБЛОНОВ. ШАБЛОННЫЕ ТЕГИ extends, block, include

Код в шаблоне на многих страницах может повторяться, и это не очень правильно и удобночитаемо
поэтому мы можем создать базовый шаблон, в котором будет находиться html код повторяющийся в большинстве страниц
Такие шаблоны нужно хранить в основной директории проекта, для них также создаётся ещё одна директория templates и уже в ней лежать шаблоны
и уже в ней лежат шаблоны.
Важно знать что шаблонизатор не просматривает шаблоны в корневой папке проекта и этот путь нужно прописать в DIRS, в коллекции TEMPLATES setting.py
    BASE_DIR / 'templates'   # BASE_DIR - это как раз путь к корневой папке
Создали директорию, указали путь, а теперь создаём там базовый шаблон который будет содержать в себе весь повторяющий html код каждой страницы
Теперь в уже существующих html документах можно стереть весь этот повторяющийся код и прописать шаблонный тег extends
    {% extends 'base.html' %} вместо этого шаблонного тега подставиться весь html код из переданного в него файла html

Но что делать с тем кодом который является эксклюзивным для наследованной html страницы?:
В бозовом html мы можем выделить место в коде, куда мы будем вставлять какие-то свои правки в html при помощи шаблонного тега block
    {% block content %} {% endblock %}  # параметр тега - это его произвольное название
И уже в нужной нам странице, в произвольном месте нужно создать такойже блок, обязательно, с тем же названием и внутри этого блока поместить наш код
{% block content %}
<h1>{{ title }}</h1>
{% endblock %}

Для наглядности вот как выглядит базовый html:
<!DOCTYPE html>
<html>
<head>
         <title>{{ title }}</title>
</head>
<body>
<ul>
<li><a href="{% url 'home' %}">Главная</a></li>
{% for m in menu %}
{% if not forloop.last %}<li>{% else %}<li class="last">{% endif %}
         <a href="{% url m.url_name %}">{{m.title}}</a>
</li>
{% endfor %}
</ul>
{% block content %} {% endblock %}

</body>
</html>

А вот так страница about:
{% extends 'base.html' %}
{% block content %}
<h1>{{ title }}</h1>
{% endblock %}

тоесть страница about будет выглядит точно так же как страница base но внутри тега block у неё будет содержимое тега block страницы about
Тегов block может быть множество на странице, у каждого должно быть собственное имя, чтобы мы могли сами решать в какой блок нам ложить информацию

Для улучшения проекта сделаем тоже самое и для страницы index
А далее добавим на страницу ещё одну строку с категориями женщин вначале и в конце списка
<nav>
         <a href="#">Актрисы</a> |
         <a href="#">Певицы</a> |
         <a href="#">Спортсменки</a>
</nav>

Теперь у нас есть повторяющийся тег <nav> в одном документе html
И подобные повторения, также можно предотвратить благодаря шаблонному тегу include
Мы можем хранить подобные куски кода html в отдельных html документах.
Создадим специальную директорию для подобных фалов, например такую
women/templates/women/includes
Создадим там html документ и сохраним в него повторяющий тег nav для страницы about
А на самой странице about вместо этого тега, вызовим шаблонный тег include в каждом месте где есть этот шаблон
    {% include 'women/includes/nav.html' %}   # он работает по аналогии тегу extends - тоже подставляет весь код переданной страницы вместо тега, но его можно использовать сколько угодно раз
У тега include есть дополнительные параметры:
only - этот параметр передаёт - не передаёт переменные - всё что в завёрнуто в двойные ковычки {{}}
with - ставиться после only в него можно передать имена тех переменных, которые мы всётаки хотим передать в теге include
    {% include 'women/includes/nav.html' only with title %} - передать всё содержимая файла nav без переменных, кроме переменной title



УРОК 7 ПОДКЛЮЧЕНИЕ СТАТИЧЕСКИХ ФАЙЛОВ

Статические файлы - это файлы css, картинки, и скрипты javascript
В боевом проекте мы конечно же не будем передовать голый шаблон.
Передоваемый шаблон будет связан со статическеми 
И сейчас разберемся как их связывать и передовать:

Мы уже знаем что мы можем запускать тестовый сервер с включеным и отключенным дебаг режимом
Во включенном дебаг режиме статические файлы ищутся, как и шаблоны, в каждом приложении за исключением рабочего каталога и каталога рабочего приложения
В setting.py есть переменная STATIC_URL, в которой по дефолту указан путь к static директории. 
Именно здесь джанго понимает в какой директории искать статические файлы в дебаг режиме.
ещё мы можем создать переменную STATICFILES_DIRS по формату аналогичной STATIC_URL и там прописать путь для нестандартного пути поиска статических файлов джанга. А-ля в директории корневого приложения.
Но в действующем сайте все статические файлы должны быть перенесены в корневую директорию проекта, в директорию static.
Путь к этой директории тоже нужно прописать в переменной, но уже в новой - STATIC_ROOT
А все статик-файлы перенести в эту директорию.
Причем перенос нужно осуществить, перед запуском сайта, благодаря команде ~ python manage.py collectstatic 

Вот наглядное расположение директорий static
sitewomen
    - sitewomen
        - static               # - нестандартный путь

    - women
        -static                # - стандартный путь для режима дебаг
        -templates

    -static                    # - стандартный путь для действующего режима работы сайта

Мы находимся в режиме разработки, а значит наши статические файлы должны лежать в каталоге приложения
Создаём директори static в приложении, в ней, по тем же причинам что и в templates, создаём директорию с именем приложения
И уже в нём создаём 3 директории - css, images, js
Создаём или добавляем уже созданные статические файлы в этих директориях

Чтобы в html можно было вставлять статические файлы их нужно в этот html загрузить
Для этого в самом начале страницы нужно поставить шаблонный тег load static
{% load static %}

Теперь нам нужно подключить эти файлы к нашему шаблону
Статические фалы добавляются в html в теге link, в нём есть параметр href - ссылка на докумемент файла.
Можно напрямую указать ссылку, но это хардкодинг.
Мы будем делать это используя шаблонный тег static.
По аналогии с include, ему нужно передать ссылку на файл ~ {% static 'women/css/styles.css' %}
часть пути - static/ - указывать не нужно, потому что эта часть уже прописана в STATIC_URL
Тег link будет выглядеть так 
    <link type="text/css" href="{% static 'women/css/styles.css' %}" rel="stylesheet" />

Вот и всё. По аналогии добавляем остальные файлы в шаблон, немного шаманим над самим шаблоном и наш сайт преображается в нормальный вид.


По уроку далее можно рассматриваем еще пару шаблонных фильтров: linebreaks, truncatewords, autoescape
Для работы поменяем в нашей бд заначение первой строки, колонки content с этого:
Биография Анджелина Джоли
на это:
'''<h1>Анджелина Джоли</h1> (англ. Angelina Jolie[7], при рождении Войт (англ. Voight), ранее Джоли Питт (англ. Jolie Pitt); род. 4 июня 1975, Лос-Анджелес, Калифорния, США) — американская актриса кино, телевидения и озвучивания, кинорежиссёр, сценаристка, продюсер, фотомодель, посол доброй воли ООН.
Обладательница премии «Оскар», трёх премий «Золотой глобус» (первая актриса в истории, три года подряд выигравшая премию) и двух «Премий Гильдии киноактёров США».'''

Разберём сначала truncatewords - он выводит указанное количество слов в тексте.
т.е. применив этот тег с параметром 20 - truncatewords:20 - в браузере отобразиться только первые двадцать слов текста
- linebreaks - переносит текст вместе с символоми переноса строк. без этого фильтра символа переноса не будет и строки склеются
- autoescape - это шаблонный тег. в нашем тексте есть экранирование текста в формате html <h1>Анджелина Джоли</h1>, и html при передачи такой строки через {{ данные }} не переводит этот текст в нужный формат сам.
Что бы html видел теги как теги а не как текст, нужно весь текст обернуть в шаблонный тег autoescape с параметром off
    {% autoescape off %}
    {{p.content|linebreaks|truncatewords:40}}
    {% endautoescape %}



УРОК 8 ПОЛЬЗОВАТЕЛЬСКИЕ ТЕГИ ШАБЛОНОВ

Помимо уже известных шаблонных тэгов, мы можем создавать свои (куда ж без этого)
Подробная информация о том как это сделать тут:
https://docs.djangoproject.com/en/4.2/howto/custom-template-tags/

Поехали разбираться!
Пользовательские теги могут быть двух типов
 - simple tags – простые теги
 - inclusion tags – включающие теги

Что нужно чтобы создать свой тег?:
Все пользовательские теги должны храниться в директории templatags, внутри приложения и этот каталог должен являться пакетом, т.е. в нём должен присутствовать файл __init__.py
Сами же теги будут храниться в отдельном файле, к примеру women_tags
импортируем всё необходимое:
from django import template - отсюда вытащим экземпляр класса Library который регестрирует наши шаблонные теги
import women.views as views - импорт файл views чтобы тянуть от туда бд по заданию
Далее создаём экземпляк класса Library, через который происходит регистрация собственных шаблонных тегов:
register = template.Library()
Теперь можно создавать шаблоны

Simple Tag:
Простой тег реализованый через функцию которая что-то возвращает, в нашем случае коллекцию
def get_categories():
    return views.cats_db
сама коллекция во вьюшке:
cats_db = [
    {'id': 1, 'name': 'Актрисы'},
    {'id': 2, 'name': 'Певицы'},
    {'id': 3, 'name': 'Спортсменки'},
]   # это та самая коллекция категорий с главной страницы, все категории у нас вшиты на прямую в html, а нам надо тянуть их из бд, что мы и делаем
Следовательно наш шаблонный тег будет возвращать эту коллекцию

Пока-что это просто функция, чтобы эта функция стала шаблонным тегом, на неё нужно навесить декоратьр @register.simple_tag()
@register - это тот самый объект класса Library, а simple_tag() - это его метод который делает нашу функцию шаблонным тегом типа Simple Tag
Теперь мы можем вызывть наш тег в html также как и другие шаблонные теги {% get_categories %}
Но сначала нам нужно в шаблон загрузить файл с нашими шаблонными тегами
{% load women_tags %}
Помним что наш тег возвращает всю коллекцию, тоесть всю строку бд представленную в виде строки.
Значит нам нужно прокрутить эту коллекци циклом.
Но вот только тег крутить не получиться, потому что он не коллекция, а тег.
Мы можем превратить его в переменную синтаксисом as имя_переменной
{% get_categories as categories %} - так мы превратили вывод тега get_categories в переменную categories, которую можно крутить
и далее вместо захардкоденных категорий
    <li><a href="#">актрисы</a></li>
    <li><a href="#">спортсменки</a></li>
    <li><a href="#">певицы</a></li>
крутим нашу коллекцию
    {% for cat in categories %}
        <li><a href="#">{{cat.name}}</a></li>
    {% endfor %}

Наш шаблонный тег не обязательно называть функцией этого тега
в параметры декоратора можно добавить параметр name= и передать ему произвольное имя
@register.simple_tag(name='getcats')
def get_categories():
    return views.cats_db
Тогда и в html нужно обращаться к тегу по указанному имени
{% getcats as categories %}

Далее разберём inclusion tags но сначала сделаем наши категориями нормальными ссылками
пропишим путь для ссылки
    path('category/<int:cat_id>/', views.show_category, name='category'),
и создадим вьюшку
    def show_category(request, cat_id):
        """Функция-заглушка"""
        return index(request)
в тег категории вставим нормальную ссылку на категорию
{% for cat in categories %}
         <li><a href="{% url 'category' cat.id %}">{{cat.name}}</a></li>
{% endfor %}

Inclusion Tag
Включающий тег позволяет дополнительно формировать свой собственный шаблон на основе данных, которые мы хотим передать в html, а сам тег после этого будет возвращать уже готовый html код
Сделаем тоже что и с простым тегом, через включающий тег:
внутри функции создадим коллекцию нашей бд и возвратим эту колекцию как значение ключа другой коллекции
def show_categories():
    cats = views.cats_db
    return {"cats": cats}
и тоже обернём это всё в декоратор, но уже с методом inclusion_tag(), в который нужно передать путь к html документу который и будет являтся шаблоном с данными, которые мы хотим передать
@register.inclusion_tag('women/list_categories.html')
def show_categories():
    cats = views.cats_db
    return {"cats": cats}
Далее создаём этот документ и засовываем в неё тот самый цикл с нашими категориями который использует нашу коллекцию
{% for cat in cats %}
         <li><a href="{% url 'category' cat.id %}">{{cat.name}}</a></li>
{% endfor %}

А в основной шаблон вместо прошлого тега и прокрутки его переменной 
{% getcats as categories %}
{% for cat in cats %}
         <li><a href="{% url 'category' cat.id %}">{{cat.name}}</a></li>
{% endfor %}
просто вставляем наш тег, который передаёт новый шаблон
{% show_categories %}

Передача параметров пользовательским тегам
По заданию мы хотим чтобы выбранная категория выделялась цветом при переходе на её адрес, и переставаля быть ссылкой
Делается это так:
в функцию нашего шаблонного тега добавим параметр с дефолтным значением =0, и в возвращаемой коллекции добавим еще один ключ со значением этого параметра
@register.inclusion_tag('women/list_categories.html')
def show_categories(cat_selected=0):
    cats = views.cats_db
    return {"cats": cats, "cat_selected": cat_selected}
А в шаблоне добавим проверку на значение этого параметра, чтобы если парметр равен id строки бд, что значит, если мы перешли на страницу этой категории,
тогда будем выводить категорию без ссылки (строкой), с подсвечиванием (используя класс)
А если проверка не проходит, будем возвращать старую ссылку
{% for cat in cats %}
         {% if cat.id == cat_selected %}
                   <li class="selected">{{cat.name}}</li>
         {% else %}
                   <li><a href="{% url 'category' cat.id %}">{{cat.name}}</a></li>
         {% endif %}
{% endfor %}
В шаблонный тег тоже нужно добавить наовый параметр
{% show_categories cat_selected %}
Раз добавили новый параметр значит нужно его от кудого-то передовать
Добавим передоваемые данные этот параметр для страницы index и страницы категории
def index(request):
    data = {
        'title': 'Главная страница',
        'menu': menu,
        'posts': data_db,
        'cat_selected': 0,   # не обязательная строчка
    }
--------
def show_category(request, cat_id):
    data = {
        'title': 'Отображение по рубрикам',
        'menu': menu,
        'posts': data_db,
        'cat_selected': cat_id,
    }
Вот так мы и реализовали смену ссылок и подсветку наших категорий, но строка "Все котегории" так и осталось статичной синей строкой.
Потому что она ей и является в html коде.
Сделаем ей проверку на то что мы находимся на главной странице и оставим её в том же виде, а если нет, сделаем из неё ссылку на главную страницу
    {% if cat_selected == 0 or cat_selected is None %}
        <li class="selected">Все категории</li>
    {% else %}
        <li><a href="{% url 'home' %}">Все категории</a></li>
    {% endif %}



ВВЕДЕНИЕ В ORM И МОДЕЛИ



УРОК 1 БД, SQL, ORM. СОЗДАНИЕ МОДЕЛИ

Данные для сайта, в рабочих проектах бычно беруться из баз данных
Джанго поддерживает следующие субд:
PostgreSQL, MariaDB, MySQL, Oracle и SQLite
По дефолту проект джанго уже сожержит файл бд с субд SQLite
настройки для выбора бд и указания его положения находяться в setting.py, в переменной DATABASES
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}
Если мы хотим поменять субд нужно, нужно будет поменять и значение этой переменной.

При работе с джанго нам не обязательно переходить в файл бд для создания, изменения и т.д. таблиц.
Мы можем создать модель таблицы, это что-то типо её представления.
модель создаётся в файле models.py внутри приложения.
И реализуется через класс джанги Model. Внутри файла models.py он уже импортирован.

Чтобы создать модель, нужно создать класс Model с названием как и таблицы в бд
и при помощи методов этого класса создать необходимые поля таблицы.
таблица создаётся как и в бд, построчно создавая каждое поле таблицы отдельно.
Кроме поля id, он создаётся автоматически.
Методов создания полей множество, все методы являются методоми класса model, вот ссылка на них с их подробностями:
https://docs.djangoproject.com/en/4.2/ref/models/fields/
В уроке были разобранны некоторые:
CharField(max_length=255) - CharField - тип значения поля varchar; max_length - максимальная длина значения
TextField(blank=True) - TextField - текстовый тип значения поля; blank=True - позволяет не создавать значение для поля, т.е. может быть равен None
DateTimeField(auto_now_add=True) - DateTimeField - поле с типом данных дата и время; auto_now_add=True - автоматически создаёт значение равное значению даты и время на момент создания записи.
У DateTimeField есть ещё параметр auto_now=True, который добавляет значение равное значению даты и время в момент создания и изменения записи
BooleanField(default=True) - BooleanField - булевый тип данных значения поля; default= - принимает дефолтное значение, на случай если мы не добавим значение в запись.

И так мы создали вот такую модель.
class Women(models.Model):
    title = models.CharField(max_length=255)
    content = models.TextField(blank=True)
    time_create = models.DateTimeField(auto_now_add=True)
    time_update = models.DateTimeField(auto_now=True)
    is_published = models.BooleanField(default=True)

Создание модели, не значит создание таблицы.
Таблица создаётся позже, по нашей модели, методом миграций в джанге, об этом дальше



УРОК 2 МИГРАЦИИ

Миграция - это команда в питоне, которая создаёт в связанной бд таблицу по моделе.
сама же миграция представляет из себя питоновский файл, в нем создаётся класс миграции из пакета model.
Причем и файл и код внутри создаётся автоматически, когда мы запускаем эту миграцию
файлы мыграций находяться в директории migrations.
Их может быть огромное множество.
Всё дело в том что при изменениие нашей модели, после запуска миграции, создаётся новый файл миграции.
Но этот файл не перезаписывает нашу таблицу, а изменяет её.
Т.Е. каждаю миграцию можно воспринимать как коммит в гитхабе и по старым миграциям, мы всегда можем откатиться к прошлому состоянию.
Также в папке migrations есть еще один пайтон файл __init__.py что делает, нашу директорию пакетом.

Чтобы создать миграцию нужно открыть терминал и запустить команду
python manage.py makemigrations 
Файл миграции создан, он выглядит примерно так - 0001_initial.py. но это ещё не означает создание таблицы, миграцию еще нужно применить.
Но прежде чем это сделать мы можем заранее посмотреть какой sql запрос выполнится если мы применим конкретную миграцию
python manage.py sqlmigrate women 0001   # sqlmigrate - команда для просмотра sql запроса; women - название приложения; 
0001 - номер миграции, он есть в название файла миграции 0001_initial.py
После выполнения команды, в терминале покажется sql запрос, который будет произведён в бд.
Чтобы наконец исполнить миграцию в терминале нобходимо запустить следующую команду
python manage.py migrate
После этого мы видем как происходит множество разных процессов.
Всё дело в том, что с нашим джанго приложением, связанно множество дополнительных модулей, которые автоматически подключаются к нему.
И в каждом этом модуле есть свои вспомогательные таблицы и данные, которые тоже обновляются вместе с нашей миграцией.

Заходим в ГУИ СУБД и видим что в файле нашего бд создалось аж 11 таблиц.
это и есть те вспомогательные таблицы джанги.
какие-то создались для админки, какие-то для самой джанги и в конце видим нашу таблицу.
Она называется названиеприложения_названиемодели (women_women)



УРОК 3 ДОБАВЛЕНИЕ ЗАПИСЕЙ В БД

Для начала нужно разъяснить кое-что о нашей модели.
модель которую мы описывали классом представляет из себя структуру таблицы.
А объект этой модели будет являтся строкой этой таблицы.
Один объект - одна строка.
Т.Е. чтобы добавить пять строк, нам нужно будет создать пять объектов этого класса, передать в них данные для строки и добавить строку в таблицу

Добавление записи в таблицу тоже происходит в джанге при помощи ОРМ
Для этого нам необходимо перейти в терминал и вызвать там в консоль фреймворка
    python manage.py shell 
Мы переходим в новую консоль где и создаются строки и передаются в таблицы
Чтобы работать с конкретной таблицей сначала нужно импортировать её модель
    from women.models import Women
Создадим строку для нашей таблицы, т.е. вызовим объект класса таблицы и передадим в него данные
    Women(title='Анджелина Джоли', content='Биография Анджелины Джоли')
имена полей являются параметрами класса в них передаём значения для строки.
В примере мы добавили только те значения, которые не создаются автоматически
объект класса перед записью в таблицу, нужно сохранить в переменну, можно было и сразу конечно, но можно воспользоваться символом _
В этой консоле символ _ является специальной ссылкой в которой сохраняется результат последнй операции
    w1 = _   # так мы добавили прошлую операцию в переменную
Когда мы сохраняем строку в переменную в терминале мы видем запись об этом
    <Women: Women object (None)> 
но запись ещё не попала в таблицу
Чтобы это произашло, нужно воспользоваться командой save()
    w1.save()
После выполнения команды запись попадает в таблицу и мы видем такой вывод в консоле
    <Women: Women object (1)>   # цыфра один это id нашей строки
Мы также можем оперировать данными этой строки в терминале
    w1.id # идентификатор
    w1.title # заголовок
    w1.time_create # время добавления записи
Вместо id можно использовать pk (primary key)
    w1.pk     # значение тоже что и w1.id

Мы можем посмотреть какие запрос произашли в бд внутри во время сессии этой консоли
Для этого нужно импортировать 
    from django.db import connection
И обратиться к колекции
connection.queries
В ответе мы видим вывод всех запросов

Добавим ещё запись
w2 = Women(title='Энн Хэтэуэй', content='Биография Энн Хэтэуэй')
w2.save()

Можно создавать строку поэтапно:
Сначала создадим строку
    w3 = Women()
Потом добавим ей значение title
    w3.title = 'Джулия Робертс'
и значение content
    w3.content = 'Биография Джулии Робертс'
и можно сохранять запись в таблицу
w3.save()

Консоль это конечно хорошо но некрасиво и лапки не любят много печатать
Можно установить в интерпритатор проекта пакет ipython
После его установки появляется подсветка синтаксиса и автодополнение кода

А можно еще круче прокачать консоль
Тоже устанавливаем пакет django-extensions
Далее в setting.py, в коллекции INSTALLED_APPS добавляем строку 
    'django_extensions',
и в консоль мы теперь переходим по команде 
python manage.py shell_plus
а можно еще круче. переходим по этой же команде с флагом --print-sql
python manage.py shell_plus --print-sql 
Теперь когда мы залетаем в консоль все импорты и модели импортируются автоматический
А если мы зашли с флагом --print-sql, когда мы добавляем строку, консоль сразу выводит красивый sql запрос который мы только что сделали

Чтобы выйти из консоли нужно прописать команду 
    exit



УРОК 4 МЕТОДЫ ВЫБОРА ЗАПЕСЕЙ ИЗ ТАБЛИЦЫ. LOOKUP

Каждый класс модели содержит специальный статический объект objects, который наследуется от базового класса Model и представляет собой ссылку на специальный класс Manager.
Благодаря нему мы можем обращаться ко всей таблицы нашей модели
Можно вывести его в терминале
    Women.objects
Этот объект называется "менеджер записей" и у него есть полезные методы
К примеру благодоря нему можно записывать строку в таблицу одной командой в терминале, при помощи его метода create
Women.objects.create(title='Ума Турман', content='Биография Ума Турман') 
мы можем сохранить эту команду в переменную и обращаться к его параметрам, как если бы записали сам объекь класса (т.е. строку таблицы)

У objects много полезных методов:
- all() - показывает список всех объектов класса модели (строк) в таблице
    Women.objects.all() 
На выходе команды получим такой список
    <QuerySet [<Women: Women object (1)>, <Women: Women object (2)>, <Women: Women object (3)>, <Women: Women object (4)>, <Women: Women object (5)>, <Women: Women object (6)>]> 
Он не очень информативен. Но можно сделать его более понятным, поправив саму модель
Добавим в неё магический метод __str__, а выводом метода будет содержимое поля title
    def __str__(self):
        return self.title
Теперь вывод Women.objects.all() будет таким
    <QuerySet [<Women: Анджелина Джоли>, <Women: Энн Хэтэуэй>, <Women: Джулия Робертс>, <Women: Екатерина Гусева>, <Women: Ума Турман>, <Women: Кира Найтли>]> 
К этому списку можно обращаться по индексу, если мы хотим получить конкретное количество записей
    Women.objects.all()[0]
Все эти команды можно сохранять в переменной и обращаться к их атрибутом
Срезами тоже можно пользоваться
    w = Women.objects.all()[:3]
И прокручивать в цикле, мы же всё-таки в питонской консоле
    ws = Women.objects.all()
        for w in ws:
        print(w)
Кстати наша консоль при каждой команде всё еще показывает sql запрос и джанга делает их всегда максимально не нагруженными

- filter() - возвращает список строк где находит совпадение
Women.objects.filter(title='Энн Хэтэуэй')   # вернёт список строк где titile равен Энн Хэтэуэй
В этой команде совпадение должно быть полное, а не частью значения, т.е. так не сработает:
Women.objects.filter(title='Энн')  # вернёт пустой список, потому-что не наёдёт совпадений

Стандартные операторы сравнения и куча чего ещё тут не работает
т.е. так нельзя
Women.objects.filter(pk > 2)   # хотим найти все строки у кого id больше двух, но получим ошибку
Не работает, так как pk – это именованный параметр и ему нужно явно присваивать определенное значение
Поэтому подобниые операции делаются специальными методами, для методов objects
эти подметоды называются lookup’ы
К примеру вот методы сравнения
    <имя атрибута>__gte – сравнение больше или равно (>=);
    <имя атрибута>__gt – сравнение больше (>);
    <имя атрибута>__lte – сравнение меньше или равно (<=);
    <имя атрибута>__lt – сравнение меньше (<). 

Подробная информация о методах и lookup'ах в документации
https://docs.djangoproject.com/en/4.2/ref/models/querysets/#field-lookups 

Вот как сделать операцию Women.objects.filter(pk > 2) в этой программе
    Women.objects.filter(pk__gte=2)

Еще лукапы
__contains - ищет совпадение строки в поле
    Women.objects.filter(title__contains='ли')   # создаёт услови «WHERE title LIKE '%ли%'» в заросе sql
Выведет список всех строк где в title есть подстрока 'ли'
__icontains - тоже что __contains, но игнорирует регистр подстроки 
вот только это лукап не работет для sqlite потому-что, sqlite сама по себе так не умеет =)
__in - ищет строки со значением поля, равное значению элементу переданного списка и выводит все совпадения
Women.objects.filter(pk__in=[2,5,11,12])  # выведет все строки у котрых id равет 2,5,11,12   в нашем случае только 2 и 5

Можно передать через запятую сразу несколько условий совпадения для метода 
это будет значить что мы должны искать совпадения по двум условия с логическим И
    Women.objects.filter(pk__in=[2,5,11,12], is_published=1)  # внизу аналогичный запрос в sql
WHERE ("women_women"."is_published" AND "women_women"."id" IN (2, 5, 11, 12)) 

Ещё методы objects:
- exclude() - обратный метод filter.
т.е. он ищет не совпадения условия
    Women.objects.exclude(pk=2)  # вернет список записи где id не равен двум

- get() - гет делает тоже что и filter но возвращает значени а не список значений, причём только одно
если он найдёт несколько совпадений или не найдёт его вовсе, прилетит исключение
    Women.objects.get(pk=2)  # получем объект модели с идентификатором 2, а не список с одним объектом модели как filter
get удобен ещё и проверкой на то что в таблице существует только одна искомая запись, ведь если он найдёт несколько совпадений - он закрашится

Все лукапы работают со всеми методами objects, если не нарушают логику их работы



УРОК 4 СОРТИРОВКА, ИЗМЕНЕНИЕ, УДАЛЕНИЕ ЗАПИСЕЙ

Внутри нашей любимой консоли, можно делать сортировку как в sql запросе c order by
Это делается методом объекта objects - order_by() =) В него передаётся название поля по которумы мы будем сортировать
    Women.objects.all().order_by('title')  # вернёт все строки отсортировнные по title
строки сортируются по стандарту сортировки sql
    ORDER BY "women_women"."title" ASC
Можно кстати не указвать метод all()
    Women.objects.order_by('title')  # отработает также как и прошлый
метод order_by можно применять в цепочки с другими методами которые возвращают коллекцию QuerySet (список строк)
    Women.objects.filter(pk__lte=4).order_by('title')
Если мы хотим отсортировать в обратном порядке (DESC), вначале названия поля нужно поставить знак минуса
    Women.objects.order_by('-time_update')

Можно сделать так чтобы наша модель всегда была отсортированна по дефолту
Для этого в классе модели, нужно воспользоваться классом вложенным Meta
У этого класса есть множество атрибутов, которые отвечают за разные свойства модели
Например атрибут ordering, который делает дефолтную сортировку таблице
Или indexes, который делает поля индексируемыми, чтобы эта самая сортировка работала быстрее
В оба атрибута передаём список полей и их порядок сортировки/индексации
    class Women(models.Model):
        ...
        class Meta:
            ordering = ['-time_create']
            indexes = [           # для indexes нужно прописать класс models.Index с параметром fields, в который мы и передаём поля с учётом сортировки
                models.Index(fields=['-time_create']),
            ]
 
        def __str__(self):
            return self.title

Подробности о классе Meta и его методов, в документации
https://docs.djangoproject.com/en/4.2/ref/models/options/

После настройки класса модели наши поля всегда будут отсортированны, даже без order_by()
Women.objects.all()  # вернёт отсортированный список строк

Вспоминае про CRUD в SQL и очень хотим узнать как изменять таблицы и удалять данные
Для одной строки можно сохранить строку в переменную и напрямую передать новые значения атрибута объекта модели
    wu = Women.objects.get(pk=2)
    wu.title = 'Марго Робби'
    wu.content = 'Биография Марго Робби'
а потом методом save() изменить данные в таблице, ведь он не только создаёт данные, но и изменяет их
    wu.save()

Но если нам нужно изменить несколько или сразу все строки то нужно воспользоваться методом update в который передадим поле и его новое значение
    Women.objects.update(is_published=0)   # меняем значение is_published на 0 для всех строк
update() как и order_by() можно использовать в цепочки с другими методами
    Women.objects.filter(pk__lte=4).update(is_published=1) 
и она тоже работает только с коллекцией QuerySet (список строк) тоесть она не будет работать с методом get()
    Women.objects.get(pk=5).update(is_published=1)  # ошибка
а ещё update не работает со срезами
    Women.objects.all()[:4].update(is_published=1)   # тоже ошибка

И наконец удаление
Оно осуществляется благодаря методу delete()
Чтобы использовать можно добавить колеекцию QuerySet в переменную и к этой переменной применить метод delete()
wd = Women.objects.filter(pk__gte=5)
wd.delete()
Но можно и цепочкой как update
Women.objects.filter(pk__gte=5).wd.delete()



УРОК 5 SLUG В URL АДРЕСАХ. МЕТОД get_absolut_url()

в url адресах часто присутствуют слаг записи.
такие адреса лучше подходят для работы браузера и выглядят понятнее для пользователей
Адреса постов женщин на сайте используют используют загрлушку вместо нормального адреса.
В эти адреса и нужно добавить слаги, но сначала сделаем их по id

Для начала нужно сделать нормальную функцию представление, потому-что у нас там стоит заглушка
def show_post(request, post_id):
    post = get_object_or_404(Women, pk=post_id)
    data = {
        'title': post.title,
        'menu': menu,
        'post': post,
        'cat_selected': 1,
    }
    return render(request, 'women/post.html', context=data)
Что мы сделали?
воспользовались функцией get_object_or_404()
Она возвращает переданный объект класса (это объект нашей модели), с выбранным критерием
в данном случае этот критерий pk, т.е. идентификатор равный переданному в функцию аргументу post_id
Т.Е. сдесь аргумент функции pk будет говорить какую строку нам передовать изходя из динамического запроса маршрута show_post
Я так понимаю что можно и не передовать никаких аргументов кроме объекта класса, но тогда мы всегда будем получать первую строку модели.
Если же функция get_object_or_404 не может вернуть строку, то она вызовит объект класса Http404.
Далее создаём коллекцию для страници с данными для шаблона, где есть и сама строка модели и её поле title
А в render передаём новую страницу и коллекцию данных

Теперь создадим и шаблон.
В нём ничего нового, только фотку передаём, но это на будущее
{% extends 'base.html' %}
 
{% block content %}
<h1>{{post.title}}</h1>
 
{% if post.photo %}
<p ><img class="img-article-left" src="{{post.photo.url}}"></p>
{% endif %}
 
{{post.content|linebreaks}}
{% endblock %}

Итак мы реализовли урл по айдишнику, теперь можно переделать его по слагу.
Айдишник мы брали из бд pk=post_id, и слаг тоже надо брать от туда, но как?
Добавим новое поле в таблицу где и будем хранить наш слаг для каждо строки
slug = models.SlugField(max_length=255, unique=True, db_index=True)  # вот так он должен выглядеть
Он реалезован через метод SlugField, это строковый тип данных.
В нём есть параметр unique=True - значит он должен быть уникальным
также параметр db_index=True, т.е. мы делаем поле индексируемым, чтобы ускорить выборку
Но если мы сейчас замигрируем изменения в таблицы, то полезут ошибки
Потому что поле создастся пустым, а у нас по дефолту стоит NOT NONE если мы не указываем blank=True
а ещё у нас есть уникальност значений поля, что тоже не даст нам его создать, потому что у нас будут все значения одинаковыми.
Но мы можем создать это поле без уникальности и с разрешение NONE
потом замигрировать его, наполнить данными, соответствующими изначальному виду, и потом изменить поле на нужный нам формат.
Создадим же первую стадию поля и замигрируем его
slug = models.SlugField(max_length=255, db_index=True, blank=True, default='')
А теперь добавим значения в эти поля вручную
Можно сначала накидать каких нибудь значений заглушек.
Например в консоле фреймворка сделать так
    for w in Women.objects.all():
        w.slug = 'slug-'+str(w.pk)
        w.save()
А потом вернуться в модель и поменять поле на нужный нам формат и замигрировать его
slug = models.SlugField(max_length=255, db_index=True, unique=True)

Слаги готовы и теперь можно поменять в наших урл идентификаторы на слаги

Сначала в маршруте поменяем конвертер с post/<int:post_id>/ на post/<slug:post_slug>/

Теперь и во вьюшке поменяем айдишник на слаг
def show_post(request, post_slug):
    post = get_object_or_404(Women, slug=post_slug)

теперь наши посты открываются по урл со слагом 
http://127.0.0.1:8000/post/slug-1/

Всё работает и теперь можно сделать слаги красивыми (можно вручную прямо в dbeaver)
    andzhelina-dzholi
    margo-robbi
    dzhuliya-roberts
    ekaterina-guseva 
Поменяли и урл стали лучше
http://127.0.0.1:8000/post/andzhelina-dzholi/


Теперь можно поправить кнопочки на сайте, ведь наши ссылки в html никто не трогал и они работают по старым данным
<p class="link-read-post"><a href="{% url 'post' p.id %}">Читать пост</a></p>
Но для url со слагом нужно формировать урл не при помощи шаблонного тега url, а при помощи собственного метода модели

Создадим этот метод в моделе
    def get_absolute_url(self):
        return reverse('post', kwargs={'post_slug': self.slug})  # вспоминаем как мы сравнивали тег url с функцией reverse
кстати не забываем импортировать from django.urls import reverse
Название метода и его тело конечно произвольное, но оно образцовое.
т.е. именно так джанго рекомендует называть и и создавать этот метод для того чтобы формировать урл со слагом

Теперь этот метод можно вызывать в шаблоне html
было так - {% url 'post' p.id %}
стало так - {{ p.get_absolute_url }}

Почему надо делать именно так а не просто поменять p.id на p.slug
Если вдруг мы захотим поменять url со слаг варианта, снова на id или на что-то друго. 
то нам придётся менять эту запись во всех тегах где она есть, а их может быть множество во множестве шаблонов.
Но теперь нам достаточно только параметр внутри функции revers, внутри функции get_absolute_url 
и url смениться везде где мы используем эту функцию
Ну и конвертер в маршруте тоже надо будет изменить.

Еще один плюс подобного подхода заключается в том что модули джанго используют эту функцию в своей работе
админ-панель обращается к этому методу для построения ссылок на каждую запись наших моделей.
В дальнейшем мы ещё узнаем об этом

тег url же стоит употреблять только для ссылок не связанных с моделями

Почти всё, осталось только передать нашу модель во вьюшку index
и изменить её коллекцию данных
(Вообще, это как будто бы можно было сделать намного раньше =-) )
def index(request):
    posts = Women.objects.filter(is_published=1)   # передаём строки с is_published равной true
    data = {
        'title': 'Главная страница',
        'menu': menu,
        'posts': posts,     # и добавляем объект модели в коллекцию для шаблона
    }
 
    return render(request, 'women/index.html', context=data)

Теперь у нас и ссылки красивые, и сделаны они как надо, и бд везде подсоеденино



УРОК 6 СОЗДАНИЕ ПОЛЬЗОВАТЕЛЬСКОГО МЕНЕДЖЕРА МОДЕЛИ

Ранее мы обращались к объекту модели благодоря стандартному джанго менеджеру objects.
Но мы можем создать свой собственный менеджер внутри модели, чтобы обращаться через него

Для этого в файле models.py нужно создать класс, относоледованный от класса Manager
и создать в нём метод, который будет возвращать родительский метод класса .get_queryset() который вызывает список записей нашей таблицы.
Тоже делает и сам object, но в своём менеджере мы можем добавить дополнительные методы к вызову, например для фильтрации данных
class PublishedModel(models.Manager):  # создаём класс
    def get_queryset(self):         # создаём метод
        return super().get_queryset().filter(is_published=1)   # вызываем родительский метод get_queryset() и к нему добавляем метод который будет принимать только строки с is_published ровным одному, т.е. True
так наш менеджер будет возвращать только строки с опубликованными статьями

Теперь, внутри модели нужно обявить объект этого класса нашего менджера.
    published = PublishedModel()

Важно знать!
Когда мы создаём модель. менеджер object создаётся автоматически.
Но когда мы создаём в моделе новый менеджер в модели, object перестаёт существовать
Но его существование всёже нужно для работы модели и его объект тоже нужно объявить внутри модели
    objects = models.Manager()
    published = PublishedModel()

У нас есть новый менеджер и теперь нам нужно поменять во всех вьюшках вызов объекта модели со старого на новый
Сначала поменяем в index
def index(request):
    posts = Women.published.all()   # к старому менеджеру мы прицепляли проверку на публикацию, а сейчас нам уже это не требуется
    data = {
        'title': 'Главная страница',
        'menu': menu,
        'posts': posts,
    }
 
    return render(request, 'women/index.html', context=data)

И во вюшке show_category тоже поменям. там кстати мы брали данные из бд заглушки - коллекция data_db, её можно удалить
def show_category(request, cat_id):
    data = {
        'title': 'Отображение по рубрикам',
        'menu': menu,
        'posts': Women.published.all(),
        'cat_selected': cat_id,
    }
 
    return render(request, 'women/index.html', context=data)

В шаблоне index.html мы делали проверку на публикацию записи, её тоже можно больше не делать. Сотрём!

Перечисляемые поля

Мы в нашей модели делаем проверку на публикицию при помощи is_published=1
Но это не очень информативная запись
потому-что, чтобы понять что мы проверяем, нужно лезть в таблицу и смотреть тип данных поля 
Можно сделать внешний вид этой проверки более читаемым
В этом нам поможет класс IntegerChoices он нужен для определения осмысленных имен для непонятных значений

Создадим собственный класс отнаследованный от IntegerChoices внутри модели
А внутри него создадим параметры равные кортежу (значение, описание)
    class Status(models.IntegerChoices):
        DRAFT = 0, 'Черновик'
        PUBLISHED = 1, 'Опубликовано'

По сути мы создали переменную со значением и коментарием о ней и сохранили в неё и значение и комментарий
Теперь можно подставлять эту переменную внутри нашей модели где угодно, вместо самого значения.
По названию этой переменной, легче понять её значение, но мы можем также обратиться и к описанию (комментарию) этой переменной

Поменяем значение в модели
    is_published = models.BooleanField(choices=Status.choices, default=Status.DRAFT)

Если поменяли модель то нужно и миграцию сделать

можно обращаться к этой переменной и внутри консоли фреймворка
w = Women.objects.all()
w.update(is_published=Women.Status.PUBLISHED)

И там же мы можем посмотреть значение и описания для нашего класса Status
Women.Status.choices - посмотреть список кортежей значение, описание  # [(0, 'Черновик'), (1, 'Опубликовано')] 
Women.Status.values - посмотреть список значений # [0, 1] 
Women.Status.labels - посмотреть список описаний # ['Черновик', 'Опубликовано'] 

Теперь значение поля is_published стало понятнее

Добавим новое оформление значение и в менеджер
class PublishedModel(models.Manager):
    def get_queryset(self):
        return super().get_queryset().filter(is_published=Women.Status.PUBLISHED)



СВЯЗИ МЕЖДУ ТАБЛИЦАМИ



УРОК 1 ТИПЫ СВЯЗЕЙ МЕЖДУ МОДЕЛЯМИ

В реальной бд множество таблиц и многие из низ связанны
В модели, поля для связи таблиц определяются следующими следующими классами
    ForeignKey – для связей Many to One (многие к одному);
    ManyToManyField – для связей Many to Many (многие ко многим);
    OneToOneField – для связей One to One (один к одному). 
Подробнее об этом в документации:
https://docs.djangoproject.com/en/4.2/ref/models/fields/#module-django.db.models.fields.related



УРОК 2 СОЗДАНИЕ СВЯЗИ MANY-TO-ONE

Итак, пора делать нашу бд более похожую на бд настоящего проекта
У нас есть список категорий женщин и дожна быть таблица с этими категориями
которая связана с таблицей женьщин по связи many-to-one

Создаём вторую таблицу, а значит, вторую модель в файле models.py
Выглядить будет так
В мадели ничего нового, описаны два поля - название котегории, и её слаг для оброзования url
Айдишник как мы помним создаётся автоматически
Строковое представление объекта модели, будет равно значению поля названия в строке
class Category(models.Model):
    name = models.CharField(max_length=100, db_index=True)
    slug = models.SlugField(max_length=255, unique=True, db_index=True)
 
    def __str__(self):
        return self.name

Чтобы связать таблицы, во вторичной таблице нужно создать поле - вторичный ключ для связующей таблицы
И тут есть маленькие тонкости
Как мы помним тип объекта этого поля должен быть реализован классом ForeignKey
Он принимает в себя два параметра - Объект модели связанной таблицы и тип ограничения при удалении внешней записи
Если мы пропишем объект модели, "то интерпритатор может начать ругаться", потому-что мы еще не создали эту модель, т.е. не замигрировали её
Поэтому, в этом случае можно прописать название класса модели в строковом виде т.е. в кавычках.
ограничения при удалении внешней записи - отвечает за то, что будет происходить со строкой во вторичной таблице если мы удалим связанную строку в первичной таблице.
Эти типы определены функциями и нам нужно передать одну из множества вариантов этих функций во второй аргумент класса ForeignKey под названием on_delete
Вот они эти функции:
    models.CASCADE – удаление всех записей из вторичной модели (например, Women), связанных с удаляемой категорией;
    models.PROTECT – запрещает удаление записи из первичной модели, если она используется во вторичной (выдает исключение);
    models.SET_NULL – при удалении записи первичной модели (Category) устанавливает значение foreign key в NULL у соответствующих записей вторичной модели (Women);
    models.SET_DEFAULT – то же самое, что и SET_NULL, только вместо значения NULL устанавливает значение по умолчанию;
    models.SET() – то же самое, только устанавливает пользовательское значение;
    models.DO_NOTHING – удаление записи в первичной модели (Category) не вызывает никаких действий у вторичных моделей. 
Подробности о этих функциях в документации
https://docs.djangoproject.com/en/4.2/ref/models/fields/#arguments
Создадим же это поле
cat = models.ForeignKey('Category', on_delete=models.PROTECT)
Оброщаем внимание на то, что мы называем объект класса просто cat, а не cat_id какое у неё и должно быть название.
Но ничего страшного - полное название для поля в таблице cat_id, джанго допишет сам
Новые таблицу и поле добавили, но замегрировать их не получиться.
Потому-что у нашего вторичного ключа по дефолту стот настройка NOT NULL, 
а при создании таблицы строк в ней не будет, следовательно и ссылаться не на что 
Поэтому в момент создания таблицы и вторичного ключа, для вторичного ключа разрешим иметь значение null, а когда добавим значения в первичную таблицу уберем разрешение на null
И по итого наше поле в момент создания будет выглядить так:
    cat = models.ForeignKey('Category', on_delete=models.PROTECT, null=True)

Теперь можно делать миграцию

Таблицы и поле созданны и теперь перйдём в консоль фреймворка и добавим в нашу новую таблицу данные, уже знакомым способом
Category.objects.create(name='Актрисы', slug='aktrisy')
Category.objects.create(name='Певицы', slug='pevicy')

А после добавим значения для вторичного ключа в таблице women
w_list = Women.objects.all()
w_list.update(cat_id=1)

И теперь можно выйти из консоли, удалить разрешение на null во вторичном ключе и замигрировать изменения

Можно перейти в консоль и проверить работоспособность наших новых данных
К примеру поробывать удалить первую строку в таблице Category
c = Category.objects.get(pk=1)
c.delete()
Но у нас ничего не выйдет, потому-что не даст параметр PROTECT в классе ForeignKey
Но не связанные строки можно удалять

А вот если бы у нас вместа параметра PROTECT был параметр CASCADE
при удалении строки категории, удалились бы все строки во вторичной таблице, связанные с этой категорией



УРОК 3 ORM КОМАНДЫ ДЛЯ СВЯЗИ MANY-TO-ONE

Как мы знаем наше поле, внутри таблицы, во вториченой модели называется cat_it.
Но сам атрибут класса моделили, называется просто cat
В орм мы можем обращаться к модели и по названию поля таблицы и по атрибуту класса модели
Но при этом мы будем получать разные данные.
При обращение по названию поля в таблице, мы получим значение поля
w = Women.objects.get(pk=1)
w.cat_id  # 1
А при обращение по атрибуту, мы получим объект связанной модели который связан с нашим объектом
w.cat  # вернётся объект модели Category с id равным cat_id
И раз мы можем достучаться через одну модель к другой связанной, то мы также можем и достучаться к её атрибутам
w.cat.name   # Актрисы

Но можно делать и наоборот - взаимодействовать со вторичной моделью через первичную
Когда мы связываем модели, у вторичной модели автоматически появляется встроенный метод который называется - <вторичная модель>_set
через этот метод мы можем подключаться к менеджеру вторичной модели из первичной, он как-бы и есть ссылка на менеджер втроичной модели
Используя его мы можем брать объекты первичной модели и относительно них, подключаться ко вторичной модели
т.е. запрашивать вторичную модель со связанными объектами с объектом объектом первичной модели 
c = Category.objects.get(pk=1)  # сохранили объект менеджера модели Category
c.women_set.all() # возьми все объекты втор. модели связанные с переменной с (Актрисы)

Методу women_set можно придать собственное название.
Делается это в классе первичной модели, для поля вторичного ключа
В класс ForeignKey нужно передать дополнительный аргумент related_name= и строковое значение которое будет являтся название метода women_set
related_name='posts'
cat = models.ForeignKey('Category', on_delete=models.PROTECT, related_name='posts')
Делать миграцию после этого не нужно но может потребоваться перезайти в orm
Теперь мы можем обращаться по этому методу с новым именем
c = Category.objects.get(pk=1)
c.posts.filter(is_published=1)

Так как атрибут cat для второй модели является обектом класса вторичной модели
мы можем делать фильтрацию запросов черз этот обект класса и для него делать лукапы
cats = Category.objects.all()
Women.objects.filter(cat__in=cats)
Это аналог записи
Women.objects.filter(cat_id__in=[1, 2])  # тоже самое
Women.objects.filter(cat__in=[1, 2])     # тоже самое

Мы также можем использовать атрибуты объекта первичной модели, используя их как лукапы
Women.objects.filter(cat__slug='aktrisy')  # покажи все объекты втор. модели связанные с объетом перв. модели у которой значение поля slug равно aktrisy
Можно делать тоже самое но еще и в совакупе с лукапами
Women.objects.filter(cat__name__contains='ы') # покажи все строки women связанные со строкой Category где в поле name есть совпадение с подстрокой 'ы'
И тоже самое можно делать и для перв. модели связывая её с вторичной через метод связи с её менеджером
Category.objects.filter(posts__title__contains='ли')  # покажи все все строки первичной модели которые входят во вторичную модель где в её строке, в поле title есть совпадение с подстрокой 'ли'
В этом запросе мы запрашиваем таблицу category и при одинаковых совпадениях наши строки будут дублироваться
В SQL есть функция distinct которая уберает дублирующие значения в выводе.
В ОРМ есть функция с аналогичным названием, которая добавляет в sql запрос вышеозвученную функцию
Category.objects.filter(posts__title__contains='ли').distinct()



УРОК 4 ОТОБРОЖЕНИЕ ПОСТОВ ПО РУБРИКАМ

В этом уроке нет новой информации по джанго мы просто модернизируем на проект, используя уже знакомые нам методы
Цель урока сделать отображение постов по категориям. т.е. добавить нашу новую таблицу в маршрут категорий и поменять шаблон

сначала изменим маршрут и будем делать его по слаг конвертеру:
path('category/<slug:cat_slug>/', views.show_category, name='category'),

Следом меняем вьюшку
И не забываем импортировать модель Category
def show_category(request, cat_slug):
    category = get_object_or_404(Category, slug=cat_slug)   # сохраняем объект модели Category
    posts = Women.published.filter(cat_id=category.pk)    # и объект модели Women
    data = {
        'title': f'Рубрика: {category.name}', меняем отображение title страницы для шаблона
        'menu': menu,
        'posts': posts,    
        'cat_selected': category.pk,  # меняем id бд заглушки, на id Category 
    }
 
    return render(request, 'women/index.html', context=data)

Вспоминаем что наши рубрики отображаются с помощью пользовательского шаблонного тега (то что мы делали для изменения цвета и ссылки рубрики)
он тут если что templatetags/women_tags.py
там мы брали данные из бд заглушки, а сейчас будем из реальной бд
@register.inclusion_tag('women/list_categories.html')
def show_categories(cat_selected_id=0):
    cats = Category.objects.all()   # берем категории из бд Category 
    return {"cats": cats, "cat_selected": cat_selected_id}
Так как мы добавили нашу модель в этот файл, то её тоже нужно импортировать

Ну и погнали менять шаблон
урл в шаблоне брался из {% url 'category' cat.id %}
а мы воспользуемся нормальной функцией - cat.get_absolute_url
{% for cat in cats %}
         {% if cat.id == cat_selected %}
                   <li class="selected">{{cat.name}}</li>
         {% else %}
                   <li><a href="{{ cat.get_absolute_url }}">{{cat.name}}</a></li>
         {% endif %}
{% endfor %}

МЫ воспользовались функцией get_absolute_url, но ещё не создали её в Category, погнали создавать!
    def get_absolute_url(self):
        return reverse('category', kwargs={'cat_slug': self.slug})

Вот и всё!
Но как же без дополнительных модификаций?

Добавим в наши статьи вывод названия рубрики и время публикации поста:
Бд уже подключена везде где надо, а значит правки нужны только в шаблоне
Отображение будет чуть выше названия поста
тоесть перед строкой <h2>{{p.title}}</h2> в нашем цикле постов нужно внутри шаблона
            <div class="article-panel">
            <p class="first">Категория: {{p.cat.name}}</p>
            <p class="last">Дата: {{p.time_update|date:"d-m-Y H:i:s"}}</p>
            </div>



УРОК 5 ДОБАВЛЯЕМ СВЯЗЬ MANY-TO-MANY

Для создания связи мany-to-many сперва создадим таблицу с которорой будем связываться
это будет таблица с тегами постов (внешние критерии женщин)

Вообще для тегирования данных существует множество модулей в джанго и при реальной задаче удобнее найти и воспользоваться существующем модулем. посмотреть их можно тут
https://django-taggit.readthedocs.io/en/latest/
Но мы всё сделаем вручную

создаём модель, пока ничего нового
class TagPost(models.Model):
    tag = models.CharField(max_length=100, db_index=True)
    slug = models.SlugField(max_length=255, unique=True, db_index=True)
 
    def __str__(self):
        return self.tag


Модель для промежуточной таблицы создавать не нужно, таблица создастся автоматически если джанго поймёт что две таблицы связанны 
А чтобы джанго это понял в поле основной (women) таблицы нужно добавить поле с кассом ManyToManyField
У ManyToManyField из обязательных параметров только название модели с которой будет связь.
Никаких условий при удаление связанных записий писать не нужно, оно и логично
Но мы также можем указать и другие настройки поля, точнее настройки связи
например разрешить значение null или задать имя для менеджера связи с таблицей
Мы создаём поле в модели, но этот класс не создаёт реальную колонку в таблице, ведь связь реализованна в промежуточной таблице
    tags = models.ManyToManyField('TagPost', blank=True, related_name='tags')
Подробнее о классе ManyToManyField в документации

модели и связи созданны значит пора делать миграцию
    python manage.py makemigrations 
    python manage.py migrate 

Всё супер, погнали в ORM добавлять данные в новую таблицу
    TagPost.objects.create(tag='Блондинки', slug='blonde')
    TagPost.objects.create(tag='Брюнетки', slug='brunetky')
    TagPost.objects.create(tag='Оскар', slug='oskar')
    TagPost.objects.create(tag='Олимпиада', slug='olimpiada')
    TagPost.objects.create(tag='Высокие', slug='visokie')
    TagPost.objects.create(tag='Средние', slug='srednie')
    TagPost.objects.create(tag='Низкие', slug='niskie')

Теперь мы можем присвоить наши теги (установить связь) к нашим женщинам
    a = Women.objects.get(pk=1)   # возьмём строку из первой тиблицы женщин
    tag_br = TagPost.objects.all()[1]  # возьмём тег из таблицы тегов
    tag_o, tag_v = TagPost.objects.filter(id__in=[3, 5])  # сохраним ещё пару тегов

Так как мы связали две таблицы у наших объектов для связи появился новый менеджер и мы изначально назвали его tags
Он и осуществляет добавление новых тегов для основной таблицы (связывает данные)
точнее его метод set
    a.tags.set([tag_br, tag_o, tag_v]) # добавим свяжем нашу строку со всеми нашими тегами
Если нужно добавить только один тег для этого используется метод add
    a.tags.add(tag_br)
Если добавить тег который уже и так добавлен, ничего не произайдёт, дублирования не будет
можно удалить тег при помощи метода remove
    a.tags.remove(tag_o)
И просматривать все теги связанные со строкой 
    a.tags.all()
или наоборот посмотреть все строки связанные с тегом
    tag_br.tags.all()

Мы не можем одновременно создавать строку и сразу связывать её с тегом
Women.objects.create(title='Ариана Гранде', slug='ariana-grande', cat_id=2, tags=[tag_br, tag_v])
Потому что, связваются через идентификатор и у создаваемой строки его ещё нет, значит и связь не установить
Поэтому сначала создаём строку, а потом связываем с тегами



УРОК 6 ДОБАВЛЕНИЕ ТЕГОВ НА САЙТ

В этом уроке практически нет ничего нового, мы просто модернизируем сайт по уже знакомым методам

Цель урока сделать меню отображения тегов, как мы делали для меню категорий
А потом сделать отоброжение тегов в посте, тех что с ним связанны конечно

Полетели!
Сначала прописываем маршрут для меню тегов
    path('tag/<slug:tag_slug>/', views.show_tag_postlist, name='tag'),

Создадим функцию get_absolute_url для модели тегов
    def get_absolute_url(self):
        return reverse('tag', kwargs={'tag_slug': self.slug})

Теперь создадим и вьюшку для меню тегов, (не забываем импортировать модель):
    def show_tag_postlist(request, tag_slug):
        tag = get_object_or_404(TagPost, slug=tag_slug)
        posts = tag.tags.filter(is_published=Women.Status.PUBLISHED)  # через менедже tags достаём связанные с ним опубликованные строки из таблицы women
        data = {
            'title': f'Тег: {tag.tag}',   # tag.tag - 1) переменная внутри функции, 2) поле tag внутри таблицы
            'menu': menu,
            'posts': posts,
            'cat_selected': None,
        }
 
        return render(request, 'women/index.html', context=data)

Когда мы будем сортировать посты на сайте через теги, наши категории не должны подсвечиваться, а там сейчас всегда что-светит
Исправим это, но пока только во вюшке index, добавив добавив в пердоваемую коллекцию переменную cat_selected = 0
    def index(request):
        data = {
            'title': 'Главная страница',
            'menu': menu,
            'posts': Women.published.all(),
            'cat_selected': 0,
        }

    return render(request, 'women/index.html', context=data)

И создадим шаблонный тег для отображения меню тегов, как делали для категорий (не забываем импортировать модель)
Он просто передаёт все теги что у нас есть
    @register.inclusion_tag('women/list_tags.html')
    def show_all_tags():
        return {"tags": TagPost.objects.all()}


Полетели создавать html для меню тегов women/list_tags.html
Там всё предельно просто, нужно прокрутить все теги циклом
{% if tags %}
    Теги:</p>
    <ul class="tags-list">
        {% for t in tags %}
        <li><a href="{{t.get_absolute_url}}">{{t.tag}}</a></li>
        {% endfor %}
    </ul>
{% endif %}

Далее меняем базовый шаблон, добавление в сайдбара меню тегов, он будет идти после сайдбара ютуб канала
<li>{% show_all_tags %}</li>
Вот так будет выглядеть весь сайдбар
<!-- Sidebar слева -->
    <td valign="top" class="left-chapters">
        <ul id="leftchapters">
        {% if cat_selected == 0 %}  # Мы убрали проверку cat_selected is None чтобы не святилось когда мы в меню тегов
            <li class="selected">Все категории</li>
        {% else %}
            <li><a href="{% url 'home' %}">Все категории</a></li>
        {% endif %}
        {% show_categories cat_selected %}

        <li class="share">
        <p>Наш канал</p>
        <a class="share-yt" href="https://www.youtube.com/channel/UClJzWfGWuGJL2t-3dYKcHTA/playlists" target="_blank" rel="nofollow"></a>
        </li>
            <li>{% show_all_tags %}</li>   # вот наше меню
    </ul>
</td>
<!-- Конец Sidebar'а -->

Прямо под сайдбаром мы создавали на будущее блок
    <!-- Хлебные крошки -->
    {% block breadcrumbs %}
    {% endblock %}
Мы делали это как раз для того чтобы в постах отображать теги связанные с постом

Меню создано, осталось только добавить отоброжение связанных тегов внутри страницы поста
Прямо в самом начале шаблона post.html (потому-что отоброжение тегов будет вверху) допишим такой код
{% block breadcrumbs %}
<!-- Теги -->
{% with post.tags.all as tags %} # тег with позволяет создавать переменные использую пайтон код
{% if tags %}
<ul class="tags-list">
    <li>Теги:</li>
    {% for t in tags %}
    <li><a href="{{t.get_absolute_url}}">{{t.tag}}</a></li>
    {% endfor %}
</ul>
{% endif %}
{% endwith %}
{% endblock %}



УРОК 7 СВЯЗЬ ONE-TO-ONE

Создаём связь one-to-one
В уроке нам нужно будет создать таблицу для этой связи
и связать наши данные с этой таблицей
Таблица будет хранить данные мужей наших женьщин

Создаём таблицу
class Husband(models.Model):
    name = models.CharField(max_length=100)
    age = models.IntegerField(null=True)
 
    def __str__(self):
        return self.name

И добавляем поле в основную модель для связи таблиц
Связь таблиц о-т-о осуществляется классом OneToOneField
В класс нужно передать имя связанной модели и что делать с если запись в ней удалиться - on_delete
    husband = models.OneToOneField('Husband', on_delete=models.SET_NULL, null=True, blank=True, related_name='wuman')
SET_NULL - делает так чтобы если запись удалилась, начение поля поменялось на null
имя менеджера для обратной связи тоже задали

Мигрируем!

Все создалось и теперь можно перейти в ОРМ и работать с таблицами

Добавим данные в таблицу мужей
    h1 = Husband.objects.create(name="Брэд Питт", age=59)
    h2 = Husband.objects.create(name="Том Акерли", age=31)
    h3 = Husband.objects.create(name="Дэниэл Модер")
    h4 = Husband.objects.create(name="Кук Марони")

Теперь свяжем строки с двух таблиц
    w1 = Women.objects.get(pk=1) # берем джоли
    w1.husband = h1 # к полю husband для джоли присвоем значение равное объекту модели мужей Бреда Питта
    w1.save() # Сохраняем данные

Чекаем таблицу и видем что в поле husband для строки Джоли есть значение равное идентификатору Бреда Питта в его таблице
Можено и в ОРЬ это посмотреть
    w1.husband
Можно посмотреть и жену Питта через менеджер обратной связи
    h1.wuman

Связывать строки таблиц тоже можно через вторую таблицу
    w2 = Women.objects.get(pk=2) 
    h2.wuman = w2 # Присваеваем мужу объект - жену через менеджер
Далее сохраняем, но тут важный момент, так как мы добавляем данные в таблицу женьщин, и сохранять нужно объект женьщин
Хоть мы исвязывали через обект - муж
    w2.save()

Если связать строку в первой таблицы с уже связанной строкой во второй, вылетит ошибка
Ведь связь О-Т-О значит уникальность вторичного ключа
Но мы можем убрать связь строк и после этого можно связывать с ранее занятой строкой из втроой таблицы с другой строкой первой
    w2.husband = None
    w2.save()
    w3.husband = h2
    w3.save()

Конечно же мы можем достучаться до полей второй таблицы через первую
    w1 = Women.objects.get(pk=1)
    w1.husband.name
    w1.husband.age
И даже можем менять так эти значения
    w1.husband.age = 30
    w1.husband.save()
Питту снова 30 лет, теперь он выглядит на свой возраст



ПОГРУЖЕНИЕ В ORM Django



Погружение в ORM Django



УРОК 1 ORM-КОМАНДЫ С КЛАССОМ Q

Когда мы только начинали изучать ОРМ мы внутри методов объектов мы использовали разные услови и иногда их комбинировали
    Women.objects.filter(pk__in=[2,5,7,10], is_published=True) # комбинируем условие pk__in=[2,5,7,10] и is_published=True
При этом комбинация происходила всегда с логическим И

Но у нас есть ещё и логические ИЛИ и НЕ
Как их сделать

Для этого в ОРМ реализован класс Q, благодаря нему мы можем делать все логические операции

Но чтобы им пользоваться нужно импортировать его внутри ОРМ
from django.db.models import Q
Если используем shell_plus, он по дефолту импортируется

Чтобы работать с любым лог. оператором условия внутри методов, нужно обернуть в класс Q - Q(pk__in=[2,5,7,10])
А вместо запятой разделяющий условию нужно поставить спец. символ который и определяет логич. выражение
    & логическое И (приоритет 2);
    | логическое ИЛИ (приоритет 1 – самый низкий);
    ~ логическое НЕ (приоритет 3 – самый высокий). 

Вот как выглядит полная команда
    Women.objects.filter(Q(pk__lt=5) | Q(cat_id=2)) # pk меньше нуля ИЛИ cat_id равен 2

Логическое И тоже можно использовать для класса Q
    Women.objects.filter(Q(pk__lt=5) & Q(cat_id=2))
Как если бы мы это делали и без него
    Women.objects.filter(pk__lt=5, cat_id=2)

Если перед классом поставить знак тильды ~ то к условию добавиться логическа НЕ
    Women.objects.filter(~Q(pk__lt=5) | Q(cat_id=2)) # pk не равно 5 или cat_id равно 2

Q классы можно комбенировать и с условиями без него
    Women.objects.filter(Q(pk__in=[1, 2, 5]) | Q(cat_id=2), title__icontains="ра") 
    # pk__in=[1, 2, 5] ИЛИ cat_id=2 И title__icontains="ра"

Но обычные условия должны идти после классов Q, а не перед ними
Иначе все условия с Q классом не будут отдельными независимыми условия
Они будут находиться внутри одного услови, т.е. в скобках
    Women.objects.filter(title__icontains="ра", Q(pk__in=[1, 2, 5]) | Q(cat_id=2))
    # title__icontains="ра" И ( pk__in=[1, 2, 5] Или cat_id=2 ) - всего два условия
Поэтому лучше сделать так
    Women.objects.filter(Q(title__icontains="ра"), Q(pk__in=[1, 2, 5]) | Q(cat_id=2)) # все условия будут независимыми
А лучше так
    Women.objects.filter(Q(pk__in=[1, 2, 5]) | Q(cat_id=2) & Q(title__icontains="ра"))
потому-что порядок условий важен - он влияет на читаемост и работу SQL запросов,
ведь у логических операций есть свой порядок выполнения, в ОРМ он тот же что и в SQL
сначала выполняется НЕ, затем, И и в последнюю очередь ИЛИ. 



УРОК 2 БОЛЬШЕ МЕТОДОВ ДЛЯ ОРМ!!!

Урок посвещен новым методам в орм для выборки данных

first() - показывает первую запись в таблицы
Women.objects.first()
Не стоит забывать про дефолтную сортировку реализованную в модели классом Meta
Когда мы используем методы для выборки в ОРМ
Мы используем их относительно дефолтной выборки модели, а она реализованна с обратной сортировко,
точнее с сортировко по меньшему значению поля time_create
    class Meta:
        ordering = ['-time_create']
        indexes = [
            models.Index(fields=['-time_create'])
        ]

В таком случае метод first() вернёт нам первое значение относительно сортированной таблицы и все другие методы выборки тоже
Но если мы хотим сделать метод относительно id то можно скомбенировать с функцией сортировки
    Women.objects.order_by("-pk").first()
Или через метод last(), который возвращает последнюю строку
    Women.objects.order_by("pk").last()

earliest() - используется с полями типа данных - datetime, возвращает объект из кверисет с самым меньшим значением datetime
(позднее время), принимае поле с типом datetime по которому и будет искать самою раннюю дату и время
    Women.objects.earliest("time_update")
latest() - обратный метод earliest, ищет самое большее значение datetime (свежая дата), 
    Women.objects.latest("time_update")

get_previous_by_  - возвращает предидущую запись относительно объекта к которому применяется метод
К названию метода нужно дописать имя поля типа datetime, как если бы имя поля было частью названия метода и поставить скобки()
    w = Women.objects.get(pk=2) # сохраняем объект
    w.get_previous_by_time_update() # выбираем следующую более позднюю запись по полю time_update относительно переданной записи
w.get_next_by_ - ну и как же без аналогичного, обратного метода
    .get_next_by_time_update() - возвратит более свежую запись
В эти функции ещё и условия можно запихать, чтобы мы искали запись учитывая эти условия
    w.get_next_by_time_update(pk__gt=3) # вернёт следующую запись, где pk больше трёх

exists() - проверяет есть ли переданный аргумент в применяемому кверисету
в аргументы принимает объект модели, т.е. проверяет наличае строк одной таблицы которые связанны с переданной строкой
показывает True если есть совпадения и False если нет
    c2 = Category.objects.get(pk=2)
    c2.posts.exists() # если что posts это имя менеджера обратной связи для таблицы Women и Category и он как раз возвращает кверисетом все строки с котегорией c2

count() - считает сколько совпадений количество объектов в кверисете
    Women.objects.filter(cat=c2).count()



УРОК 3 КЛАСС F, Value И МЕТОД annotate()

Мы можем передовать в методы в ОРМ разные значения подходящие по логие относительно метода и применяемого объекта
    Women.objects.filter(pk__lte=2) # передали в фильтр и его условие значение 2
И это нормально работает

Но мы не можем передать значением имя поля, чтобы это работало как значение из этого поля
    Women.objects.filter(pk__gt="cat_id") # "cat_id" воспримется как строка и у нас полетит ошибка, потому что сравниваем с pk
Но вообще мы можем так делать.и в этом нам поможет класс F
Сначала его нужно импортировать
    from django.db.models import F
Используя его мы можем просто завернуть "Неподходящее" значение в этот класс и джанга поймет что мы применяем не строку
а значение поля, название которого мы передали в класс F
    Women.objects.filter(pk__gt=F("cat_id")) # так это работает, каждая строка будет сравниваться со своим cat_id

Больше примеров чтобы лучше понять этот класс

Создадим дополнительное поле в модели мужей
    m_count = models.IntegerField(blank=True, default=0) # счетчик женитьб
Мигрируем!

Счетчик по дефолту при создание равен нулю
Го увеличим у всех этот счётчик на один
    Husband.objects.update(m_count=F("m_count")+1)  # в класс F положили не ноль, а значение m_count

Можно увеличить счетчик только для одной записи
    h = Husband.objects.get(pk=1)
    h.m_count = F("m_count") + 1
    h.save()

Метод annotate() - позволяет искуственно создать дополнительное поле, в которое можно передать значение
Значение нужно передать используя класс Value, который тоже надо импортировать
from django.db.models import Value
    lst = Husband.objects.all().annotate(is_married=Value(True)) # ко всем строка таблице Husband добавим дополнительное поле
    с названием is_married и значением True (без Value() не сработает)
Можно прокрутить всю нашу табличук циклом и посмотреть что получилось
    for i, x in enumerate(lst):
        if i == 0:
            print(list(x.__dict__)[1:]) # вот так мы выводим сначала поля
        print(list(x.__dict__.values())[1:]) # потом строки
Получается как-то так
    ['id', 'name', 'age', 'm_count', 'is_married'] # Видим в конце новое поле is_married
    [1, 'Брэд Питт', 30, 4, True]  # И у всех строк в этом поле значение True
    [2, 'Том Акерли', 31, 1, True]
    [3, 'Дэниэл Модер', 54, 1, True]
    [4, 'Кук Марони', 37, 1, True]
    [5, 'Сергей Балакирев', 101, 1, True] 

В класс Value можно вставлять python выражения 
    lst = Husband.objects.all().annotate(is_married=Value(2 + 5)) # у всех полей будет значение 7
    lst = Husband.objects.all().annotate(is_married=Value("hi "*3)) # у всех полей будет значение hihihi
Но значени поля по названию мы передать не можем
    lst = Husband.objects.all().annotate(is_married=Value("m_count"*3)) # будет m_countm_countm_count
Но снова можно воспользоваться классом F, и кстати используя класс F, нам уже не нужен класс Value
    lst = Husband.objects.all().annotate(is_married=F("m_count"))
    lst = Husband.objects.all().annotate(work_age=F("age") - 20) # возраст минус 20
Внутри annotate() можно создавать сразу несколько полей и присваивать им значения, перечисляя их чере запятую
    lst = Husband.objects.all().annotate(work_age=F("age") - 20, salary=F("age") * 1.10) # создаём два поля work_age и salary
    со значениями F("age") - 20 и F("age") * 1.10
Ну и конечно можно использовать в одном выражении сразу несколько полей
    lst = Husband.objects.all().annotate(salary=F("age") * 1.10 - F("m_count") * 5)



УРОК 4 АГРЕГИРУЮЩИЕ ФУНКЦИИ Count, Sum, Avg, Max, Min. МЕТОД values()

С count мы уже знакомы, он вычисляет количество записей в кверисете
    Women.objects.count()

count и есть агрегирующая функция, агрегирующая функция это функция которая проходит по всем переданным полям и возвращает результат в одном значение, а не для каждого поля

Больше агрегирующих функций и информации о них в документации
https://docs.djangoproject.com/en/4.2/ref/models/querysets/#aggregation-functions

Агрегирующая функция, она и в SQL есть, и как раз-таки ORM ничего не придумывает, она просто вызывает такюже функцию внутри sql
а нам возвращает результат её работы

Добавим значение возраста мужьям для демонстрации работы других функций - 25 и 40 лет

Другие функции нужно будет импортировать
    from django.db.models import Count, Sum, Avg, Max, Min
Все эти функции реализованны классами, но работают как и все агрегирующие функции
Вот только они будут работать внутри другой функции aggregate
Она и вызывает одноименную функцию внутри SQL, и возвращает словарь с выводом этой функции
Min - вычисляет минимальное значени переданного поля
    Husband.objects.aggregate(Min("age")) # вычисли минимальный возраст у мужей
в aggregate можно вставить сразу две агрегатные функции и в возвращаемом словаре будут два ключа со значениями
Max - вычисляет максимальное значение переданного поля
    Husband.objects.aggregate(Min("age"), Max("age")) # вычисли минимальное и максимальное значени
    {'age__min': 25, 'age__max': 40} # вывод

Как видим ключем является название функции внутри sql запроса
Но мы можем присвоить друго название
    Husband.objects.aggregate(young=Min("age"), old=Max("age"))
    {'young': 25, 'old': 40} 

Внутри aggregate можно проводить вычислительные операции со значением возвращаемых функций
Но в таком случае обязательно указывать имя для первого значения
    Husband.objects.aggregate(res=Sum("age") - Avg("age"))
    {'res': 31.5} 
Avg - вычисляет среднее значение строк в переданном поле
    Women.objects.aggregate(Avg("id")) # среднее значение айдишников в таблице женщин

Функцию aggregate можно комбинировать с другими функциями которые возвращают кверисеты
    Women.objects.filter(pk__gt=2).aggregate(res=Count("cat_id")) # сколько строк в тблице женщин где id больше 2

Метод values() (не путаем с классом)
когда мы делаем запрос, мы запрашиваем все поля, даже если возвращаем значение только с одного
метод values() - позволяет нам указать в выборке только те поля которые нам нужны для вычисления значения
это сокращает select запрос, делает его менее нагруженным как визуально так и для процессора
он принимает название тех полей который мы хотим доставать select запросом
А возвращает коллекцию, с именами этих полей как ключ и значением этих полей как значение
    Women.objects.values("title", "cat_id").get(pk=1)
    {'title': 'Анджелина Джоли', 'cat_id': 1}
Мы также можем брать данные и из связанных полей
    Women.objects.values("title", "cat__name").get(pk=1)
    {'title': 'Анджелина Джоли', 'cat__name': 'Актрисы'}
Если мы передадим в values множество строк, то вернётся список из словорей
    Women.objects.values("title", "cat__name")
Этот список можно крутануть в цикле
    w = Women.objects.values("title", "cat__name")
    for p in w:
        print(p["title"], p["cat__name"])



УРОК 5 ГРУПИРОВКА СТРОК И ПРИМЕНЕНИЕ К НИМ АГРЕГИРУЮЩИЕ ФУНКЦИИ

Как и в SQL функция count счтает количество строк в переданной таблице.
Но если в неё передать значение (поле), функция будет считать количество разных значений этого поля в таблице
В ОРМ это работает тоже.
В SQL для этого необходимо делать групировку строк
Но в ОРМ - кверисет это исть групировка строк
Без функции values() групировка происходит по всем полям, из-за чего в группу входит только одна строка
т.к. у нас почти никогда не бывает полностью одинаковых строк (хотябы из-за того же айдишника)
Но с values() мы получаем только нужные нам поля и они уже могут дублироваться
values() показывает нам все строки, но если применить к ней агрегационную функцию, она воспримет дублирующие строки как сгрупированные.
В этом случае можно воспринимать что values() и есть групировка по полям, просто её вывод раскладывает эту групировку по всем входящим строкам, чисто для лучшего визуального понимания

Для лучшего понимания пример:
Посчитаем сколько строк таблицы женщин входят в разние категории
передадим все строки таблицы women, будем запрашивать только поле cat_id, 
и применим к этому count с переданным полем, неважно каким, главное чтобы значение было во всех строках
    Women.objects.values("cat_id").annotate(Count("id"))
разные значения cat_id и количество строк входящие в эти категории
    <QuerySet [{'cat_id': 1, 'id__count': 3}, {'cat_id': 2, 'id__count': 2}]> # 3 строки входят в первую категорию и 2 во вторую
Не забываем что мы можем задать собственное имя для вывода агр. функции
    Women.objects.values('cat_id').annotate(total=Count('id'))
    <QuerySet [{'cat_id': 1, 'total': 3}, {'cat_id': 2, 'total': 2}]>

Можно передовать в агр. функцию менеджер обратной связи чтобы вычислить агр. функцию для каждой строки в связанной таблице связанной с переданной таблицей (например считать сколько строк связанно с переданной строкой как в примере)
Мы также можем фильтровать подобные запросы
    lst = Category.objects.annotate(total=Count("posts")).filter(total__gt=0) # условие запрещает выводить данные со значением 0
И раскладывать этот кверисет в цикле
    for i, x in enumerate(lst):
     if i == 0:
         print(list(x.__dict__)[1:])
     print(list(x.__dict__.values())[1:])
-------------------------------------
    ['id', 'name', 'slug', 'total']
    [1, 'Актрисы', 'aktrisy', 3]
    [2, 'Певицы', 'pevicy', 2]

Также будет и стаблицей тегов
    lst = TagPost.objects.annotate(total=Count("tags")).filter(total__gt=0)

Используя полученные знания можно изменить функцию вывода тегов в сайтбаре, так чтобы мы видели только те теги с которыми связаны наши женщины
    @register.inclusion_tag('women/list_tags.html')
    def show_all_tags():
        return {"tags": TagPost.objects.annotate(total=Count("tags")).filter(total__gt=0)}


И тоже самое сделаем для категрорий
    @register.inclusion_tag('women/list_categories.html')
    def show_categories(cat_selected_id=0):
        cats = Category.objects.annotate(total=Count("posts")).filter(total__gt=0)
        return {"cats": cats, "cat_selected": cat_selected_id}

В Джанге существует множество агрегационных и вычислительных функций, смотреть можно в документации
https://docs.djangoproject.com/en/4.2/ref/models/database-functions/

Разберём одну из них
Length - это функция len в SQL, она вычисляет длинну строки
также принимает имя поля и работает по аналогии с другими агр функциями
    lst = Husband.objects.annotate(len_name=Length('name')) # посчитай длинну имён в каждой строке
Разложим в цикле и получим
    ['id', 'name', 'age', 'm_count', 'len_name']
    [1, 'Брэд Питт', 30, 4, 9]
    [2, 'Том Акерли', 31, 1, 10]
    [3, 'Дэниэл Модер', 54, 0, 12]
    [4, 'Кук Марони', 37, 1, 10]
    [5, 'Сергей Балакирев', 101, 0, 16] 



УРОК 6 ОПТИМИЗАЦИЯ САЙТА С Django Debug Toolbar

Сайт который мы разрабатываем всю дорогу, в принцапи уже можно считать за полноценный рабочий сайт.
Но хорошо ли работает этот сайт?
И что вообще даст нам оценку его работы?
Обычно работа сайта оценивается по этим критериеям:
    скорость работы приложения;
    нагрузку на СУБД (частоту и сложность запросов);
    корректность возвращаемых пользователю данных. 

А как определить эти характеристики на нашем сайте?
Поможет инструмент под названием Django Debug Toolbar

Погнали его скачивать!
    pip install django-debug-toolbar 

Теперь его нужно подключить к нашиму сайту, инструкция в документации
https://django-debug-toolbar.readthedocs.io/en/latest/installation.html

Но я конечно же её продублирую тут

Открываем setting.py и проверяем что в коллекции INSTALLED_APPS есть эта строка
    "django.contrib.staticfiles",
А если нет копируем её
Также проверяем наличае пути для статических файлов
STATIC_URL = "static/"

INSTALLED_APPS = [
    # ...
    "django.contrib.staticfiles",
    # ...
]

STATIC_URL = "static/"

Проверяем наличае строк в другой коллекции:
TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "APP_DIRS": True,
        # ...
    }
]

Теперь добавляем данные:
в этом же файле в коллекцию INSTALLED_APPS добавляем строку
    "django.contrib.staticfiles",
INSTALLED_APPS = [
    # ...
    "debug_toolbar",
    # ...
]

Тоже самое для коллекции MIDDLEWARE
MIDDLEWARE = [
    # ...
    "debug_toolbar.middleware.DebugToolbarMiddleware",
    # ...
]

создаём новую коллекцию INTERNAL_IPS и добавляем новую строку
INTERNAL_IPS = [
    '127.0.0.1',
]

Переходим в файл urls.py  пакета конфигурации (sitewomen.urls.py) и добавляем следующий маршрут: 
Но сначала нужно сделать необходимый импорт
    from debug_toolbar.toolbar import debug_toolbar_urls

    path("__debug__/", include("debug_toolbar.urls")),

Всё готово!
Теперь на нашем сайте появилась дополнительная панель со множеством вкладок
Перейдя по этим вкладкам мы можем посмотреть разную информацию о нём
Например во вкладке SQL мы можем посмотреть какие SQL запросы выполняются при переходе на данный урл
Переходим, смотрим, и видим что у нас дублируются запросы
SELECT ••• FROM "women_category" WHERE "women_category"."id" = 1 LIMIT 21
4 similar queries. Duplicated 3 times. 
Это не очень хорошо - дублирующиеся запросы тормозят сайт и от них можно избавиться

А запросы эти дублируются потому-то у нас по дефолту реализована "ленивая" загрузка данных когда мы берем данные из бд
т.е. на основной странице сайта у нас есть данные которые мы берем из таблицы, например категории
Но когда мы переходим на какую нибудь категорию, мы также находимся на главной странице, в которой также отображаются категории
Но данные берутся и для главной страницы и для и для адреса категорий, так они и дублируются

Как это исправить?
Мы можем сделать "жадную" загрузку данных, при помощи метода select_related()
C ним мы будем сохранять данные для передачи их другим страницам
Есть две функции для реализации "жадной" загрузки данных
    select_related(key) – «жадная» загрузка связанных данных по внешнему ключу key, который имеет тип ForeignKey;
    prefetch_related(key) – «жадная» загрузка связанных данных по внешнему ключу key, который имеет тип ManyToManyField. 

Функцию нужно применить к данным в коллекции внутри функций пердставления и вставить в них имя поля модели которое является вторичным ключем в таблице

вот как это выглядит во вьюшке index
def index(request):
    data = {
        'title': 'Главная страница',
        'menu': menu,
        'posts': Women.published.all().select_related('cat'),
        'cat_selected': 0,
    }

тоже самое нужно сделать и для представления категорий, и для тегов



АДМИН ПАНЕЛЬ



УРОК 1  ПОДКЛЮЧЕНИЕ АДМИНКИ И РЕГИСТРАЦИЯ МОДЕЛЕЙ
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
Перейдя по по адресу http://127.0.0.1:8000/admin/ мы попадаем в окно автризации
это окно авторизации админ панели - место где мы можем просматривать и управлять сайтом и его данными
Туда как правило могут попасть только владельцы и работники сайта, внутри проекта джанги настраевается доступ для пользователей

В файле setting.py можно изменить значение переменной LANGUAGE_CODE, для установки руского языка в админ панели
LANGUAGE_CODE = 'ru-RU'

Для входа в админку нужен логгин и пароль пользователя, но пока их нет совсем
Поэтому сначала нужно создать суперпользователя
    python manage.py createsuperuser
После введения команды нам потребуется задать логин суперпользователя, емейл и пароль

Залетаем в админку и видим пустые списки групп и пользователей, но не видим наши таблицы
Это потому-что мы их не зарегистрировали в админ панели

Регистрация моделей в админке происходит внутри приложения в файле admin.py
Чтобы зарегать модель сначала нужно её импортировать
    from .models import Women
А регистрация происходит блогодаря классу site из пакета admin и его метода register(), в который мы передаём модель
    admin.site.register(Women)

Смотрим админку и видим таблицу women
На неё можно перейти, увидить её строки и даже перейти на них и узнать все данные по строке
При этом в данных есть кнопка "смотреть на сайте"
Она реализована благодоря тому, что в нашей модели есть метод get_absolute_url(), без него кнопики не было бы

Можно настраивать админку.
Напиример изменить заголовки первого и второго уровня
    admin.site.site_header = "Панель администрирования" # _header изменяет заголовок первого уровня
    admin.site.index_title = "Известные женщины мира" # _title изменяет заголовок второго уровня

Название таблицы (заголовок), её отображение, её колонки тоже можно менять для отображения в админки
Но делается это уже внутри модели
Чтобы поменять отоброжение в классе Meta, нужно задать параметр verbose_name
а для отображения во множественном числе verbose_name_plural
        verbose_name = 'Известные женщины'
        verbose_name_plural = 'Известные женщины'

Для изменения заголовка нужно перейти в файл apps.py внутри приложения, там уже автоматически создан класс WomenConfig
    class WomenConfig(AppConfig):
        default_auto_field = 'django.db.models.BigAutoField'
        name = 'women'
В него нужно добавить параметр verbose_name и передать имя заголовка
    verbose_name = 'Женщины мира'



УРОК 2  НАСТРОЙКА ОТОБРАЖЕНИЯ СПИСКА СТАТЕЙ В АДМИНКЕ

Помимо настройки отображения админки, мы можем настраивать еще и сами таблицы внутри админки

Можно указывать какие поля таблицы мы хотим видеть внутри таблицы
Для этого нужно воспользоваться классом отображения моделей в файле admin.py
Создаём собственный класс отнаследованный от класс admin.ModelAdmin, предварительно зарегестрировав его в нашем регистраторе
    admin.site.register(Women, WomenAdmin)
    class WomenAdmin(admin.ModelAdmin):
И пердадим в класс параметр list_display который определяет какие поля будут отображаться в таблице, он принимает названия полей
Туда же можо передать параметр list_display_links, который отвечает за то какие поля будут являться ссылками на пост
Кстати, нам не обязательно пользоваться регистратором как списко с моделй
Мы можем использовать его как декоратор, и нам нам не нужно будет всегда пополнять коллекцию зарегестрированных моделей
    @admin.register(Women)
    class WomenAdmin(admin.ModelAdmin):
        list_display = ('id', 'title', 'time_create', 'is_published', 'cat')
        list_display_links = ('id', 'title')

Ещё в эту модель можно передать параметр ordering, котороый отвечает за сартировку таблицы для админ панели, он принимает список полей
Сортировка будет работать как в SQL когда мы передаём туда несколько полей
сначала по первому полю, а при совпадении значения по следующим полям, но в самой админки мы можем менять порядок сортировки
    ordering = ['-time_create', 'title']

Мы также можем изменить названия полей для отображения в админки
Но это делается уже в самой модели таблицы model.py
В классе самого поля, можно передать параметр verbose_name= и передать в него строку которая заменит название поля в админке

class Women(models.Model):
    class Status(models.IntegerChoices):
        DRAFT = 0, 'Черновик'
        PUBLISHED = 1, 'Опубликовано'
 
    title = models.CharField(max_length=255, verbose_name="Заголовок")
    slug = models.SlugField(max_length=255, db_index=True, unique=True)
    content = models.TextField(blank=True, verbose_name="Текст статьи")
    time_create = models.DateTimeField(auto_now_add=True, verbose_name="Время создания")
    time_update = models.DateTimeField(auto_now=True, verbose_name="Время изменения")
    is_published = models.BooleanField(choices=Status.choices, default=Status.DRAFT, verbose_name="Статус")
    cat = models.ForeignKey('Category', on_delete=models.PROTECT, related_name='posts', verbose_name="Категории")
    tags = models.ManyToManyField('TagPost', related_name='tags', verbose_name="Тэги")
    husband = models.OneToOneField('Husbands', on_delete=models.SET_NULL, null=True, blank=True, related_name='wuman', verbose_name="Муж")

Зарегестрируем модель категорий, на забываем импортировать её
    @admin.register(Category)
    class CategoryAdmin(admin.ModelAdmin):
        list_display = ('id', 'name')
        list_display_links = ('id', 'name')

Изменим её названия, создав внутри модели класс Meta и названия поля name для админки
    class Meta:
        verbose_name = 'Категория'
        verbose_name_plural = 'Категории'

    name = models.CharField(max_length=100, db_index=True, verbose_name="Категория")


Можно сделать возможность редактировать значение поля в отображении строк таблице, а не только внутри самого поста
Для этого в зарегестрированной модели нужно добавить параметр list_editable и передать в него картеж с полями для изменения
Важно, чтобы эти поля не были ссылками на пост, т.е. не находились list_display_links
    list_editable = ('is_published', )
Конкретно в этом примере мы добавляем возможность изменять публикацю, и после добавленя этой возможности всё работает как надо,
Но данные стали отображаться не корректно
Всё дело в том что поле is_published имеет булевый тип данных, и в нём реализовано выбор данных через класс models.IntegerChoices
Этот класс работает с числами и передаёт в таблицу число, а sql понимает булевое значение относительно числа
А вот админка не понимает как связать число с булевым значением
А класса для выборки булевых значений, в джанге просто не существует. 
но мы можем сами подменять число на бул написав для этого "костыль" преобразования данных в самом поле модели
    choices=tuple(map(lambda x: (bool(x[0]), x[1]), Status.choices))
Вместо старого
    choices=Status.choices
В итоге поле выглядит так
    is_published = models.BooleanField(choices=tuple(map(lambda x: (bool(x[0]), x[1]), Status.choices)), default=Status.DRAFT, verbose_name="Статус")
Миграция не нужна
После этого данные отображаются корректно

Сделаем возможность изменять еще и поле cat(вторичный ключ) 
    list_editable = ('is_published', 'cat')
Теперь в админки можно изменять и его, при этом есть возможность и удалить значение и изменить его и добавить новое
Т.Е. для изменения значения применился другой виджет
Джанго сам умеет определять какой виджет для каких данных нужно подставлять, и у него из коробке есть всё необходимое

Ещё мы можем сделать пагинацию на странице отображения строк таблицы, чтобы не грузить все строки разом, если у нас из много
в регистрационную модель нужно добавить параметр list_per_page и передать в него число, равное колличиству строк в пагинации
    list_per_page = 5



УРОК 3  ПОЛЬЗОВАТЕЛЬСКИЕ ПОЛЯ И ДЕЙСТВИЯ В АДМИНКЕ

Мы можем создавать собственные поля для отображения в админке
Для этого необходимо, в классе регистрации модели прописать метот.
Метод будет принимать, помимо селф, параметр, с произвольным названием, который принимает объект модели, которую будм расширять
А возвращает значение нового поля.
В данном случае, количество символов поля content
    def brief_info(self, women: Women):
        return f"Описание {len(women.content)} символов."

Создали новое поле, теперь его нужно добавить в всписок отображающих полей
    list_display = ('id', 'title', 'time_create', 'is_published', 'cat', 'brief_info')

Поле со значениями появилось, но назвывается оно как наш метод. Изменим это!
Для этого необходимо наш метод обернуть в декоратор @admin.display()
и передать в него аргумент description= са значением нужного нам названия поля
    @admin.display(description="Краткое описание")
    def brief_info(self, women: Women):
        return f"Описание {len(women.content)} символов."

всё четко, теперь сделаем новое поле сортируемым
В этом же декораторе, добавляем ещё один аргумень ordering и передаём в него название поля по которому будем сортировать
В данном случае по полю content 
    @admin.display(description="Краткое описание", ordering='content')
    def brief_info(self, women: Women):
        return f"Описание {len(women.content)} символов."

Сделали, чекаем, но сортировка какая-то неправельная
Всё потому-что она происходит именно по полю content а не по значению нашего поля
поле content имеет текстовый тип данных и сортируется в лексикографическом порядке, а не по количеству символов

Создание пользовательских действий

Если выделить несколько строк таблицы и перейти во вкладку действий
Мы увидем только одно действие - удалить строки
Но мы можем создать собственное действие для строк

Действие реализуется для каждой таблицы, следовательно, в модели регистрации
Реализация проиводистся как метод класса модели,
Он принимает в себя - self, request и queryset – объект QuerySet с выбранными записями
Именно к queryset мы и применяем функции для изменения модели
    def set_published(self, request, queryset):
    queryset.update(is_published=Women.Status.PUBLISHED)

Каждое пользовательское действие с таблицей нужно внести в список actions, предворительно создав его
Это типо список регистрации пользовательских действий для модели

Создали, внесли - всё работает
Но называется действие как и метод
Чтобы изменить название нужно метод обернуть в декоратор @admin.action, у которого тоже есть параметр description
    @admin.action(description="Опубликовать выбранные записи")
    def set_published(self, request, queryset):
        queryset.update(is_published=Women.Status.PUBLISHED)

Eщё мы можем модифицировать наше действие, добавив функционал вывода сообщения при его использовании
Для этого нужно применить метод message_user к объекту класса (self),
а в метод передать request и текстовое сообщении которое хотим передать
В нашем случае мы хотим передать - сколько записей изменено, а метод update, который мы применяем в методе пользовательского действия, как раз возвращает количество изменённых строк.
В таком случае, обернём функционал нашего метода в переменную и используем её вывод в текстовом сообщении
    @admin.action(description="Опубликовать выбранные записи")
    def set_published(self, request, queryset):
        count = queryset.update(is_published=Women.Status.PUBLISHED)
        self.message_user(request, f"Изменено {count} записи(ей).")


Сделаем ещё одно пользовательское действие, которое будет снимать записи с публикации
    @admin.action(description="Снять с публикации выбранные записи")
    def set_draft(self, request, queryset):
        count = queryset.update(is_published=Women.Status.DRAFT)
        self.message_user(request, f"{count} записи(ей) сняты с публикации!", messages.WARNING)
В целом всё понятно, но мы видим что в методе message_user появился дополнительный аргумент - messages.WARNING
Этот аргумент прикрепляет к нашему сообщению значок "восклицательный знак"
по дефолту в сообщение применяется значек "галочка"



УРОК 4 ДОБАВЛЕНИЕ ПОИСКА И ПАНЕЛИ ФИЛТРАЦИИ ДЛЯ МОДЕЛИ В АДМИНКЕ

Мы можем на странице отображения строк таблицы добавить поисковик
Для этого в моделе регистрации нужно создать список search_fields и передать в него все поля по каторым будет произвадиться поиск
    search_fields = ['title']
Поиск ищет совпадение переданной подстраки во всём поле, но он чувствителен к регистру
Можно добавить и несколько полей, тогда поиск будет отрабатывать по всем переданным полям сразу
Но нельзя передать поля содержащие вторичные ключи
потому-что вторичные ключи возвращают не данные, а объект класса модели
Чтобы передать данные, нужно как в ОРМ воспользоваться синтаксисом двух подчеркиваний, а после прописать имя поля связанной таблицы
    search_fields = ['title', 'cat__name']
Люкапами тоже можно пользоваться 
    search_fields = ['title__startswith', 'cat__name'] # __startswith ищет только вначале строки, а не по всему тексту

Настройка панели фильтрации

Ещё мы можем создать панель филтрации в админке нашей таблички
Делается это по аналогии с поиском - необходимо создать список list_filter и добавить в него поля для фильтрации
    list_filter = ['cat__name', 'is_published']

Мы можем создать собственный фильтр
Так и сделаем - создадим фильтр замужних и незамужнх женщин

Реализуется он классом который наследуется из класса admin.SimpleListFilter
Фильтр создаётся не в моделе, он общий, его, по идеи, можно использовать для любой таблице, если логика фильтра позволяет его применять
Следовательно пишем просто в файле models.py
    class MarriedFilter(admin.SimpleListFilter):
Ему нужно задать имя - параметр title
    title = 'Статус женщин'
А также нужно задать параметр - parameter_name - он нужен для образования урл когда мы его применяем
    parameter_name = 'status'
Далее создаём поля фильтра, т.е. выборку (замужем/не замужем)
Для этого нужно сделать метод нашего класса, который будет применять (помимо self) реквест и саму модель
Аргументы нужны только для его работы, в выводе мы сами создаём параметры фильтра
    def lookups(self, request, model_admin):
        return [
            ('married', 'Замужем'),
            ('single', 'Не замужем'),
        ]
Видим два параметра, представленные в виде кортежа с двумя значениями:
1) то-же что и parameter_name - название параметра для урл
2) второе значение уже для нас - название параметра в панели фильтрова

Осталось прописать логику для каждого параметра фильтра
Для этого в нашем классе нужно определить ещё один метод
Он принимает в себя реквест и кверисет, по той же логике, что и в функции определения пользовательского действия
А в теле метода прописываем саму логику фильтра через if, пайтон кодом
    def queryset(self, request, queryset):
        if self.value() == 'married':  # если значени параметра - замужем
            return queryset.filter(husband__isnull=False) # верни все строки у которых поле husband не равно True
        elif self.value() == 'single': # если значени параметра - не замужем
            return queryset.filter(husband__isnull=True) # верни все строки у которых True



УРОК 5 НАСТРОЙКИ ФОРМЫ РЕДАКТИРОВАНИЯ АДМИНКИ

Перейдя на страницу поста (строки таблицы) мы видим все поля таблицы, кроме тех что создаются автоматически
Сдесь мы можем изменять данные поста и сохранять их в таблице
Но если нам не нужны все поля, мы можем сделать так, чтобы внутри поста отображались только нужные нам поля
Для этого в модели регистрации нужно добавить параметр fields 
- это список, который хранит имена полей, которые мы хотим видеть в посте
    fields = ['title', 'slug', 'content', 'cat', 'husband', 'tags']

Есть и обратный параметр exclude - тоже список который хранит названия полей, которые мы не хотим видеть в посте
    exclude = ['tags', 'is_published']

На странице поста можно изменять данные полей, но мы можем сделать так чтобы конкретные поля были неизменяемые,
т.е. доступны только для чтения
Для этого тоже нужно создать параметр readonly_fields и передать в него нужные поля
    readonly_fields = ['slug']

При этом на странице присутствует ещё кнопка добавить запись, т.е. создать новый пост
Если нажать то у нас будет та-же страница поста, но где все записи пустые
Сдесь мы можем заполнить каждую запись и нажать сохранить
Если все поля где нет дефолтного или разрешенного null значения будут заполнены, то пост успешно сохраниться
Причем если какое-то поле у нас недоступно для редоктирования, оно и при создании записи будет недоступно

Но что делать если нам нужно оставить поле недоступным для редоктирования, а заполнять мы его сами не можем?
Существует множество вариантов как это сделать, и для каждого типа данных и условий данных в поле, они могут отличаться
Но всё сводиться к тому чтобы сделать поле автозаполняемым и если со временем и датой мы можем сделать это на уровне бд, то как нам быть с текстовыми и другими типами данных, с которыми так не получиться?
Разберём пару примеров на том-же слаге:


Пример №1 - загавнокодить всё к херам

Мы можем пойти в саму модель и там сделать автозаполнение данных при создании строки
Для этого в самой модели нужно создать нужно определить метод save()
Если что он у нас и так по дефолту определён, но для нашей цели нам нужен свой метод - переопределенный
Он то как раз и отвечает за сохранение данных в бд, а переопределяем мы его, чтобы указать как сохранять поле slug
Слаг мы будем сохранять используя знакомую нам функцию slugify которая преобразует текст в формат slug, а передовать в него будем поле title, т.е. мы будем преобразовывать title в слаг
    def save(self, *args, **kwargs): # вот что он принимает
        self.slug = slugify(self.title , allow_unicode=True) # образовываем слаг
        super().save(*args, **kwargs) # для всего остального используем родительские методи и параметры функции

Вот мы и создали автозаполнение для слага, но это не совсем рабочаяя история
Сам по себе slugify не понимает кирилицу и если она будет в тайтле то всё закрашиться
Но второй аргумент который мы передали понимает кирилицу и позволяет slugify делать слаг, но тоже на кирилице
И из-за этого всё тоже закрашится когда наш слаг полетит в url браузера, потому-что он тоже её не воспринимает

И тут самый мощный инструмент програмиста - кастыли, просит подержать его пиво
Можно создать функцию которая будет посимвольна заменять в переданной строке кирилицу на латиницу
что то типо этого:
    def translit_to_eng(s: str) -> str:
        d = {'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd',
            'е': 'e', 'ё': 'yo', 'ж': 'zh', 'з': 'z', 'и': 'i', 'к': 'k',
            'л': 'l', 'м': 'm', 'н': 'n', 'о': 'o', 'п': 'p', 'р': 'r',
            'с': 's', 'т': 't', 'у': 'u', 'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch',
            'ш': 'sh', 'щ': 'shch', 'ь': '', 'ы': 'y', 'ъ': '', 'э': 'r', 'ю': 'yu', 'я': 'ya'}
 
        return "".join(map(lambda x: d[x] if d.get(x, False) else x, s.lower()))
И применить эту функцию внутри slugify
    def save(self, *args, **kwargs):
        self.slug = slugify(translit_to_eng(self.title) # красотень!
        super().save(*args, **kwargs)

И всё! теперь слаги образуются сами

Пример №2 - способ по лучше

На самом деле автозаполнение механизм автозаполнения (по крайней мере для слага) уже придуман
и преобразование текста в слаг в нём уже реализованно
Но это механизм для админки и само автозаполнение данных происходит тоже только в ней а не на уровне создание записи в бд
Чтобы его использовать нужно в регистрационной модели создать атрибут prepopulated_fields 
в него передаём словарь с ключем - поле для автозаполнения и значением - кортеж с полями по которым производится преобразование данных
    prepopulated_fields = {"slug": ("title",)}
Данные добавляются в поле slug посимвольно при заполнении поля title.
Но для работы поле слаг должен быть доступен для изменния (не находиться в readonly_fields)

Если мы реализуем данный способ, то при заполнении поля title увидим как заполняется и поле slug
Правда бывает что это не работает при редактировании постов. Если вдруг не работает - достаточно стереть всё поле title и начать писать его по новой


Ещё мы можем изменять физуальный формат добавление данных для полей связи таблиц многи ко многим
из каробки нам предоставляется виджет в виде списка в котором нужно протыкать с зажатым CTRL нужные значения
Можно сделать по красивше
Для этого также нужно создать атрибут класса filter_horizontal и передать в список поля, виджет которых мы хотим преобразить
    filter_horizontal = ['tags']
теперь наш виджет для поля tags выглядит как два поле и нужные поля нам нужно перетащить из левого в правый

Еще есть атрибут filter_vertical - это тоже что и filter_horizontal, но поля будут находится по вертикали (сверху-вниз)



Урок 6 НАСТРОЙКА ВНЕШНЕГО ВИДА АДМИНКИ

В админке, как и на самом сайте, в браузере, мы всегда видим html документ
этот документ создаётся автоматически при создании проекта джанги
его местоположение можно посмотреть находясь на нём в панеле Debug Toolbar
но если что они все тут - venv\\lib\\site-packages\\django\\contrib\\admin\\templates\\
и конечно же как и любой html мы можем его изменить
И наша админка будет выглядить так как мы захотим

Сами же файлы которые автоматически создаются джангой не рекомендуется трогать
Лучше просто их скопировать и добавить к себе в папку основного проекта
так мы в уроке и сделали, перенеся файл base_site.html в папку templates, а вней создали папку admin и положили копию туда
При этом нам не нужно прописывать новый нестандартный маршрут, мы уже это сделали когда писали его для base.html нашего сайта
А джанга сначала ищет html именно в нём
он туда и подставиться когда мы попадём в админку

К нашему новому html документу мы можем прикрутить и static файлы
для этого создадим папку static, тоже внутри главной директории проекта, и в ней тоже создадим директорию admin
Уже в ней создадим все директории для статических файло (но нам нужна только css), а в ней сам файл css - admin.css

Мы хотим подключить свои стили, на как?
Залетаем в html сраницу более верхнего уровня - base.html и видим что там, статик файлы передаются в блоке -
{% block extrastyle %}{% endblock %}

создаём в нашем файле этот блок и добавляем в него наши css файлы
{% block extrastyle %}
<link rel="stylesheet" href="{% static 'css/admin/admin.css' %}">
{% endblock %}

ну и конечно не забываем подгрузить этот файл в html (после наследования шаблонов - это важно, иначе назаведётся)
{% load static %}  

Для статик файлов всёже нужно прописывать маршрут в setting.py и для админки нужна отдельная коллекция STATICFILES_DIRS
Создадим её и пропишем маршрут
STATICFILES_DIRS = [
    BASE_DIR / 'static',
]

Всё готово! теперь наши статические фалы успешно передаются в новый html.

Осталось только их заполнить, для этого нам нужно знать какие html теги используются на странице
В нашем фале их нет, ведь в нём только пустые блоки в которые попадаю данные из родительских блоков
Мы можем долго ковырять html документы в родительской директории
А можно просто воспользоваться инспектором в браузере и увидить эти теги и их названия там

Находим имена тегов и вперёд заполнять css документ
В уроки мы заполнили их вот так:
#header, .module caption, #changelist-filter h2 {
    background: #3F4137;
}

div.breadcrumbs {
    background: #6A6E5D;
}



ФОРМЫ



УРОК 1 ФОРМА HTML. GET И POST ЗАПРОСЫ

Форма это страница или участок страницы с полями в которые пользователь добавляет какие-то данные
Например окно авторизации - это форма с полями для заполнения логина и пароля
Человек заполняет эти поля и нажимает на кнопку "отправить"
А данные летят нам на сервер, где в дальнейшем обрабатываются

В джанге бывает два типа формы:
-связанные с моделью
-несвязанные с моделью

Документация по формам для джанго
https://docs.djangoproject.com/en/4.2/#forms

Про обработку будет дальше, а пока коснёмся только html

Создадим странницу сайта где мы добавляем пост
Путь у нас уже прописан
А вот в функции представления у нас стоит заглушка
    def addpage(request):
        return HttpResponse("Добавление статьи")
Исправим это
    def addpage(request):
        return render(request, 'women/addpage.html', {'menu': menu, 'title': 'Добавление статьи'})
Теперь создаём html шаблон который указали во вьюшке
пока с таким наполнением
    {% extends 'base.html' %}
 
    {% block content %}
    <h1>{{title}}</h1>
    Содержимое страницы
    {% endblock %}


конечно же чтобы видеть форму на странице её нужно поместить в html
Вся форма обварачивается в тег <form>
    <form action=""></form>
А внутри тега помещаем теги для поля - тег <input>
Поля бывают разного типа - а-ля текстовые, поля для отметки, для чисел, для паролей и ещё огромное множество
Больше про них можно узнать тут
    https://www.w3schools.com/html/html_forms.asp
Добавим несколько из них на нашу страницу, под тего title просто посмотреть, без отношения к странице
    <form action="">
        <input type="text">
        <input type="checkbox">
        <input type="number">
        <input type="password">
    </form>
Добавили и видим поля для ввода!

Хорошо бы их как-то подписать
Легко! просто перед тегом input нужно поставить тег label и между тегами прописать текст который и будет подписью поля
Еще нужно связать названи с полем
Для этого в открывающем теге label пишем параметр for= и в него передаём строку - название связи
а теге input добавляем параметр id= и в него тоже самое название свзяи
    <label for="id_1">Текст: </label><input type="text" id="id_1">
    <label for="id_2">Отметка: </label><input type="checkbox" id="id_2">
    <label for="id_3">Число: </label><input type="number" id="id_3">
    <label for="id_4">Пароль: </label><input type="password" id="id_4">
Супер! теперь наши поля подписаны

Ещё для полного кайфа можно можно сделать все поля на отдельной строке а не в одну
для этого просто Весь тег поля с подписью обварачиваем в тег <p>
можно просто поставить вначале только открывающий тег или вконце только закрывающий, браузер поймёт
    <label for="id_1">Текст: </label><input type="text" id="id_1"></p>
    <label for="id_2">Отметка: </label><input type="checkbox" id="id_2""></p>
    <label for="id_3">Число: </label><input type="number" id="id_3"></p>
    <label for="id_4">Пароль: </label><input type="password" id="id_4"></p>

Добавим кнопку под полями
    <button type="submit">Отправить</button></p>

Кнопка готова и если на неё нажать в конце url появляется знак вопроса
Это значит что на сервер отправляются какие-то данные, но никаких данных после знака вопроса нет
Потому-что мы не дали дали имена нашим данным для запроса
эти имена берутся из тегов полей и образуются они параметром name= внутри поля
    <label for="id_1">Текст: </label><input type="text" id="id_1" name="field_text"></p>
    <label for="id_2">Отметка: </label><input type="checkbox" id="id_2" name="field_check"></p>
    <label for="id_3">Число: </label><input type="number" id="id_3" name="field_num"></p>
    <label for="id_4">Пароль: </label><input type="password" id="id_4" name="field_psw"></p>

теперь если мы заполним поля формы и отправим их мы увидем в url какие данные летят на серв
    http://127.0.0.1:8000/addpage/?field_text=%D0%B9%D1%86%D1%83&field_check=on&field_num=123&field_psw=123

Эти данные сервер передаёт в джанго и там мы уже можем их обрабатывать
Кстати данные летят в во вьюшку addpage(), и там в режиме отладки мы можем поймать этот запрос и посмотреть и данные и сам запрос
Всё потому-что мы в параметре action тега form ничего не указали, туда можно указать путь и запрос полетит туда, а мы после отправки и сами окажемся на той страниче куда указали путь
    <form action="/"> # переход на страницу index

Теперь понятно что за данные мы видим в урл
Но вообще-то мы не должны из там видеть, но почему тогда видим
Потому-то мы отправляем GET запрос, а данные которые не должны быть в безопасности и скрыты от глаз - передаются post запросом
Чтобы поменять тип запроса в теге form нужно добавить ещё один параметр method и передать в него название типа запроса
    <form action="" method="post">
Теперь данные передаются скрытно

Но если мы сейчас отправим запрос мы словим ошибку
Ошибка из-за отсутствия специального поля CSRF
Это прихоть джанги
Он требует чтобы при отправлении пост запросов у нас мы прикрепляли csrf токен
CSRF позволяет защитить запрос от межсайтовых атак и джанго требует его в целях безопасности
Добавить его очень просто
Нужно внутри формы, перед полями, поставить шаблонный тег csrf_token

    {% block content %}
    <h1>{{title}}</h1>
    <form action="" method="post">
        {% csrf_token %}
        <label for="id_1">Текст: </label><input type="text" id="id_1" name="field_text"></p>
        <label for="id_2">Отметка: </label><input type="checkbox" id="id_2" name="field_check"></p>
        <label for="id_3">Число: </label><input type="number" id="id_3" name="field_num"></p>
        <label for="id_4">Пароль: </label><input type="password" id="id_4" name="field_psw"></p>
        <button type="submit">Отправить</button></p>
    </form>
    {% endblock %}

Теперь данные отпраляются и мы можем посмотреть запрос в отладке, в окне Evaluate Expression



УРОК 2 ФОРМА В ДЖАНГО (БЕЗ СВЯЗИ С МОДЕЛЬЮ)

Мы теперь знаем как выглядит форма в html
Но форму можно прописать и в самой джанге
И передать её в шаблон, используя шаблонный тег

Все формы создаются в файле forms.py, в директории проекта.
Создаём файл women/forms.py

Каждая форма объявляется классом, наследуемый из родительского класса Form, из папекта django.forms, импортируем его пакет
    from django import forms

Подробности о нём в документации
    https://docs.djangoproject.com/en/4.2/ref/forms/api/#django.forms.Form

Теперь можно создавать форму
Нам нужно создать класс отнаследованный от класса Form
Мы создаём форму для добавление постов
    class AddPostForm(forms.Form):

В классе создаём поля для формы, как и поля в модели, где каждое поле - атрибут класса
Атрибуты стоит называть так-же как и поля в модели
т.е. если мы создаём форму для добавления постов (строк в таблицу), 
то поля формы будут полями таблицы и хорошей практикай является называть их одинакого
У полей есть тип данных, который формирует окно для ввода данных и типа данных для ввода в него
Как и в html мы в теге определяли этот тип, так и тут мы тоже его определяем, это реализованно вложенными классами родительского класса

этих классов много, подробности в документации
    https://docs.djangoproject.com/en/4.2/ref/forms/fields/

Многие из классов называются идентично классам построения полей в модели, 
и аргументы, которые они принимают тоже выглядят одникаово, зачастую и нужны они для одного и того-же, 
но сами классы, всёже разные и путать их не стоит
не забываем что они относледованны от разных родительских классов и пакетов
Разберём некоторые из классов для полей
 - CharField - класс образования текстового поля, в него можно задать максимальную длинну текста, и не только,
Например в него можно передать параметр widget, который определяет вид виджета поля, 
а в него ещё один вложенный класс Textarea(), который определяет что это поля для ввода большого текста, без ограничений количества символов
 - SlugField - тоже образует текстовое поле, но проверяет текст на соответствие слаг-формата
 - BooleanField - образует поля для булевого типа данных - та самая кнопка "галочка"
 - ModelChoiceField - образует поля для выбора данных, типа списка с готовыми значениями
эти значения как правило берутся из таблицы, чтобы их передать, нужно в класс передать параметр queryset= 
и в него передать кверисет объектов класса модели. модель конечно же импортируем в файл forms.py

Создаём форму
    class AddPostForm(forms.Form):
        title = forms.CharField(max_length=255)
        slug = forms.SlugField(max_length=255)
        content = forms.CharField(widget=forms.Textarea())  
        is_published = forms.BooleanField() # BooleanField
        cat = forms.ModelChoiceField(queryset=Category.objects.all())
        husband = forms.ModelChoiceField(queryset=Husband.objects.all())

Форма созданна и теперь её нужно передать во вьюшку, и конечно же импортировать
    from .forms import AddPostForm

    def addpage(request):
        form = AddPostForm()
        data = {
            'menu': menu,
            'title': 'Добавление статьи',
            'form': form
        }
        return render(request, 'women/addpage.html', data)

Форма переданна во вьюшку, и теперь нужно передать её в шаблон
Стираем все наши написаные ранее поля и вместо них пишем шаблонный тег {{ form.as_p }}
Вот это дополнение к имени шаблона, определяет как будут разделятся поля _p
В данном случае тегом <p>, но есть и другие варианты разделения полей
    <form action="" method="post">
        {% csrf_token %}
        {{ form.as_p }}
        <button type="submit">Добавить</button>
    </form> 

Подключили, проверяем на сайте, всё работает!

Форма работает и все данные летят к нам пост-запросом, но если какое-то поле не заполнить, то в браузере вылетит ошибка
Потому-что по умолчанию все поля являются обязательными к заполнению
Чтобы это изменить в класс поля фармы нужно добавить параметр required= со значением False
    class AddPostForm(forms.Form):
        title = forms.CharField(max_length=255)
        slug = forms.SlugField(max_length=255)
        content = forms.CharField(widget=forms.Textarea(), required=False)
        is_published = forms.BooleanField(required=False)
        cat = forms.ModelChoiceField(queryset=Category.objects.all())
        husband = forms.ModelChoiceField(queryset=Husband.objects.all(), required=False)

Теперь у нас только 3 поля бязательны к заполнению - title, slug и cat

Обработка данных формы

Сейчас очень важно разобраться что происходит когда мы передаём нашу форму на страницу
Если перейти в режим отладки, а затем перейти на странцу с формой
К нам на сервер как и переходе на обсалютно любую страницу летит гет запрос
в этот момент отрабатывает функция вьюшки, в которую мы передаём нашу форму
т.е. запрос произваодиться в момент когда мы просто заходим на страницу
Если его просмотреть, то мы увидим пустую коллекцию в гет-запросе и в пост-запросе
А раз коллекция пост пустая, значит производится гет запрос
Но когда мы отправляем данные с заполненой формой, мы тоже производим переход страницу благодаря параметру action
Но так как он пустой мы совершаем переход на эту же страницу
А значит функция представления отрабатывает снова и отправляется новый реквест запрос
Но так как с переходом мы ещё и передали данные методом пост, просмотрев этот реквест мы увидим заполненную коллекци пост
Следовательно мы делаем тоже самое, что и при открытии страницы, но в реквесте добавляем данные
значит вся разница только в содержимом реквеста и его методе

Именно благодаря разности запроса, мы можем определить, заполнил ли пользователь поля или нет
а во вьюшке мы можем поставить обычную if проверку на то, какой запрос приходит при отрабатывании вьюшки
И если приходит гет-запрос, передовать ему пустую форму для заполнения
А если это пост-запрос, то в самой вьюшке, можно прописать логику на обрабоку данных запроса и уже дальше с этими данными что-то делать

По поводу данных
Данные которые мы заполняем проверяются самим браузером на корректность
Если мы заполним поля для ввода чисел буквенными символами, браузер сообщит нам об этом и не даст отправить данные
Но он проверяет только на корректность типа данных
А нам порой нужны данные в каком-то более конкретном представлении помимо его типа
А значит их тоже нужно проверить на корректность уже на уровне сервера
проверить данные пост-запроса на его корректность можно и нужно, в обязательном порядке, сделать при его получении
для этого можно применить к запросу функцию джанго is__valid()
таким образом отправляемые пользователем данные проверяются дважды - в браузере и на сервере

Создадим логику обработки во вьюшке
Пока-что не будем заниматься реальной обработкой, просто выведем коллекцию пост из запроса
    def addpage(request):
        if request.method == 'POST': # если реквест - это пост запрос
            form = AddPostForm(request.POST) # Вызываем класс формы с заполненными данными
            if form.is_valid(): # проверяем корректность заполненных данных на уровне сервера
                print(form.cleaned_data) # распечатаем переданные данные, cleaned_data - показывает чистые данные запроса
        else:  # если пришёл гет запрос, отправляем пустую форму
            form = AddPostForm()
        data = {
            'menu': menu,
            'title': 'Добавление статьи',
            'form': form
        }
        return render(request, 'women/addpage.html', data)

Теперь можно заполнить форму на сайте, отправить и увидеть в терминале переданную нами коллекцию данных
    {'title': 'qwre', 'slug': 'qwer', 'content': '', 'is_published': False, 'cat': <Category: Актрисы>, 'husband': None}



УРОК 3 НАСТРОЙКА ОТОБРАЖЕНИЯ ПОЛЕЙ. ДОБАВЛЕНИЕ ДАННЫХ В БД

Ранее мы прописывали подписи для полей, когда писили их в шаблоне
Но сейчас наша форма вся прописана в джанге и тэг подписи к ней не подставить
Но можно классе поля добавить параметр label и передать строку подписи в класс
    title = forms.CharField(max_length=255, label="Заголовок")
    slug = forms.SlugField(max_length=255, label="URL")
    content = forms.CharField(widget=forms.Textarea(), required=False, label="Контент")
    is_published = forms.BooleanField(required=False, label="Статус")
    cat = forms.ModelChoiceField(queryset=Category.objects.all(), label="Категории")
    husband = forms.ModelChoiceField(queryset=Husband.objects.all(), required=False, label="Муж")
Поля подписаны!

Ещё можно модифицировать наши поля - списки выбора данных (cat, husband)
Когда в поле не выброны данные, там отображаются некрасивые черточки, можно поминять их внешний вид на подпись
Для этого в класс ModelChoiceField нужно передать параметр empty_label и добавить туда строку которая будет заменять черточки
    cat = forms.ModelChoiceField(queryset=Category.objects.all(), empty_label="Категория не выбрана", label="Категории")
    husband = forms.ModelChoiceField(queryset=Husband.objects.all(), required=False, empty_label="Не замужем", label="Муж")

И также можно модифицировать поле чекпоинт для is_published, сделав дефолтно поставленную галочку в поле
Добавив в класс BooleanField параметр initial= со значением True
    is_published = forms.BooleanField(required=False, initial=True, label="Статус")


Посмотрим как ещё можно отображать форму и заодно узнаем что из себя представляет шаблонный тег формы

Мы можем сделать представление формы не через шаблонный тег, а как и до этого через обычные теги, но пердеав в них данные нашего шаблонного тега
Например для поля title это будет выглядить так
    <label class="form-label" for="{{ form.title.id_for_label }}">{{form.title.label}}: </label>{{ form.title }}</p>
    <div class="form-error">{{ form.title.errors }}</div>
 - class="form-label" - статическое отображение поля
 - {{ form.title.id_for_label }} - название связи с данными поля
 - {{form.title.label}} - подпись
 - {{ form.title }} - само поле для данных
 - form.title.errors - Место для вывода ошибки при валидации данных

 В итоге видим что наш тег form имеет множество данных, т.к. он представляет из себя класс в питоне

 Можно сделать всё тоже самое для каждого поля
    <label class="form-label" for="{{ form.slug.id_for_label }}">{{form.slug.label}}: </label>{{ form.slug }}</p>
    <div class="form-error">{{ form.slug.errors }}</div>
    <label class="form-label" for="{{ form.content.id_for_label }}">{{form.content.label}}: </label>{{ form.content }}</p>
    <div class="form-error">{{ form.content.errors }}</div>
    <label class="form-label" for="{{ form.is_published.id_for_label }}">{{form.is_published.label}}: </label>                 {{ form.is_published }}</p>
    <div class="form-error">{{ form.is_published.errors }}</div>
    <label class="form-label" for="{{ form.cat.id_for_label }}">{{form.cat.label}}: </label>{{ form.cat }}</p>
    <div class="form-error">{{ form.cat.errors }}</div>
    <label class="form-label" for="{{ form.husband.id_for_label }}">{{form.husband.label}}: </label>{{ form.husband }}</p>
    <div class="form-error">{{ form.husband.errors }}</div>

Ещё можно добавить новую строчку в шаблон, выше всех полей
    <div class="form-error">{{ form.non_field_errors }}</div>
Она будет отображать ошибку валидации, не связанную с конкретным поле (серверную)

Проверяем страницу и там точно такая-же форма

Видим, что каждое поле имеет одинаковую форму и понимаем что можно всё это прокрутить циклом, вместо прописывани всех строк
    {% for f in form %}
    <label class="form-label" for="{{ f.id_for_label }}">{{f.label}}: </label>{{ f }}</p>
    <div class="form-error">{{ f.errors }}</div>
    {% endfor %}
Так красивее и короче

В цикле мы крутим данные и они с каждой итерацией меняются, но что делать со статичными переданными данными
например классом из статик файла class="form-label"
Он же будет применяться ко всем данным, но что делать если для конкретных полей, нам нужен другой стриль оформления?
Стиль можно указать в самой модели формы передав в класс уже знакомы параметр widget=
В него мы также передаём класс для отображения поля, например Textarea или TextInput, 
В них передаём параметр attrs=
а уже в него можно передать класс стиля или задать полю какие-либо параметры, например размер поля
Параметры которые мы передаём в модель шаблона, выше по иерархие данных для отображения
и класс стиля не подставиться вместо них в конечном html документе
    title = forms.CharField(max_length=255, label="Заголовок", widget=forms.TextInput(attrs={'class': 'form-input'})) # стиль
    content = forms.CharField(widget=forms.Textarea(attrs={'cols': 50, 'rows': 5}), required=False, label="Контент") # размер

Все эти классы и их параметры можно прочитать и в документации и перейдя по ним в пайчарме
    https://docs.djangoproject.com/en/4.2/ref/forms/fields/

Поменяли настройки полей, чекаем на сайте и убеждаемся в разнице их отображения и тегов в инспекторе

Добавляем данные в бд

До этого во вьюшке мы просто выводили данные в консоль, а теперь будем добавлять данные в бд и действительно создавать пост
Это сделать легко
удаляем строку вывода данных и воспользуемся знакомым способом передачи данных в бд Women.objects.create()
До этого мы выводили колеекцию переданных данных form.cleaned_data, её же и передадим в функцию create(), 
а так как наши поля в форме называются также как и поля в бд, а их названия это ключи в словаре form.cleaned_data, а данные соответствуют данным для полей в таблице
Нам и придумывать не нужно как упаковывать эти данные, просто развернём словарь
    Women.objects.create(**form.cleaned_data)
И сделаем перенаправление на другу страницу используя знакомый redirect()
    return redirect('home')
Важно понимать, что данные после всех проверок валидности проверяются на соответствие ещё и в бд и там можно словить какую нибудь ошибку, а если есть возможность словить ошибку то нужно создать и возможность обработки исключения
В таком случае обернём обработку данных в try/except и пропишем логику в except
    if form.is_valid():
        try:
            Women.objects.create(**form.cleaned_data)
            return redirect('home')
        except:
            form.add_error(None, 'Ошибка добавления поста') # используем метода add_error, с данными и сообщением ошибки

Вот наша полная вьюшка
    def addpage(request):
        if request.method == 'POST':
            form = AddPostForm(request.POST)
            if form.is_valid():
                # print(form.cleaned_data)
                try:
                    Women.objects.create(**form.cleaned_data)
                    return redirect('home')
                except:
                    form.add_error(None, 'Ошибка добавления поста')
        else:
            form = AddPostForm()
        data = {
            'menu': menu,
            'title': 'Добавление статьи',
            'form': form
        }
        return render(request, 'women/addpage.html', data)


Чекаем работает ли, и оно работает!!! пост успешно создался и нас перекинуло на домашнюю страницу

Но что будет если мы добавим ещё одну запись, которая пройдёт валидацию везде, но не пройдёт в бд?
Например добавим запись с повторяющимся слагом
- В таком случаее над полями в форме странице, мы увидим текстовое сообщение Ошибка добавления поста, 
которое мы добавили в блок except
А выведется оно там потому-что передаётся в шаблонном теге
    <div class="form-error">{{ form.non_field_errors }}</div>



УРОК 4 ВАЛИДАЦИЯ ПОЛЕЙ ФОРМЫ. СОЗДАНИЕ СОБСТВЕННОГО ВАЛИДАТОРА

Как мы знаем данные которые мы передаём из формы валидируются - проверяются на корректность
В джанге это реализовано валидатором is_valid()
Но этот валидатор рассматривает общие параметры валидности
А у нас могут быть какие-то собственные правила заполнения полей или какие-то более сложные проверки

Классы в форме имеют больший функционал на проверку валидности чем классы полей
В них уже реализовано множество параметров которые могут осуществлять некотороый проверки данных на уровне браузера
Например можно проверять текст на минимальное количество символов параметром min_length
title = forms.CharField(max_length=255, min_length=5, label="Заголовок", widget=forms.TextInput(attrs={'class': 'form-input'}),

Если мы попрубуем передать в поле title данные не подходящие по переданному параметру, мы увидим в браузере сообщение, сгенерированное джангой с описанием ошибки

Если нам как-то не нравиться это сообщение, мы можем определить своё для каждой проверки
Для этого нужно воспользоваться параметром error_messages
    title = forms.CharField(max_length=255, min_length=5, label="Заголовок",
                            widget=forms.TextInput(attrs={'class': 'form-input'}),
                            error_messages={
                                'min_length': 'Слишком короткий заголовок',
                                'required': 'Без заголовка - никак',
                            })
У каждого класса поля формы, эти параметры могут быть разными

Помимо встроенных проверочных параметров, класса поля формы, в джанге реализованы собственные классы валидаторов
которые подходят для множества классов и функций
А в классах поля формы, мы можем их передать
Но сначала их нужно импортировать
from django.core.validators import MinLengthValidator, MaxLengthValidator
Передать их нужно в специальный параметр validators=[]
    slug = forms.SlugField(max_length=255, label="URL", validators=[
        MinLengthValidator(5),
        MaxLengthValidator(100),
    ])
Мы добавили те-же валидаторы, что и так есть в классе, но их реализация всёже разная

У классов-валидаторов есть свои параметры, например messege= 
который выводит переданную строку вместо сгенерированного ответа об ошибки из джанги
    slug = forms.SlugField(max_length=255, label="URL", validators=[
        MinLengthValidator(5, message="Минимум 5 символов"),
        MaxLengthValidator(100, message="Максимум 100 символов"),
    ])

Да результат тот же что и с параметром, но класс-валидатор более многофункциональный
Например у классов для построения полей модели нет параметра на минимальную строку, зато мы можем также добавить в него этот же класс валидатор, причем в одноимённый параметр с классом поля формы
    slug = models.SlugField(max_length=255, db_index=True, unique=True, validators=[
        MinLengthValidator(5),
        MaxLengthValidator(100),
    ])
Не забываем импортировать


Создание собственного валидатора


Много разных классов-валидоторов предоставляет джанго, 
но всёже невозможно придумать такой валидатор который будет проверять всю возможную логику 

Поэтому если у нас есть какая-то собственная логика валидности данных, которая не реализована в джанговых валидаторах,
остаётся только писать свой собственный класс-валидатор

Мы можем перейти в уже реализованные валидаторы и взять весь код, нужный нам для построения собственного
Например декоратор которым они все обёрнуты
А также посмотреть примерную логику их построения и на основе неё, учитывая наши запросы, создать свой
В целом логика у них не сложная
Построим свой класс-валидатор, который будет проверять текст на то, что в нём только кирилические символы

    # необходимый декоратор (его нужно будет импортировать)
    @deconstructible
        # объявляем класс
        class RussianValidator:
            # колеекция для проверки каждого символа данных на присутсвие в ней
            ALLOWED_CHARS = "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЬЫЪЭЮЯабвгдеёжзийклмнопрстуфхцчшщбыъэюя0123456789- "
            # необходимые данные для реализации класса (не до конца понял зачем они если честно)
            code = 'russian'
         
            # конструктор для проверки что данные не пустые
            def __init__(self, message=None):
                если данные есть то всё чётко, если нет формируем сообщение ошибки
                self.message = message if message else "Должны присутствовать только русские символы, дефис и пробел."
         
            # метод который производит проверку на валидно и выкидывает ошибку если проверка не пройденно
            def __call__(self, value):
                # проверка на то что данные не входят в коллекцию
                if not (set(value) <= set(self.ALLOWED_CHARS)):
                    # генерация исключения реализованная через класс ValidationError (который тоже нужно импортировать)
                    raise ValidationError(self.message, code=self.code, params={"value": value})

И наш новый валидатор конечно-же тоже нужно добавить в коллекцию validators= для нужного поля

Валидатор работает! 
Но всё-же создавать валидатор через отдельный класс, нужно только если мы собираемся использовать его в нескольких местах
Если же он нужен нам конкретно в одной форме, мы можем в классе этой формы реализовать его через функцию и это сильно проще

    def clean_title(self):
        title = self.cleaned_data['title']
        ALLOWED_CHARS = "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЬЫЪЭЮЯабвгдеёжзийклмнопрстуфхцчшщбыъэюя0123456789- "
        if not (set(title) <= set(ALLOWED_CHARS)):
            raise ValidationError("Должны быть только русские символы, дефис и пробел.")
 
        return title

Так тоже работает!



УРОК 5 ФОРМЫ СВЯЗАННЫЕ С МОДЕЛЯМИ

Наша прошлая форма была связанна с моделью, но специально реалезованна через кастыли, которые определяли её как несвязанную
Кастылями были те классы полей которые мы передовали дальше в модель

Реальная же, связанная форма подключается к полям модели на прямую, и из полей делает поля для формы

Как такую создать?

сотрём к херам все наши старания в построение предидущей формы и напишем точно такую-же, но правельную!
создаётся форма всё в том же файле, как и все формы в приложении
Она также реализованна классом, но он наследуется не от Form, а от ModelForm (импортируем) 
    class AddPostForm(forms.ModelForm):
И в нём нужно создать новый класс Meta
В него передаём два параметра
 - model - реализовывает звязь с моделью, принимает саму модель (импорируем модель)
 - fields - принимает все поля, можно передать вот в таком виде '__all__'
     class AddPostForm(forms.ModelForm):
        class Meta:
            model = Women
            fields = '__all__'
Вот и всё бл**ь, форма готова!!! И это не шутка, обновляем страницу и она там правда есть втф
Причем и подписи стоят, которые взяты из классов полей модели, из параметра verbose_name

Осталось только навести марафет в форме:
 - На самом деле в параметр fields, лучше передать все поля списком
fields = ['title', 'slug', 'content', 'is_published', 'cat', 'husband', 'tags']

 - Стили оформления тоже для отдельных тегов тоже слетели. Востановим!
Для этого в классе мета используем параметр widgets, 
в него передаём словарь, где ключ - имя поля а значение, как раз содержимое этого параметра внутри классов полей формы из прошлого варианта формы
    class Meta:
        model = Women
        fields = ['title', 'slug', 'content', 'is_published', 'cat', 'husband', 'tags']
        widgets = {
            'title': forms.TextInput(attrs={'class': 'form-input'}),
            'content': forms.Textarea(attrs={'cols': 60, 'rows': 10}),
        }

 - У нас в поля с выбором данных категории и мужа вернулись черточки, за отсутвие которых отвечал empty_label, исправим!
Для этого, в классе формы, прописываем точно такой параметр-поле, как и был в прошлой таблице с тем же параметром empty_label
Прям один в один, я его из старой формы скопипастил
    class AddPostForm(forms.ModelForm):
        cat = forms.ModelChoiceField(queryset=Category.objects.all(), empty_label="Категория не выбрана", label="Категории")
        husband = forms.ModelChoiceField(queryset=Husband.objects.all(), required=False, empty_label="Не замужем", label="Муж")
     
        class Meta: 
            model = Women
            fields = ['title', 'slug', 'content', 'is_published', 'cat', 'husband', 'tags']
            labels = {'slug': 'URL'}
            widgets = {
                'title': forms.TextInput(attrs={'class': 'form-input'}),
                'content': forms.Textarea(attrs={'cols': 50, 'rows': 5}),
            }
И да в этой форме, можно создавать поля через тот же способ, что в несвязанных таблица, 
просто ещё можно через класс Meta, что намного проще

Вот теперь всё, эта форма ничем не отличается по функционалу от старой.
Вдобавок, в ней появился новый метод save(), он нужен, для сохранения данных в бд
И он делает проще еще и написание логики обработки во вьюшке
Старая логика сохранения
    if request.method == 'POST':
        form = AddPostForm(request.POST)
        if form.is_valid():
            try:
                Women.objects.create(**form.cleaned_data)
                return redirect('home')
            except:
                form.add_error(None, 'Ошибка добавления поста')
    else:
        form = AddPostForm()
Новая логика
    if request.method == 'POST':
        form = AddPostForm(request.POST)
        if form.is_valid():
            form.save()
            return redirect('home')
Мы убрали весь блок try/except

Всё работает и даже при генерации исключения выдаются сообщения, которые генерит джанго в совокупе с моделью. 
эти сообщения выглядят лучше и информативнее стандартных джанговских без связи с моделью

Абсолютно весь функционал повторён, легче и правельнее
Ну кроме валидатора который был прописан отдельно

Для этой формы он бы ничем не отличалься - также реализуется функцие в классе формы
Напишем какой нибудь друг, например аналог max_length(50)

    def clean_title(self):
        title = self.cleaned_data['title']
        if len(title) > 50:
            raise ValidationError('Длина превышает 50 символов')  # он тоже вызывает знакомый класс
 
        return title



УРОК 6 ЗАГРУЗАКА ФАЙЛОВ НА СЕРЕВЕР

Добавление файлов на сервер также реалезованно в форме, где окно для добавление файла это поле формы

Создадим такую форму на странице about.html
Но сначала поясним что в ней к чему
форма определяется также тегом <form> но если в форме мы собираемся передовать фалы, то у тега должен присутствовать обызательный параметр - enctype= со значением "multipart/form-data", именно он отвечает за загрузку файлов
Поле для передачи файлов определяется тегом input и параметров type="file", 
ещё нужно передеать в него параметр - name=, переданное имя будет фигурировать в коллекции данных request.post
Если точнее то в коллекции FILES,  он будет ключем в словаре, по ниму мы и будем забирать файл
В остальном всё понятно
    <form action="" method="post" enctype="multipart/form-data">
        {% csrf_token %}
        <p ><input type="file" name="file_upload"></p>
        <p ><button type="submit">Отправить</button></p>
    </form>

Страница обрабатывается вьюшкой about, значит в ней и нужно реализовывать логику загрузки файла
В джанге есть разные способы сделать это, подробнее о них тут
https://docs.djangoproject.com/en/4.2/topics/http/file-uploads/
Но в основном используют одну из двух джанговых функций read() и chunk()
read() считывает данные целиком и загружает их
chunk() загружает данные по частям
Метод chunk() - самый предпочтительный выбор, потому-что файлы могут быть большими. Его и используем
Прям в документации приведена функция как можно использовать функцию chunk() для сохранения данных
Её же и воспользуемся, сделаю её общей на случай если буду где-то ещё грузить данные
    def handle_uploaded_file(f):
        with open(f"uploads/{f.name}", "wb+") as destination:
            for chunk in f.chunks():
                destination.write(chunk)
Думаю с ней всё понятно

В функции мы прописали путь сохранения файлов uploads/{f.name}, но директории uploads у нас нет. Создаём! (в главной директории)

Теперь нужно во вьюшке прописать логику обработки запроса с использованием новой функции
    def about(request):
        if request.method == "POST":
            handle_uploaded_file(request.FILES['file_upload']) # та самая колекция пост и тот самый ключ
     
        return render(request, 'women/about.html', {'title': 'О сайте', 'menu': menu})

Проверяем, Всё успешно загружается на сервер!

Но это конечно же был гавнокодный вариант. нормальные пацаны юзают классы
Создаём форму через класс, т.к. мы не связаны с моделью наследуемся от Form
Для поля загрузки файлов используется класс FileField()
    class UploadFileForm(forms.Form):
        file = forms.FileField(label="Файл")

Передаём класс формы во вьюху с нормальной логикой обработки запроса
И про валидацию данных не забываем
    def about(request):
        if request.method == "POST":
            form = UploadFileForm(request.POST, request.FILES)
            if form.is_valid():
                handle_uploaded_file(form.cleaned_data['file'])
        else:
            form = UploadFileForm()

        return render(request, 'women/about.html', {'title': 'О сайте', 'menu': menu, 'form': form})

Ну а в шаблон подставляем шаблонный тег формы вместо полей
    {{ form.as_p }}

Всё работает как надо!

Можно сделать так, чтобы файлы были, обязательно типа изображения, а не любого типа как сейчас
Для этого нужно просто использовать другой класс поля формы - ImageField, но для его работы нужно установить пакет pillow
    class UploadFileForm(forms.Form):
        file = forms.ImageField(label="Изображение")


На самом деле, у нас есть косяк в работе сохранения файлов
Дело в том, что если мы сохраним файл с названием который уже присутствует в директории, то старый файл перезапишетья на новый
Потому-что нам нельзя иметь одноимённые имена.
Мы можем нагавнокодить собственный способ создавать уникальные имена, например изменив функцию сохранения
    import uuid

    def handle_uploaded_file(f):
        name = f.name
        ext = ''
     
        if '.' in name:
            ext = name[name.rindex('.'):]
            name = name[:name.rindex('.')]
     
        suffix = str(uuid.uuid4())
        with open(f"uploads/{name}_{suffix}{ext}", "wb+") as destination:
            for chunk in f.chunks():
                destination.write(chunk)
Но в джанге уже реализована эта задача
Но о ней будет дальше



УРОК 7 ЗАГРУЗКА ФАЙЛОВ В МОДЕЛИ

Теперь понятно как загружать файлы на сервер.
Но грузить их просто в никуда так себе идея

Обычно мы сохраняем их в бд. этим и займёмся

Создадим новую модель для для хранения файлов. конечно же в файле моделей
    class UploadFiles(models.Model):
И пропишем ей поле для файлов.
Оно также реализуется классом и у него тоже одинаковое название с классом для формы FileField()
Но это как и впрошлых случаях - разные классы
И у этого, например есть параметр upload_to= в который мы передаём путь к директории, где будут сохраняться файлы на сервере
Кстати директорию создавать не нужно, она создасться автоматически
    class UploadFiles(models.Model):
        file = models.FileField(upload_to='uploads_model')

Мигрируем!

Теперь нужно связать нашу форму с модель
Для этого достаточно во вьюшке где мы сохраняем файл функцией chunk(), передать этот же файл в объект класса и сохранить объект
было так
    handle_uploaded_file(form.cleaned_data['file'])
стало так (НЕ ЗАБЫВАЕМ ИМПОРТ МОДЕЛИ)
    fp = UploadFiles(file=form.cleaned_data['file'])
    fp.save()

Чтобы не создавать директории для файлов в каждом рабочем проекте, мы можем создать одну единую директорию внутри главной директории проекта в которой будет сохраняться все файлы передающийся в проект

чтобы так сделать достаточно в файле setting.py создать коллекцию в которую передадим путь в эту директорию
MEDIA_ROOT = BASE_DIR / 'media'
там и будут создаваться все директории для файлов и сохраняться сами файлы

Теперь можно и присобачить изображение к постам

Добавим поле для фалов в модель с женщинами
    photo = models.ImageField(upload_to="photos/%Y/%m/%d/", default=None, blank=True, null=True, verbose_name="Фото")
путь для сохранения фалов занчит photos/год/месяц/день

Мигрируем!

Теперь в шаблоне добавления поста, в теге form, указываем enctype="multipart/form-data"

А в форме, в коллекцию fields, добавляем новое поле
    fields = ['title', 'slug', 'content', 'photo', 'is_published', 'cat', 'husband', 'tags']

Ну и меняем вьюшку, там нужно только в объект классе забирать кроме коллекции посте еще и файл
    form = AddPostForm(request.POST, request.FILES)

Проверяем, всё гуд!



УРОК 8 ОТОБРАЖЕНИЕ ЗАГРУЖЕННЫХ ИЗОБРАЖЕНИЙ В HTML И АДМИНКЕ

Мы добавили возможность добавлять картинки в бд, внутри сайта
Но они почему-то не отображаются у нас на сайте
Если кликнуть по в иследователе по тегу с картинкой, то увидем, внутри тега url и возврат страницы 404

Перейдём ОРМ
Возьмём объект модели у которого есть фотка (последняя добавленная нами строка)
    w = Women.objects.all()[0]
выберем в объекте класса модели параметр с полем для фото, добавим к этой команде символ точки и потыкаем на Tab
    w.photo. <Tab> <Tab> <Tab>
То увидем все его возможные свойства (классный способ о них узнать)
например, свойство - url
Если вызвать его, то увидим... ну конечно же, его урл
Тот самый урл что мы видим в теге страницы

Так вот причина, по которой наши картинки не отображаются, заключается как раз в том, что сайт ловит не полный путь к файлу
и не может связать файл с переданным путём

Мы установили, что все медиа-файлы будут храниться в одной директории
Но чтобы сайт видел путь к этой директории и там искал, переданный урл
Нужно прописать этот маршурт в настройках setting.py
Создаём переменную для маршрута поиска медиа-файлов MEDIA_URL и передаём туда путь
    MEDIA_URL = '/media/'

И теперь нам нужно передать маршрут для статик файлов
В файле url.py корневой директории, в колеекцию urlpatterns нужно добавить маршрут корневой директории медиа-файлов,
связанный с нашей коллекцией передачи маршрута в url файлы, используя функцию статик
Сложно но че поделать, вот как это выглядит
    if settings.DEBUG:
        urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
settings и static() нужно сначала импортировать
    from sitewomen import settings
    from django.conf.urls.static import static
Путь нужно передать только для режима отладки, не той что с точкой останова, а тот в котором мы всё время находимся,
т.е. пока сайт находится на локальном сервере

Теперь наши фоточки видно на странице поста

Теперь выведем их отображение на странице со списком постов
Для этого просто добавим шаблонный тег photo.url в шаблон
 {% for p in posts %}
    <li><div class="article-panel">
    <p class="first">Категория: {{p.cat.name}}</p>
    <p class="last">Дата: {{p.time_update|date:"d-m-Y H:i:s"}}</p>
        </div>
    <h2>{{p.title}}</h2>
    {% if p.photo %}
       <p ><img class="img-article-left thumb" src="{{p.photo.url}}"></p>
    {% endif %}

Всё четко!
Заходим в админука, а там нет наших фото. Исправим!

Ну во первых, они не добавлены в список отображения таблицы. Добавим!
    fields = ['title', 'slug', 'content', 'photo', 'cat', 'husband', 'tags']
    list_display = ('title', 'photo', 'time_create', 'is_published', 'cat')
А поле brief_info я удалю. (это то поле где мы писали сколько символов в поле контекст)

Теперь поля есть, но вместо фоток - там урл. Исправим!

Чтобы картинка отображалась, нужно создать функцию по аналогию с функцией brief_info
В ней мы будем передовать картинку при помощи функции mark_safe()
В неё передаём тег как строку, а сама она делает строку не экранируемой, чтобы она выглядела именно как тег
    @admin.display(description="Краткое описание", ordering='content')
    def brief_info(self, women: Women):
        return f"Описание {len(women.content)} символов."
---------------
    @admin.display(description="Изображение")
    def post_photo(self, women: Women):
        if women.photo: # если есть фото, возвращаем фото
            return mark_safe(f"<img src='{women.photo.url}' width=50>")
        return "Без фото" # если нет, то вернём текст (это обязательно, чтобы не вылетела ошибка из-за полей без фото)

Ну и теперь нужно добавить нашу функцию в коллекцию отображения полей в таблице админки
    list_display = ('title', 'post_photo', 'time_create', 'is_published', 'cat')

И сделаем отображение внутри записи тоже
    fields = ['title', 'slug', 'content', 'photo', 'post_photo', 'cat', 'husband', 'tags']
    readonly_fields = ['post_photo']



КЛАССЫ ПРЕДСТАВЛЕНИЙ



УРОК 1 ВВЕДЕНИЕ В CBV. КЛАССЫ View И TemplateView

До этого все вьюшки были реализованны в виде функций.
Но конечно же их можно определять ещё и классами
Зачастую, код, таким образом, выглядит понятнее и имеет больший функционал.

В джанге представленно множество классов для определения вьюшки под любую задачу.
Эти классы образуются от трёх основных классов View, TemplateView и RedirectView
От них уже идут множество наследуемых классов, которыми и определяют вьюшки
Подробности о них в документации
    https://docs.djangoproject.com/en/4.2/ref/class-based-views/

Сейчас разберёмся с двумя основными классами View И TemplateView

Пересоздадим вьюшку addpage используя класс и относледуем его от View
Сначала импортируем его 
    from django.views import View

Если перейти на его определения можно увидеть реализацию всех его методов и параметров
В частности метод обработки гет и пост запросов, как раз такие у нас есть на странице
И в этом одно из приемуществ класса, что нам не нужно прописывать логику по отловле и определению запроса
мы просто определяем логику работы нужных нам запросов, а их определение класс берет на себя 

Создадим класс и два метода для разных запросов
    class AddPage(View):
        def get(self, request):
            pass
     
        def post(self, request):
            pass
Методы конечно же принимают сам запрос

Теперь пропишем логику для этих запросов, она та-же что и была в функции
    class AddPage(View):
        def get(self, request):
            form = AddPostForm()
            return render(request, 'women/addpage.html', {'menu': menu, 'title': 'Добавление статьи', 'form': form})
     
        def post(self, request):
            form = AddPostForm(request.POST, request.FILES)
            if form.is_valid():
                form.save()
                return redirect('home')
     
            return render(request, 'women/addpage.html', {'menu': menu, 'title': 'Добавление статьи', 'form': form})

Как видно, это точная копия логики в функции для каждого запроса
Теперь нужно изменить маршрут на странцу, ведь в него мы передовали вьюшку в виде функции, а нужно через класс
Для этого просто вместо функции, вставляем наш класс, к которому применяем метод - as_view(), 
он вызывает вьюшку и связывает её с маршруторм
    path('addpage/', views.AddPage.as_view(), name='add_page'),

Вот и всё теперь странцица открывается новой вьюшкой и её функционал аналогичен старой

Класс TemplateView
TemplateView - служит для обработки шаблонов и передачи результатов пользователю
Т.Е. им мы делаем статичную вьюшку  с передачей шаблона с данными

Сначала импортируем его
    from django.views.generic import TemplateView

Заменим вьюшку главной страницы, на класс 
    class WomenHome(TemplateView):

У этого класса есть параметр template_name, который принимает путь к шаблону 
class WomenHome(TemplateView):
    template_name = 'women/index.html'

В целом это уже рабочая вьюшка, мы только данные не передали, но её уже можно передать в маршрут и страница будет отображаться
    path('', views.WomenHome.as_view(), name='home'),

И да, она отображается, только пустая, без постов и коллекции с сылками на другие страницы сайта (с пустыми блоками в html)

Теперь передадим данные.
В старой вьюшке мы создавали коллекцию с произвольным именем и передовали её в вывод функции
В классе тоже самое, но для этой колекции уже определён параметр extra_context и именно в него нужно передать коллекцию данных
    class WomenHome(TemplateView):
        template_name = 'women/index.html'
        extra_context = {
            'title': 'Главная страница',
            'menu': menu,
            'posts': Women.published.all().select_related('cat'),
            'cat_selected': 0,
        }

Проверяем страницу и все данные отображаются 

У функции as_view() тоже есть такой параметр и нужен он для того-же самого
т.е. мы можем не создавать коллекцию внутри класса, а просто передать её в функцию as_view, в маршруте
    WomenHome.as_view(extra_context={'title': "Главная страница сайта"})
Но если у нас будет переданна коллекция и в классе и в as_view, в шаблон применится коллекция из функции - она выше по иерархии 

Вот так в TemplateView передаются статичные данные
Но данные могут быть и динамическими http://127.0.0.1:8000/category/?cat_id=2, т.е. с выборкой
В таком случае extra_context уже не справиться
Но для этого в классе реализован ментод get_context_data куда мы можем передать и статичные даннные и определить динамические
    def get_context_data(self, **kwargs):  
        context = super().get_context_data(**kwargs) # наследум метод у родителя
        context['title'] = 'Главная страница' # определяем объект коллекции данных и передаём ему дефолтное значение
        context['menu'] = menu
        context['posts'] = Women.published.all().select_related('cat')
        context['cat_selected'] = int(self.request.GET.get('cat_id', 0))
        return context
т.е. мы создали туже статичную коллекцию данных, где каждай переменная - это ключ этой коллекции (указан в квадратных скобках)
а значение переменной - это значение ключа
таким образом мы определяем не статичное? а дефолтное значение данных
Но благодаря методу get_context_data при передачи динамических данных, значение колеекции изменяется

Добавляем, проверяем, всё работает!



УРОК 1 ListView

Мы изучили базовые классы представлений
Но в реальных задачах ими особо не пользуются
А пользуются заранее заготовленными классами предстовлений уже относледованных от них   

Один из низ ListView - он используется специально для отображения пользовательских списков

Для начала импортируем его от туда же что и TemplateView
    from django.views.generic import ListView

Заменим класс представления домашний страницы на ListView:
просто поменяем класс от которого наследуемся
    class WomenHome(ListView):
Но если запустим то словим ошибку
Конечно же потому-что, у него всё-же есть различия с родительским классом

Во первых класс ListView обязательно нужно брать данные из таблицы в бд
Да, он и так их берет, но ему нужно конкретно прописать связь с таблице
Делается при помощи параметра model, в который мы передаём таблицу
    class WomenHome(ListView):
        model = Women

В остальном можно полностью продублировать то же тело класса, что и было в родительском
    class WomenHome(ListView):
        model = Women
        template_name = 'women/index.html'
        extra_context = {
            'title': 'Главная страница',
            'menu': menu,
            'posts': Women.published.all().select_related('cat'),
            'cat_selected': 0,
        }
И страница будет функционировать точно также, но у класса ListView, всё-же больше функционала и он лучше подходит для передования пользовательских списков (строк таблицы)

Например, передача строк (постов) может производится по другому и обычно именно так и делается:
Обратим внимание, что наши посты передаются в коллекции данных в ключе posts, который мы образуем объектом модели.
Но благодаря связи класса вью с моделью наша функция уже и так имеет все строки нашей таблицы 
И хранит она их в параметре object_list
Мы можем убрать из коллекции ключ posts, а в шаблоне, вместо тега posts поставить object_list, никак не определяя его в классе
    {% for p in object_list %} # это
    {% for p in posts %} # вместо этого
И оно будет работать
И мы можем переименовать параметр object_list на другое имя, да хоть на тот-же posts.
Для этого в параметр context_object_name нужно передать желанное имя
    class WomenHome(ListView):
        model = Women
        template_name = 'women/index.html'
        context_object_name = 'posts'

        extra_context = {
            'title': 'Главная страница',
            'menu': menu,
            'cat_selected': 0,
        }
Теперь всё работает и со старым тегом {% for p in posts %}

Но работает не совсем так как до этого
Дело в том, что в ключ пост мы передовали объект модели с фильтром, который передовал только опубликованные посты
    Women.published.all().select_related('cat')
А object_list принимает и выдаёт все строки таблицы и на сайте видно неопубликованные посты. Исправим!

Для этого нужно просто преобразовать выборку данных из таблицы.
Она реализованна методом get_queryset
Определим его сами в нашем классе и туда передадим наш метод выборки - ту же строку что мы передовали в ключ post
При этом нам больше не понадобится параметр model который осуществлял связь с таблице,
Потому-что связь с таблицей уже указана в методе get_queryset

class WomenHome(ListView):
    template_name = 'women/index.html'
    context_object_name = 'posts'
    extra_context = {
        'title': 'Главная страница',
        'menu': menu,
        'cat_selected': 0,
    }

    def get_queryset(self):
        return Women.published.all().select_related('cat')
Проверяем, всё работает! И это уже конечный результат нашей вьюшки

Теперь сделаем вьюшку show_category, этим же классом
В ней у нас динамический урл и параметр extra_context уже не подойдёт
Но какой-то новой информации уже нет, коллекцию определяем get_context_data, а всё остальное по аналогии с прошлым классом

    class WomenCategory(ListView):
        template_name = 'women/index.html'
        context_object_name = 'posts'
     
        def get_context_data(self, *, object_list=None, **kwargs):
            context = super().get_context_data(**kwargs)
            cat = context['posts'][0].cat
            context['title'] = 'Категория - ' + cat.name # переопределили title, но тут всё понятно
            context['menu'] = menu
            context['cat_selected'] = cat.id
            return context 
     
        def get_queryset(self): # cat__slug - поле слаг в Category; self.kwargs['cat_slug'] - имя переменной - конвертора
            return Women.published.filter(cat__slug=self.kwargs['cat_slug']).select_related('cat')

И меняем маршрут
    path('category/<slug:cat_slug>/', WomenCategory.as_view(), name='category'),

Всё работает как надо! 
Но если ввести неправельный урл категории, получим ошибку, а по хорошему должны получить страницу 404 
Чтобы это реализовать достаточно добавить в класс параметр allow_empty и передать в него False
    allow_empty = False

По аналогии сделаем ещё и класс для тегов
    class TagPostList(ListView):
        template_name = 'women/index.html'
        context_object_name = 'posts'
        allow_empty = False

        def get_context_data(self, *, object_list=None, **kwargs):
            context = super().get_context_data(**kwargs)
            tag = TagPost.objects.get(slug=self.kwargs['tag_slug'])
            context['title'] = 'Тег - ' + tag.tag
            context['menu'] = menu
            context['cat_selected'] = None
            return context

        def get_queryset(self):
            return Women.published.filter(tags__slug=self.kwargs['tag_slug']).select_related('cat')
Ну и маршрут конечно.
    path('tag/<slug:tag_slug>/', TagPostList.as_view(), name='tag'),



УРОК 2 DetailView

Класс представления DetailView - используется для отображения отдельных постов (строк таблицы)
Конечно же мы будем менять нашу вьюху show_post

Для функционала страницы, классу, также необходимо связь с модель, тем же параметром model и путь к шаблону template_name
    class ShowPost(DetailView):
        model = Women
        template_name = 'women/post.html'
Кидаем маршрут
    path('post/<slug:post_slug>/', views.ShowPost.as_view(), name='post'),
Для того чтобы-открыть страницу этого хватит, но конечно-же она пуста и всё по тем-же причинам, что и ListView
Да и в целом, классы похожи между собой очень сильно

Итак сначала разберёмся с динамичностью
Класс понимает, что раз это одна строка, то скорее всего страница будет динамичная
И чтобы не придумывать логику для определения динамичности , у него для этого уже есть специальные параметры, в которые достаточно передать только конвертер и он сам поймёт как подставлять его в урл
Причём для каждого типа конвертера, есть свой параметр
У нас конвертер реализован через слаг и для того, чтобы определить динамичный урл, используется параметр slug_url_kwarg
    slug_url_kwarg = 'post_slug'
Если бы конвертер был реализован через айдишник, параметр был бы pk_url_kwarg

Теперь разберёмся с данными
они также автоматически попадают из в аналогичный параметр ListView - object_list, только у него просто object
Но параметр тоже можно переименовать, тем же параметром 
    context_object_name = 'post'

Реализовавывать отображение 404, при передачи неверного динамического адреса, и вовсе не нужно, класс автоматически это делает

Осталось передать динамическую колеекцию
Как и во всех классах вью это делается методом get_context_data
За ним также наследуемся у родителя
а за ним определяем поля, в данном примере ничего нового
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['title'] = context['post']
        context['menu'] = menu
        return context

И всё функционал старой вью полностью реализован

Но на самом деле есть один касяк.
С главной странице мы не можем перейти на неопубликованный пост, так как там их просто нет
Но если вручную ввести в урл слаг неопубликованного поста, то мы сможем туда попасть
И всё это по той-же причине, связь с моделью заберает все строки этой таблицы
Поэтому, нам опять нужно передопределить собственную выборку данных

В ListView это делал метод get_queryset, А здесь для этого реализован метод get_object. (По названию понятно почему)
В остальном смысл похож, но всё-же реализация другая
И там и там мы присобачиваем отфильтрованный объект модели, что мы делали еще в модели Women.published
И да раз мы его используем, параметр model нам больше не нужен
Но там мы доставали всю коллекцию и фильтровали её на то чтобы посты совподали со слагом переданный динамично
Здесь тоже, но раз мы делаем это для одного объекта модели, нужно использовать либо какой-то филтр корый будет возвращать одну страницу и писать ей логику для соответсвия сб и логику на отображение 404
Либо вспомнить про функцию которая делает всё это разом get_object_or_404()
    def get_object(self, queryset=None):
        return get_object_or_404(Women.published, slug=self.kwargs[self.slug_url_kwarg])



УРОК 2 FormView

Класс FormView - предназначен для вью обратки html форм (для страниц с формой)

До этого мы реализовывали такую страницу вьюшкой базового класса
    class AddPage(View):
        def get(self, request):
            form = AddPostForm()
            return render(request, 'women/addpage.html', {'menu': menu, 'title': 'Добавление статьи', 'form': form})

        def post(self, request):
            form = AddPostForm(request.POST, request.FILES)
            if form.is_valid():
                form.save()
                return redirect('home')

            return render(request, 'women/addpage.html', {'menu': menu, 'title': 'Добавление статьи', 'form': form})


Но это было для формата обучения основного класса.

В реальности такие страницы представляются именно классом FormView
И сейчас мы переделаем эту вьюху данным класса
создаём и импортируем класс 
    from django.views.generic.edit import FormView

    class AddPage(FormView):

У этого класса присутствует параметр form_class в который нужно передать класс формы на странице
Причем именно класс, а не его объект
    form_class = AddPostForm

Конечно же нужно пердать путь к html
    template_name = 'women/addpage.html'
А ещё ему нужно указать полный маршрут на страницу перенаправления
Для этого в классе определён параметр success_url
Чтобы не прописывать полный путь можно использовать функцию reverse и в неё передать название маршрута
    success_url = reverse('home')
Но на самом деле, с reverse, класс не сможет определить маршрут 
потому-что классу нужен маршрут определённый сразу в момент формирования класса вью, а реверс формирует его позже
Но у этой функции есть аналог reverse_lazy, который формирует маршрут не в какой-то момент
А когда это необходимо самому фреймворку
Используя именно её, фреймворк сможет получить маршрут и переопределение произайдёт
Именно по этой причине в действительности везде используют именно reverse_lazy, а не reverse
потому-что данная проблема встречается довольно часто и не только в этом классе
    success_url = reverse_lazy('home')

Получается что-то типо такого
    class AddPage(FormView):
        form_class = AddPostForm
        template_name = 'women/addpage.html'
        success_url = reverse_lazy('home')

Теперь наша страница отображается и форма функционирует, но и то и то неполноценно

Проблема с отображением всё та-же - передана не вся коллекция в шаблон. Передадим её
    extra_context = {
        'menu': menu,
        'title': 'Добавление статьи',
    }

А функциональность формы заключается только в том что переданные данные, не сохраняются в бд
Ведь этот процесс реализуется именно в логике вью и нам нужно его явно прописать и здесь
Но приемущество этого класса в том, что нам не нужно определять какой запрос прилетел, это класс берёт на себя
необходимо прописать только метод записи данных
Для этого используется метод класса form_valid
Он должен принимать в себя ссылку на заполненную форму, она реализована у нас в шаблоне под именем form
Внутри класса прописываем сам метод сохранения данных form.save() (ведь наша форма связанна с бд)
И пишем возврат метода - этот же метод, но родительский, с нашей формой
    def form_valid(self, form):
        form.save()
        return super().form_valid(form)

И это всё! Данные сейвятся, всё на своих местах и даже функционал ограничений весь реализован, как раз благодаря связи с классом формы, у который весь этот функцонал прописан, и именно он берет все эти моменты на себя



УРОК 5 CreateView И UpdateView

Помимо того, что у нас есть клас для вьюс формы, в которой мы определяем работу с данными, 
в джанге имются классы для вью с более направленным функционалом формы
форм для сохранения данных CreateView, изменения UpdateView и удаления DeleteView
Поговорим о первых двух

CreateView - если подразумевается, что наша форма только сохраняет данные в бд, то более лучшим вариантом для её вью будет использовать класс CreateView

Наша форма добавления записей как раз используется только для сохранения данных в бд
Снава переопределим эту вьюшку.

Основные параметры для работы ей нужны те-же самые
- связь с формой
- путь к шаблону
- коллекция данных
- путь переадресации
И использует она для этого те-же параметры что и FormView

    class AddPage(CreateView):
        form_class = AddPostForm
        template_name = 'women/addpage.html'
        success_url = reverse_lazy('home')
        extra_context = {
            'menu': menu,
            'title': 'Добавление статьи',
        }

Но в FormView мы прописывали метод для использования данных, а точнее их сохранения в бд, внутри form_valid
Но здесь это уже не требуется, потому-что наш класс итак заточен под сохранение данных и реализацию этого метода он берёт на себя
Т.Е. всё, наш класс готов и он выглядит проще!

И это даже не всё упрощение формы:

Например нам не обязателен, вместо него можно связать класс на прямую с моделью model = Women
И тогда наш класс будет генерить форму на основании модели. Но есть одно но.
Ему нужно будет явно указать какие поля должны отображаться в новой форме, и делается это уже знакомым параметром fields
В него можно перечислить необходимые нам поля 
    fields = ['title', 'slug', 'content', 'is_published', 'cat']
или просто передать все
    fields = '__all__'
Главное что-бы были переданны все поля, которые обязательны к заполнению, иначе мы не сохраним данные
    class AddPage(CreateView):
        model = Women
        fields = '__all__'
        template_name = 'women/addpage.html'
        success_url = reverse_lazy('home')
        extra_context = {
            'menu': menu,
            'title': 'Добавление статьи',
        }
т.е. упрощение заключается в том, что можно не создавать форму, она сама сгенерится автоматически
Правда со всеми минусами автоматической генерации
типа без праметров полей как в форме или подписей полей (подписи будут взяты из verbose_name в модели)
Но если есть форма, то конечно же лучше с ней

Но и на этом мы не закончили
Указывать переодресацию тоже не обязательно
Если она не указана, то переодресация будет проводится по маршруту метода absolut_get_url внутри модели, но он конечно же должен быть в ней реализован.
А в модели этот метод переадресовывает на сам пост который мы создаём
Поэтому если нам не нужен другой маршрут, его можно не прописывать


Класс UpdateView

По аналоги с созданием данных, мы можем представлять страницу с формой для изменения данных при помощи UpdateView

Он работает точно так-же как и CreateView, только данные которые мы пердаём в форму будут изменять выбранную запись
А выборку записи мы определяем по динамическому урл, так мы попадаем на нужную запись
Ну и в форме будет уже заполненные поля с данными, которые совпадают с данными нашей записи
И в этих полях мы можем изменять данные на, те которые нам нужны

В класс тоже нужно передать форму, но у нас этот функционал не реалезован, да и не нужен, и формы нет, и создавать не будем,
Но можно тоже воспользоваться связкой с моделью и перечислением полей

Всё остальное тоже-самое.
И переадресацию тоже можно не указывать, но мы всё равно укажем

class UpdatePage(UpdateView):
    model = Women
    fields = ['title', 'content', 'photo', 'is_published', 'cat']
    template_name = 'women/addpage.html'
    success_url = reverse_lazy('home')
    extra_context = {
        'menu': menu,
        'title': 'Редактирование статьи',
    }

Осталось только маршрут реализовать
    path('edit/<int:pk>/', views.UpdatePage.as_view(), name='edit_page'),
Конвертер реализован через айдишник, но это просто для упрощения прописания урл, а так не важно какой конвертер
Прямой ссылки на сайте нет и не будет, 
поэтому не будем писать логику определеня динамического маршрута, а переходить на страницу будем просто - вручную прописывая урл
    http://127.0.0.1:8000/edit/1/ 

Переходим и видим шаблон с заполненными полями и содержанием равным записи модели Women с id 1
Если их поправить и отрпавить, данные в бд изменятся

Вобщем классы аналогичные и класс DeleteView, тоже такой-же, только удаляет запись
так как нам этот функционал не нужен, его можно уже и не расматривать, а почитать о нём подробности можно тут
    https://docs.djangoproject.com/en/4.2/ref/class-based-views/generic-editing/#deleteview



УРОК 6 Mixins

Если у нас есть множество классов, которые используют какой-то общий функционал или данные, мы всё время дублируем в них один и тот же код.
Но это можно предотвраитить.
Для этого существуют специальные классы, они называются миксины. 
в них хранятся данные и функционал для их развёртки и изменения.
Создав такой класс и поместив в него повторяющий код, мы можем наследовать его в другие классы и уберать из них этот код

В нашем случае, мы в каждый класс передаём коллекцию данных, которая зачастую дублируется extra_context
Создадим класс который будет хранить в себе эту коллекцию и уметь изменять её данные

Данный класс может является общим для всего приложения и является вспомогательным функционалом для работы
Обычно в джанге вспомогательные классы хранятся в файле utils.py, внутри приложения. Создадим его
Создали файл и погнали создавать класс
    class DataMixin:
Внутри класса определим метод который будет образовывать контекст шаблона (коллекцию) по умолчанию идобавим в него возможность передовать именнованные аргументы
Ну и наполним содержимое контекста по умолчанию
    def get_mixin_context(self, context, **kwargs):
        context['menu'] = menu
        context['cat_selected'] = None
        context.update(kwargs)
        return context

В контекс мы передаём коллекцию menu, а в файле её нет, перевезём ей из вью сюда
menu = [{'title': "О сайте", 'url_name': 'about'},
        {'title': "Добавить статью", 'url_name': 'add_page'},
        {'title': "Обратная связь", 'url_name': 'contact'},
        {'title': "Войти", 'url_name': 'login'}
]

Теперь можно использовать класс миксинн как наследуемы класс, и не определять метод с передачей коллекции, либо сокращать его
а разные коллекционные данные можно передовать как параметр

Очень важно наследовать класс миксин первым в очереди, чтобы он не переопределял одноимённые параметры других наследуемых классов

Изменим все наши классы вью при помощи миксин
И изменим функцию get_context_data для вью главной страницы
    def get_context_data(self, *, object_list=None, **kwargs):
        return self.get_mixin_context(super().get_context_data(**kwargs),
                                      title='Главная страница',
                                      cat_selected=0,
                                      )
А коллекцию context_data уберём

тоже самое для ShowPost
    class ShowPost(DataMixin, DetailView):
    ...
     
        def get_context_data(self, **kwargs):
            context = super().get_context_data(**kwargs)
            return self.get_mixin_context(context, title=context['post'])

WomenCategory
    class WomenCategory(DataMixin, ListView):
    ...
     
        def get_context_data(self, **kwargs):
            context = super().get_context_data(**kwargs)
            cat = context['posts'][0].cat
            return self.get_mixin_context(context,
                                          title='Категория - ' + cat.name,
                                          cat_selected=cat.id,
                                          )

TagPostList
    class TagPostList(DataMixin, ListView):
    ...
     
        def get_context_data(self, **kwargs):
            context = super().get_context_data(**kwargs)
            tag = TagsPost.objects.get(slug=self.kwargs['tag_slug'])
            return self.get_mixin_context(context, title='Тег: ' + tag.tag)



У нас ещё есть вью классы формы которые не отображают данные, но им всё равно нужна коллекция
И мы можем, благодаря миксин, убрать коллекцию ещё и у них
Реализовав параметры внутри миксин для статичных значений коллекции
А в клас вью эти данные будем передовать в виде параметров

У нас еже есть статичные данные в миксин - это menu
добавим туда ещё и title и сам метод extra_context
    class DataMixin:
        title_page = None
        extra_context = {}
     
        def __init__(self):
            if self.title_page:
                self.extra_context['title'] = self.title_page
     
            if 'menu' not in self.extra_context:
                self.extra_context['menu'] = menu 

Теперь можно относледовать миксин и во вью форм, после добавить в них параметр title_page,
передать значение title и удалить extra_context
    class AddPage(DataMixin, CreateView):
        model = Women
        fields = ['title', 'slug', 'content', 'is_published', 'cat']
        # form_class = AddPostForm
        template_name = 'women/addpage.html'
        success_url = reverse_lazy('home')
        title_page = 'Добавление статьи'


class UpdatePage(DataMixin, UpdateView):
...
    title_page = 'Редактирование статьи'


Всё рабоатет как надо!



УРОК 7 ПАГИНАЦИЯ

Узнаем как реализовывается пагинация на джанго и добавим её на страницу
Документации по пагенации
https://docs.djangoproject.com/en/4.2/topics/pagination/
https://docs.djangoproject.com/en/4.2/ref/paginator/

В общем в джанге реализован класс Paginator, благодаря которому реализуется пагинация на страницах
прочекаем некоторые его методы в консоле фреймворка
python manage.py

Создадим список для пагинации
    women = ['Анджелина Джоли', 'Дженнифер Лоуренс', 'Джулия Робертс', 'Марго Робби', 'Ума Турман', 'Ариана Гранде', 'Бейонсе', 'Кэтти Перри', 'Рианна', 'Шакира']
Импортируем пагинатор
    from django.core.paginator import Paginator

Так вот чтобы реализовать пагинатор, нужно передать в класс объект, для погинации и количество элементов на спагенированной странице
    p = Paginator(women, 3)


И далее можно применять разные методы для пагинации
    p.count # число элементов в списке
    p.num_pages # число страниц (10:3 = 4 – округление до большего)
    p.page_range # итератор для перебора номеров страниц
    p1 = p.page(1) # получение первой страницы
    p1.object_list  # список элементов текущей страницы
    p1.has_next() # имеется ли следующая страница
    p1.has_previous() # имеется ли предыдущая страница
    p1.has_other_pages() # имеются ли вообще страницы
    p1.next_page_number() # номер следующей страницы
    p1.previous_page_number() # номер предыдущей страницы

Методов сильно больше чем указано здесь, о них о всех можно узнать в документации

Но в целом разобрались

Теперь можно протестить как это реализовывать в реальной странице
Наши страницы сделанны при помощи классов вью, их каснёмся в следующем уроке
А в этом протестим на функциональной вьюшке
Реальных страниц через функцию у нас нет, поэтому затестим на тестовой странице about

Итак, чтобы нам пагинироваться, нам нужны данные которые мы будем пагинировать. Пусть будут объект модели
    contact_list = Women.published.all()
Далее нам нужно добавить пагинатор во вью
    paginator = Paginator(contact_list, 3)

сохраняем текущую страницу с пагинацией для шаблона
    page_number = request.GET.get('page') - её номер берём из гет запроса. в параметре page
    page_obj = paginator.get_page(page_number) - и сохраняем страницу используя номер

Ну и ретарн
    return render(request, 'women/about.html', {'page_obj': page_obj, 'title': 'О сайте'})

Наша сохранённая строница это и есть коллекция данных и страницы в пагинаторе
И конечно же она итерируемая
Через итерацию мы и выведем её содержимое в шаблоне

Уберём всё что было в women/about.html и поставим туда новые тестовые данные
    {% for contact in page_obj %}
    {{ contact }}</p>
    {% endfor %}

Всё работает

Выведем ещё ссылки на страницы
Просто вкинем в шаблон их всех
<nav>
    <ul>
        {% for p in page_obj.paginator.page_range %}
        <li>
            <a href="?page={{ p }}">{{ p }}</a>
        </li>
        {% endfor %}
    </ul>
</nav>

Это конечно супер простой пример, но функционал выполнен



УРОК 8 ПАГИНАЦИЯ С КЛАССОМ ListView

Добавляем пагинацию в классы где она нужна
Начнём с домашней страницы

Вообщем мы знаем что пагинация реализуется классом Paginator и поидеи чтобы реолизовать пагинацию, нам нужно добавить и реализовать работу класса в нашем классе
Но на самом деле этого не требуется
Под капотом у класаа ListView и его подклассов уже встроен пагинатор
И чтобы его применить  достаточно в классе указать параметр paginate_by, а в него передать размер коллекции данных на странице
paginate_by = 3

И всё! реально всё. всё работает
Ссылок на страницы только нет, но это потомучто мы в шаблоне ничего не меняли, но вручную можно переходить по страницам

Работает пагинация конечно же только на главной странице, ведь мы её только там и реализовали
Нам ещё нужно добавить в класс с категориями и тегами
Но мы вспоминаем про миксины и добавляем этот параметр туда
Теперь пагинация есть везде

Осталось только шаблон поменять

Сначала в базовом шаблоне добавим блок для пагинации в самом низу
    {% block navigation %}
    {% endblock %}

все посты крутятся у нас в шаблоне index, а значит этот блок нужно открывать только там. 
Переходим и добавляем его, а в него уже оформляем переход по страничкам
Это просто цикл в котором мы гоняем коллекцию используя класс пагинатор и его методы
    <nav class="list-pages">
        <ul>
            {% for p in paginator.page_range %}
            <li class="page-num">
                <a href="?page={{ p }}">{{ p }}</a>
            </li>
            {% endfor %}
        </ul>
    </nav>

Теперь создадим условие, что если у нас всего одна страница, убрать пагинацию
    {% if page_obj.has_other_pages %}
    <nav class="list-pages">
    ...
    </nav>
    {% endif %}

Теперь сделаем так, чтобы вместо ссылки на текущую страницу, отображалась строка
    <nav class="list-pages">
        <ul>
            {% for p in paginator.page_range %}
                       {% if page_obj.number == p %}
            <li class="page-num page-num-selected">{{ p }}</li>
                       {% else %}
            <li class="page-num">
                <a href="?page={{ p }}">{{ p }}</a>
            </li>
                       {% endif %}
            {% endfor %}
        </ul>
    </nav>

Теперь сделаем так чтобы не отображать все страницы пагинации а только текущую и соседнии две
    {% for p in paginator.page_range %}
               {% if page_obj.number == p %}
    <li class="page-num page-num-selected">{{ p }}</li>
               {% elif p >= page_obj.number|add:-2 and p <= page_obj.number|add:2  %}
    <li class="page-num">
        <a href="?page={{ p }}">{{ p }}</a>
    </li>
               {% endif %}
    {% endfor %}

И добавим кнопки перехода на соседнюю страничку
Кнопка назад (перед циклом)
    {% if page_obj.has_previous %}
    <li class="page-num">
             <a href="?page={{ page_obj.previous_page_number }}">&lt;</a>
    </li>
    {% endif %}
Кнопка вперед (после цикла)
    {% if page_obj.has_next %}
    <li class="page-num">
             <a href="?page={{ page_obj.next_page_number }}">&gt;</a>
    </li>
    {% endif %}


Вот конечный результат
    {% block navigation %}
    {% if page_obj.has_other_pages %}
    <nav class="list-pages">
        <ul>
            {% if page_obj.has_previous %}
            <li class="page-num">
                <a href="?page={{ page_obj.previous_page_number }}">&lt;</a>
            </li>
            {% endif %}

            {% for p in paginator.page_range %}
            {% if page_obj.number == p %}
            <li class="page-num page-num-selected">{{ p }}</li>
            {% elif p >= page_obj.number|add:-2 and p <= page_obj.number|add:2 %}
            <li class="page-num">
                <a href="?page={{ p }}">{{ p }}</a>
            </li>
            {% endif %}
            {% endfor %}

            {% if page_obj.has_next %}
            <li class="page-num">
                <a href="?page={{ page_obj.next_page_number }}">&gt;</a>
            </li>
            {% endif %}

        </ul>
    </nav>
    {% endif %}
    {% endblock %}

















