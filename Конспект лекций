УСТАНОВКА ДЖАНГО, СОЗДАНИЕ ПРОЕКТА, ПРЕДСТАВЛЕНИЯ И МАРШРУТИЗАЦИЯ


Урок 1 УСТАНОВКА ДЖАНГО

для запуска проекта на джанго сначала нам нужно создать репозиторий проекта и в нём поставить виртуальное окружение venv
далее ставим джанго внутри окружения ~ pip install django==4.2.1 
можно посмотреть какие команды доступны в ядре джанго ~ django-admin 
далее создаём сайт на котором будем работать ~ django-admin startproject <имя сайта>
после создания, видим внутри проекта папку с названием сайта и в нём python файлы, включая manage.py
чтобы запустить сервер сайта нужно выполнить команду внутри папки сайта ~ python manage.py runserver 
при обновлении програмного кода, браузер может не подгрузить изменения, тогда нам нужно отключить соединение в терминале и подключиться снова



Урок 2 СОЗДАНИЕ ПРИЛОЖЕНИЯ В ДЖАНГО

сначала напомним что происходит под капотом сайта когда пользователь делает запрос на сайт:
- на сервер приходит запрос и он ищет щаблоны схожие с запросом пользователя
- при нахождении шаблона активируется представление в джанге
- представление это функция или класс в питоне, которые при активации дастаёт необходимые данные из бд и шаблонов html, объединяет их и отрправляет пользователю в виде html страницы

на сайте может быть реализованно множество логических независимых приложений, каждое из них является программой внутри сайта и все эти программы хранятся в нашем проекте джанго. Каждая из них должна быть зарегестрированна (прописана) в settings.py внутри INSTALLED_APPS

приложение создаётся в терминале внутри проекта джанго ~ python manage.py startapp <имя приложения> 



УРОК 3 СОЗДАНИЕ ФУНКЦИЙ-ПРЕДСТАВЛЕНИЙ И ИХ МАРШРУТИЗАЦИЯ 

Как уже говорилось ранее представление это функция или класс которая возвращает данные, как правило, в виде html страницы
Сами представления создаются и хранятся в файле views.py внутри репозитория приложения

Но чтобы эта функция вернулась пользователю её нужно как-то передать. Процесс передачи называется - маршрутизация
Маршрутизация осуществляется при помощи джанговой функции path() из джанговой библиотеки, она принимает "суфикс" урл котороый будет в адресе той страницы на которую мы переходим и функцию (или класс) - представление, которая и возвращает страницую

все маршруты хранятся в переменной urlpatterns как элементы списка, внутри файла urls.py
Такой файл по дефолту есть только в основном приложении, а для созданных приложений его нужно создавать отдельно.
Если мы используем маршрут из созданного приложения, маршрут нужно прописывать urls.py самого приложеия, а в urls.py основного приложения принимать все пути при помощи функции include() ~ path(<первоначальный суфикс>, include('<имя приложения>.urls')),



УРОК 4 ОТЛАДКА ПРОЕКТА В ПАЙЧАРМ

Если подключаться к серверу через терминал, мы теряем возможность его отлаживать, а еще это не очень удобно.
Мы можем подключаться к нему по кнопке (зелёной, что запускает скрипт) в пайчарме.
Для этого возле той самой кнопки, нажимаем на настройки и в окне указываем: название скрипта, рабочую директорию, интерпритатор пайтон, в котором работает проект и команду скрипта (в этом примере runserver)
После настройки можно: подключаться к серверу по кнопке, а не командой в терминале и делать отладку функций. 
А ещё больше не нужно перезапускать сервер при изменение кода



УРОК 5 ДИНАМИЧЕСКИЕ URL И КОНВЕРТЕРЫ

Динамические урл это урл с несколькими раздаелами пути, где последующие разделы, после основного, могут динамически изменятся и тем самым изменять данные, которые возвращаются в ответе сервера.
эти разделы отображаются при написании представлений и маршрутов динамических урл
Для представлений, если оно выполненно в виде функции, подраздел будет дополнительным аргументов функции, который можно использовать в теле или выводе этой функции.
    def categories_by_slug(request, cat_slug):
        return HttpResponse(f"<h1>Статьи по категориям</h1><p >slug:{ cat_slug }</p>")
В маршруте, подраздел отображается как часть пути, но не статичной строкой, а спец. синтаксисом <тип данных:имя аргумента представления>, а называется это - конвертер
    path('cats/<int:cat_id>/', views.categories),



Для динамичных путей можно использовать несколько типов данных:
    str – любая не пустая строка, исключая символ ‘/’;
    int – любое положительное целое число, включая 0;
    slug – слаг, то есть, латиница ASCII таблицы, цифры, символы дефиса и подчеркивания;
    uuid – цифры, малые латинские символы ASCII, дефис;
    path – любая не пустая строка, включая символ ‘/’. 

Но если нам их не хватает, можно определить свой тип данных и воспользоваться регуляркой.
В таком случае путь в маршруте будет указываться функцией re_path(), а регулярка будет прописана в пути
    re_path(r'^archive/(?P<year>[0-9]{4})/', views.archive),
Но это выглядит не очень, поэтому можно поступить намного круче:
Вместо того чтобы того чтобы прописывать конвертер внутри path можно прописать его в отдельном файле converters.py, предворительно создав его внутри нашего приложения.
В этом файле мы будем хранить все наши конвертеры, а реализовывать их можно в классе и это выглядит очень красиво и удобно:
    class FourDigitYearConverter:
        regex = "[0-9]{4}"  # наша регулярочка
     
        def to_python(self, value):
            return int(value)   # функция делает из строки число (я так понимаю для проверки)
     
        def to_url(self, value):
            return "%04d" % value       # возвращает строку обратно, чтобы использовать в path

И теперь мы можем можем использовать этот конвертер в path().
Причем именно в path, а не re_path
Но перед использованием конвертера, его нужно снасала зарегестрировать в файле urls.py, ну и импортировать конечно же
Чтобы зарегестрировать конвертер нужно воспользоваться функцией register_converter(), которую тоже нужно импортировать из django.urls.
В функцию летит имя конвертера и произвольное имя типа данных который он возваращает
    register_converter(converters.FourDigitYearConverter, "year4")
после этого можно использовать конвертер в path и лицезреть красивый код
    path('archive/<year4:year>/', views.archive),

подробности обо всём этом тут:
https://docs.djangoproject.com/en/4.2/topics/http/urls/


Ещё момент про urlpatterns (список наших урлов)
При запросе всегда отработает тот шаблон, в котором, первым, было найдено совпадение запроса. Т.Е. елси запрос может отработать в нескольких маршрутах, отработает, тот что записон в списке раньше остальных (имеет меньший индекс). 



УРОК 6 GET И POST ЗАПРОСЫ, ОБРАБОТКА ИСКЛЮЧЕНИЙ

УРЛ запросы могут содержать дополнительные параметры в виде GET и POST запросов.
http://127.0.0.1:8000/?name=Gagarina&cat=music 
?name=Gagarina&cat=music  - вот эта часть и есть пост запрос.
Эти запросы можно обрабатывать в джанге, например, в самой вьюшке можно словить его ~ request.GET и далее с ним работать
С пост запросом всё идентично ~ request.POST

ОБРАБОТКА ИСКЛЮЧЕНИЙ:
Порой при запросе, запросе пользователь может словить исключение, разберем на примере 404, когда запрос не находит совпадений в маршрутах и не может ничего вернуть
Если самому сделать подобный запрос, джанго выдаст страницу исключения 404 с данными подсказывающие нам об исключение.
Это происходит потомучто в файле setting.py в папке главного приложения есть переменная DEBUG с параметром TRUE.
Если её отключить (поменять на False) при исключении мы будем получать стандартный вывод 404 браузера
Но помимо отключения дебага нам нужно будет еще прописать хост локального сервера в ALLOWED_HOSTS = [], иначе мы не подключимся к нему и получим ошибку
    ALLOWED_HOSTS = ['127.0.0.1']
Вывод исключений браузера не очень удобный и информативный для пользователя
Мы можем написать собственный обработчик исключений и выводить собственный html в подобных случаях
пишем его в urls.py основного приложения ~ handler404 = page_not_found
обработчик это вызов функции page_not_found сама же функция будет находится во вьюшке приложения women
    def page_not_found(request, exception):
        return HttpResponseNotFound('<h1>Страница не найдена</h1>')
функция принимает запрос и ошибку из джанги и возвращает класс HttpResponseNotFound который мы импортируем из django.http
Теперь при ошибки 404 мы выводим собственный html для пользователя.

обрабатывать запросы можно и в самих вьюшках:
    def archive(request, year):
        if year > 2023:
            raise Http404()
        return HttpResponse(f"<h1>Архив по годам</h1><p >{year}</p>")
Здесь по условию мы генерим исключение Http404(). оно импортируется из django.http. при срабатывание этого исключения сработает наш обработчик 404

Обрабатывать можно не только 404 исключение, но и другие, для каждого нужно писать свой обработчик.
Подробнее тут:
https://docs.djangoproject.com/en/4.2/ref/urls/



УРОК 7 GET И POST ЗАПРОСЫ, ОБРАБОТКА ИСКЛЮЧЕНИЙ

При развитии сайта очень часто некоторые страницы переезжают на други урл адреса.
Чтобы не потерять эти страницы, поисковой системе нужно явно указывать что страница переехала.
После того как мы это сделали, переходя по старому адресу сайт перенаправит нас на новый урл а запрос получит ответ 301 или 302
    301 – страница перемещена на другой постоянный URL-адрес;
    302 – страница перемещена временно на другой URL-адрес. 

В джанго переезд можно оформить функцией redirect(), предварительно импортируя её из django.shortcuts
    from django.shortcuts import render, redirect
функцию мы вставляем в return представления и передаём в неё адрес на которое будет переход
    def archive(request, year):
        if year > 2023:
            return redirect('/')
Вместо указания адреса напрямую можно указать имя функции представления return redirect(index)
По дефолту перенаправление происходит с ответом 302, т.е. временно, чтобы сработал ответ 301, в redirect нужно добавить дополнительный аргумент - permanent со значением True
    return redirect(index, permanent=True)
Писать путь напрямую или имя функции, считается хардкодингом.
Помимо этих двух вариантов функция redirect принимает еще и имя маршрута. И это самый лучший вариант в визуальном стили кода.
Но это имя в маршруте должно присутствовать.
Для этого в маршрут передаём еще один параметр name='имя маршрута'
    path('', views.index, name='home'),
    path('cats/<slug:cat_slug>/', views.categories_by_slug, name='cats'),
и после этого в redirect можно передовать это имя
    return redirect('home', permanent=True)
Если же маршрут перенаправления содержит несколько параметров - в redirect эти параметры также нужно указать
    return redirect('cats', 'music')

Маршрут перенаправления можно вычеслить заранее, до функции redirect используя функцию revers, предворительно, импортируя её из django.urls
В revers можно передать имя маршрута и коллекцию дополнительных подрозделов.
А после передаём функцию в redirect
        url_redirect = reverse('cats', args=('sport',))
        return redirect(url_redirect)

Помимо redirect можно использовать классы HttpResponseRedirect и HttpResponsePermanentRedirect
Работает они почти аналогично redirect(). первый вызывает ответ 302, второй 301
Чем пользоваться тоже, особо разницы нет.
Разница в работе заключается в том, что в классы нельзя передовать названия функций представлений, а ещё redirect может сам вычислять маршрут динамически



ШАБЛОНЫ


УРОК 1 ШАБЛОНЫ, render(), render_to_string()

Шаблоны это готовы html страницы.
До этого мы передовали захардкоженную html внутри функций представления. Но так конечно же делать неправильно
Все шаблоны храняться внутри нашего приложения в директории под названием templates.
Внутри этой директории также необходимо создать директорию с названием нашего приложения и уже в ней хранить наши html файлы
Это делается потому-что, чтобы вытащить html документ, мы должны передать его путь.
Джанго не требует передовать весь путь, он подразумевает, что в каждом приложении, у нас есть папка templates и сам будет искать там html.
Вот только джанго будет проходить по всем приложениям и если у нас в разных приложениях будут храниться html с одинаковыми названиями джанго возьмёт первый найденный.
Для этого и создаётся подпапка в templates, так мы указываем более подробный путь, который не будет совпадать с другими приложениями.

Как же передать этот путь во вьюшке?:
Для этого нам понадобиться функция render_to_string(), которую мы импортируем из django.template.loader.
в неё мы и передадим путь к файлу html, а её саму передадим в вывод вьюшки
    def index(request):
        t = render_to_string('women/index.html')
        return HttpResponse(t)
Но можно сократить эти две строки в одну используя функцию render() из django.shortcuts
В неё передаём request и путь к html
    def about(request):
        return render(request, 'women/about.html')

Теперь а самом шаблонизаторе джанго:
Мы можем изменять его настройки в основной директории приложения в файле settings.py
Там есть коллекция TEMPLATES. она хранит в себе такие ключи: BACKEND, DIRS, APP_DIRS, OPTIONS
'BACKEND': 'django.template.backends.django.DjangoTemplates', - в нём прописан стандартный шаблонизатор джанги
'DIRS': [], - в Этой коллекции мы можем хранить дополнительные пути для поиска шаблонов, если это требуется
'APP_DIRS': True, - этот ключ отвечает, за то что джанго понимает что ей нужно искать в папке templates в каждом приложении.
точнее не в каждом приложении а в каждом инсталированном. т.е. находящийся в коллекции INSTALLED_APPS, в этом же файле
    'women.apps.WomenConfig',



УРОК 2 ПЕРЕДАЧА ДАННЫХ (ПЕРЕМЕННЫХ) В ШАБЛОНЫ

Шаблону не обязательно быть статичным. т.е. данные в нём не обязательно должны быть строго вшиты в html.
Мы можем передовать данные из переменных в коде в html страницу.
Для этого нужно поправить сам html документ и в место куда мы хотим хотим поставить вставлять данные прописать {{}}, а внутрь кавычек вписать имя переменной, значение которой будем вставлять. 
вместо этого
    <title>Главная страница</title>
вот так
    <title>{{title}}</title>
А в коде нам нужно создать данные с таким же названием.
Например, создать словарь с ключём title и значением которое мы хотим подставить html
    data = {'title': 'Главная страница'}
Этот словарь можно создать внутри представления страницы в которую мы будем подставлять данные и передать словарь третим аргументом в функцию рендер, или через именнованный аргумент context
    def index(request):
        data = {'title': 'Главная страница'}
        return render(request, 'women/index.html', data)
А можно создать прямо внутри аргумента напрямую
    def about(request):
        return render(request, 'women/about.html', context={'title' : 'О сайте'})

В html может находиться множество данных, которые нужно подставлять из кода, тогда и словарь будет с множеством ключей.
     data = {
        'title': 'Главная страница',
        'menu': menu,
        'float': 28.56,
        'lst': [1, 2, 'abc', True],
        'set': {1, 1, 2, 3, 2, 5},
        'dict': {'key_1': 'value_1', 'key_2': 'value_2'},
        'obj': MyClass(10, 20),
    }
Тип данных может быть любым, но в html выводиться строковое представление переданных данных
Можно передовать даже коллекции, как целиком, так и части этих коллекций.
Но чтобы передать элемент коллекции в html, нужно это указать в самом html.
И делается это не привычным синтаксисом пайтон
    <p >{dict[key_1]}}</p>
а немного измененным
    <p >{{dict.key_1}}</p>
    <p >{{obj.a}}</p>
В одни фигурные скобки, можно засовывать только один элемент. Если мы хотим передать в тег несколько элементов - каждый нужно обернуть в скобки отдельно
    <p >{{ dict.key_1 }} {{ dict.key_2 }}</p>
Если в html есть имя данных которые мы не передали в render, при выводе страницы в браузере мы не получим ошибку.
В таком случае данные будут просто проигнорированны. т.е. на месте данных ничего не будет

Как вытаскивать элементы из списков и кортежей, будет в дальнейших уроках



УРОК 3 ШАБЛОННЫЕ ФИЛЬТРЫ

Шаблонные фильтры это как методы для объектов пайтон, но для данных в html (те что обёрнуты в кавычки {{}})
Фильтров существует огромное множество, у каждого своё предназначение, и свой тип данных для работы
Если в питоне метод присоединяется определённым синтаксисом obj.method
У html свой синтаксис obj|filter
Если в филтьр нужно передать значение - будет так obj|filter:"value", даже числи летят в кавычки

Разбёрем некоторые фильтры:
 - add - прибовляет к числу переданное число
    <p >{{float|add:"50"}}</p> 
float у нас равен 28.56, а на выводе страницы мы видем 78
Это потому что add работает только с целочисленными значениями и если в него передать вещественное число, он преобразует его в целое
 - capfirst - делает первую букву заглавной
 - upper - делает все буквы заглавными
 - lower - делает все буквы маленькими
 - cut - вырезает из строки все переданные символы.
как и в питоне методы можно комбенировать цепочкой obj.method1.method2.... так и тут можно obj|filter1|filter2...
<h1>{{title|cut:" "|cut:"?"}}</h1>
 - default - создаёт дефолтное значение из переданных данных объекту, если мы не подставили этот объект в коде или передали пустое значение
<title>{{main_title|default:"Без заголовка"}}</title>
 - divisibleby - Возвращает true или false если объект кратен переданному числи, как и add преобразует объект в целочисленное значение
 - first - выводит первый элемент коллекции. как раз тот способ доставание элементов из списков и кортежей
 - last - выводит последний элемент коллекции
 - join выводит все элементы коллекции через переданный разделитель
 <p >{{menu|join:" | "}}</p>
 О сайте | Добавить статью | Обратная связь | Войти 
 - length - показывает длинну коллекции или строки. а-ля функция len()
 - slugify - преобразует строку в формат slug
 <p >{{"The Main Page"|slugify}}</p>
 the-main-page

Больше фильтров и подробностей о них можно узнать в документации
https://docs.djangoproject.com/en/4.2/ref/templates/builtins/ 

Фильтры можно использовать не только в html, но и в самом коде
Необходимый фильтр сначала нужно импортировать
    from django.template.defaultfilters import slugify
А позже его можно использовать как функцию в коде
    'dict': {'key_1': 'value_1', 'key_2': 'value_2'},
        'obj': MyClass(10, 20),
        'url': slugify("The main page"),  # вот он
В html у нас будет просто обычный тег с переданными данными в него, без каких либо фильтров
    <p >{{url}}</p>
Но на странице будет отображаться отфильтрованные данные, аналогичные  <p >{{"The Main Page"|slugify}}</p>



УРОК 3 ТЕГИ ШАБЛОНОВ for И if

Внутри шаблона можно использовать цикл for и проверку if как в питоне, но с немного отличающимся синтаксисом.
И цикл и проверка являются шаблонными тегами, но не стандартными html которые определяют в каком виде выводить данные, а специальными тегами, которые определяют как эти данные выводить.
Такие теги не видно при просмотре страницы в браузере и они пишуться с отличающимся синтаксисом.
    {% <название тега> [параметры] %} 
Для работы мы создали коллекцию в файле представления, а-ля как если бы это было бд
    data_db = [
        {'id': 1, 'title': 'Анджелина Джоли', 'content': 'Биография Анджелины Джоли', 'is_published': True},
        {'id': 2, 'title': 'Марго Робби', 'content': 'Биография Марго Робби', 'is_published': False},
        {'id': 3, 'title': 'Джулия Робертс', 'content': 'Биография Джулия Робертс', 'is_published': True},
    ]
И добавили коллекцию в функцию представления
    def index(request):
        data = {
            'title': 'Главная страница',
            'menu': menu,
            'posts': data_db,
        }
 
        return render(request, 'women/index.html', context=data)

Так вот эти данные мы можем крутить в цикле внутри html и почерёдно выводить их на странице
Вот так это выглядит в шаблоне:
<!DOCTYPE html>
<html>
<head>
         <title>{{ title }}</title>
</head>
<body>
<p >{{ menu|join:" | " }}</p>
<h1>{{ title }}</h1>
 
<ul>
         {% for p in posts %}
         <li>
                   <h2>{{ p.title }}</h2>
                   <p >{{ p.content }}</p>
                   <hr>
         </li>
         {% endfor %}
</ul>
 
</body>
</html>
Мы видим что цикл обёрнут в тег {% %}, но сам цикл пишется точно с таким же синтаксисом как в питоне
После этого идёт тело цикла. в нём создаётся html теги шаблоана, а в них другие вложенные теги, в который мы передаём элементы коллекции, и в конце тег разделитель <hr>
Ещё одно отличае от питона - теги шаблона должны закрываться {% endfor %} для for и {% endif %} для if

И ещё одно отличае:
В отличае от питона, когда мы создаём цикл в шаблоне джанго, у нас под капотом создаётся переменная forloop
forloop напрямую связан с колекцие которую мы прокручиваем и через него, используя методы этой переменной, можно выяснить какая на данный момент происходит итерация и не только.
У forloop множество методов, подробнее тут
https://docs.djangoproject.com/en/4.2/ref/templates/builtins/#for

Нам нужно убрать тег разделитель после последней итерации.
Можно воспользоваться методом forloop.last - он выводит true если это последняя итерация
И сделать это можно проверкой if внутри цикла.
     {% for p in posts %}
     <li>
       <h2>{{p.title}}</h2>
       <p >{{p.content}}</p>
       {% if not forloop.last %}
       <hr>
       {% endif %}
     </li>
Шаблонный тег прописывается в те-же скобки что и for {% if not forloop.last %} и также закрывается, как и for {% endif %}
И точно также сама проверка if пишется полностю питоновским синтаксисом
if not forloop.last - если не последняя итерация
<hr> - ставь разделитель
У тега if есть все те-же конструкции if, elif, else, что и в питоне, каждую из них по аналогии нужно укутывать в скобки, но закрывать нужно только if

Еще в задание требоволось выложить только те строки из бд, в которой колонка is_published имела значение True
Для этого тоже используем if и конечный цикл у нас получается таким:
<ul>
         {% for p in posts %}
         {% if p.is_published %}
         <li>
                   <h2>{{p.title}}</h2>
                   <p >{{p.content}}</p>
                   {% if not forloop.last %}
                   <hr>
                   {% endif %}
         </li>
         {% endif %}
         {% endfor %}
</ul>



УРОК 4 ШАБЛОННЫЙ ТЕГ url

Мы знаем что в html существуют ссылки - тек <a>
<a href="URL-адрес страницы">Название ссылки</a> 

Мы можем брать адреса этих ссылок из кода в джанго-приложение, вместо того чтобы хардкодить их напрямую в теге
Для этого используется шаблонный тег url
Вот его синтаксис ~ {% url 'название маршрута' параметр1 параметр2 %}
Мы видим как шаблонный тег заковывается в кавычки {% %}, далее само название тега - url, 
после идёт название маршрута, это то самое название из маршрута в нашем коде - параметр name= в функции path(), в коллекции маршрутов
А далее идут параметры этого маршрута, т.е. дополнительные динамические подразделы url

Для примера создадим маршрут для нашей коллекции data_db, который будет передовать страницу каждого элемента колекции
    path('post/<int:post_id>/', views.show_post, name='post'),
Ну и конечно же нужно создать функцию представления этой страницы
def show_post(request, post_id):
    return HttpResponse(f"Отображение статьи с id = {post_id}")
Получится динамичный урл, подраздел которого будет привязан к id строки нашего бд

И так у нас есть новая страница в проекте и мы можем добавить ссылку на неё в основной странице нашего сайта, где перечисляются данный data_bd
         {% for p in posts %}
         {% if p.is_published %}
         <li>
             <h2>{{p.title}}</h2>
             <p >{{p.content}}</p>
             <p ><a href="{% url 'post' p.id %}">Читать пост</a></p>  # вот она
                {% if not forloop.last %}
                   <hr>
                {% endif %}
         </li>
Как видим в ссылку мы вставили именно шаблонный тег url, который передали имя маршрута 'post' и параметр маршрута p.id

По уроку далее мы добавили новые маршруты для нашего списка menu, а каждый элемент этого списка сделали словарём с названием маршрута и визуальной частью ссылки для тега <a>, чем и являлись ранее элементы списка menu.
для каждого маршрута, естественно создали представление.
А на главной странице была добавленна ссылка на эту же страницу.
    path('addpage/', views.addpage, name='add_page'),
    path('contact/', views.contact, name='contact'),
    path('login/', views.login, name='login'),


    menu = [{'title': "О сайте", 'url_name': 'about'},
            {'title': "Добавить статью", 'url_name': 'add_page'},
            {'title': "Обратная связь", 'url_name': 'contact'},
            {'title': "Войти", 'url_name': 'login'}
    ]


    def addpage(request):
        return HttpResponse("Добавление статьи")


    def contact(request):
        return HttpResponse("Обратная связь")


    def login(request):
        return HttpResponse("Авторизация")

Теперь можно отобразить коллекцию menu и в html как ссылки на эти маршруты:
<ul>
<li><a href="{% url 'home' %}">Главная</a></li>     # добавляем ссылку на главную страницу
{% for m in menu %}                                 # прокручиваем коллекцию menu
{% if not forloop.last %}<li>{% else %}<li class="last">{% endif %}   # для последнего тега <li> добавили class="last", чтобы в будущем подкрутить стиль
         <a href="{% url m.url_name %}">{{m.title}}</a>   # а вот и тег url, в который передаём имя маршрута, а в тег <a> передаём название страницы
</li>
{% endfor %}
</ul>


Шаблонный тег url можно сравнить с функцией reverse() в джанге
reverse('post', args=(11, )) - reverse принимает имя маршрута и его аргументы, а потом склеивает их в единый url
{% url 'post' 11 %}          - шаблонный тег url принимает тоже самое и делает тоже самое
Именно так и рекомендуется воспринимать шаблонный тег url



УРОК 5 НАСЛЕДОВАНИЕ ШАБЛОНОВ. ШАБЛОННЫЕ ТЕГИ extends, block, include

Код в шаблоне на многих страницах может повторяться, и это не очень правильно и удобночитаемо
поэтому мы можем создать базовый шаблон, в котором будет находиться html код повторяющийся в большинстве страниц
Такие шаблоны нужно хранить в основной директории проекта, для них также создаётся ещё одна директория templates и уже в ней лежать шаблоны
и уже в ней лежат шаблоны.
Важно знать что шаблонизатор не просматривает шаблоны в корневой папке проекта и этот путь нужно прописать в DIRS, в коллекции TEMPLATES setting.py
    BASE_DIR / 'templates'   # BASE_DIR - это как раз путь к корневой папке
Создали директорию, указали путь, а теперь создаём там базовый шаблон который будет содержать в себе весь повторяющий html код каждой страницы
Теперь в уже существующих html документах можно стереть весь этот повторяющийся код и прописать шаблонный тег extends
    {% extends 'base.html' %} вместо этого шаблонного тега подставиться весь html код из переданного в него файла html

Но что делать с тем кодом который является эксклюзивным для наследованной html страницы?:
В бозовом html мы можем выделить место в коде, куда мы будем вставлять какие-то свои правки в html при помощи шаблонного тега block
    {% block content %} {% endblock %}  # параметр тега - это его произвольное название
И уже в нужной нам странице, в произвольном месте нужно создать такойже блок, обязательно, с тем же названием и внутри этого блока поместить наш код
{% block content %}
<h1>{{ title }}</h1>
{% endblock %}

Для наглядности вот как выглядит базовый html:
<!DOCTYPE html>
<html>
<head>
         <title>{{ title }}</title>
</head>
<body>
<ul>
<li><a href="{% url 'home' %}">Главная</a></li>
{% for m in menu %}
{% if not forloop.last %}<li>{% else %}<li class="last">{% endif %}
         <a href="{% url m.url_name %}">{{m.title}}</a>
</li>
{% endfor %}
</ul>
{% block content %} {% endblock %}

</body>
</html>

А вот так страница about:
{% extends 'base.html' %}
{% block content %}
<h1>{{ title }}</h1>
{% endblock %}

тоесть страница about будет выглядит точно так же как страница base но внутри тега block у неё будет содержимое тега block страницы about
Тегов block может быть множество на странице, у каждого должно быть собственное имя, чтобы мы могли сами решать в какой блок нам ложить информацию

Для улучшения проекта сделаем тоже самое и для страницы index
А далее добавим на страницу ещё одну строку с категориями женщин вначале и в конце списка
<nav>
         <a href="#">Актрисы</a> |
         <a href="#">Певицы</a> |
         <a href="#">Спортсменки</a>
</nav>

Теперь у нас есть повторяющийся тег <nav> в одном документе html
И подобные повторения, также можно предотвратить благодаря шаблонному тегу include
Мы можем хранить подобные куски кода html в отдельных html документах.
Создадим специальную директорию для подобных фалов, например такую
women/templates/women/includes
Создадим там html документ и сохраним в него повторяющий тег nav для страницы about
А на самой странице about вместо этого тега, вызовим шаблонный тег include в каждом месте где есть этот шаблон
    {% include 'women/includes/nav.html' %}   # он работает по аналогии тегу extends - тоже подставляет весь код переданной страницы вместо тега, но его можно использовать сколько угодно раз
У тега include есть дополнительные параметры:
only - этот параметр передаёт - не передаёт переменные - всё что в завёрнуто в двойные ковычки {{}}
with - ставиться после only в него можно передать имена тех переменных, которые мы всётаки хотим передать в теге include
    {% include 'women/includes/nav.html' only with title %} - передать всё содержимая файла nav без переменных, кроме переменной title



УРОК 6 ПОДКЛЮЧЕНИЕ СТАТИЧЕСКИХ ФАЙЛОВ

Статические файлы - это файлы css, картинки, и скрипты javascript
В боевом проекте мы конечно же не будем передовать голый шаблон.
Передоваемый шаблон будет связан со статическеми 
И сейчас разберемся как их связывать и передовать:

Мы уже знаем что мы можем запускать тестовый сервер с включеным и отключенным дебаг режимом
Во включенном дебаг режиме статические файлы ищутся, как и шаблоны, в каждом приложении за исключением рабочего каталога и каталога рабочего приложения
В setting.py есть переменная STATIC_URL, в которой по дефолту указан путь к static директории. 
Именно здесь джанго понимает в какой директории искать статические файлы в дебаг режиме.
ещё мы можем создать переменную STATICFILES_DIRS по формату аналогичной STATIC_URL и там прописать путь для нестандартного пути поиска статических файлов джанга. А-ля в директории корневого приложения.
Но в действующем сайте все статические файлы должны быть перенесены в корневую директорию проекта, в директорию static.
Путь к этой директории тоже нужно прописать в переменной, но уже в новой - STATIC_ROOT
А все статик-файлы перенести в эту директорию.
Причем перенос нужно осуществить, перед запуском сайта, благодаря команде ~ python manage.py collectstatic 

Вот наглядное расположение директорий static
sitewomen
    - sitewomen
        - static               # - нестандартный путь

    - women
        -static                # - стандартный путь для режима дебаг
        -templates

    -static                    # - стандартный путь для действующего режима работы сайта

Мы находимся в режиме разработки, а значит наши статические файлы должны лежать в каталоге приложения
Создаём директори static в приложении, в ней, по тем же причинам что и в templates, создаём директорию с именем приложения
И уже в нём создаём 3 директории - css, images, js
Создаём или добавляем уже созданные статические файлы в этих директориях

Чтобы в html можно было вставлять статические файлы их нужно в этот html загрузить
Для этого в самом начале страницы нужно поставить шаблонный тег load static
{% load static %}

Теперь нам нужно подключить эти файлы к нашему шаблону
Статические фалы добавляются в html в теге link, в нём есть параметр href - ссылка на докумемент файла.
Можно напрямую указать ссылку, но это хардкодинг.
Мы будем делать это используя шаблонный тег static.
По аналогии с include, ему нужно передать ссылку на файл ~ {% static 'women/css/styles.css' %}
часть пути - static/ - указывать не нужно, потому что эта часть уже прописана в STATIC_URL
Тег link будет выглядеть так 
    <link type="text/css" href="{% static 'women/css/styles.css' %}" rel="stylesheet" />

Вот и всё. По аналогии добавляем остальные файлы в шаблон, немного шаманим над самим шаблоном и наш сайт преображается в нормальный вид.


По уроку далее можно рассматриваем еще пару шаблонных фильтров: linebreaks, truncatewords, autoescape
Для работы поменяем в нашей бд заначение первой строки, колонки content с этого:
Биография Анджелина Джоли
на это:
'''<h1>Анджелина Джоли</h1> (англ. Angelina Jolie[7], при рождении Войт (англ. Voight), ранее Джоли Питт (англ. Jolie Pitt); род. 4 июня 1975, Лос-Анджелес, Калифорния, США) — американская актриса кино, телевидения и озвучивания, кинорежиссёр, сценаристка, продюсер, фотомодель, посол доброй воли ООН.
Обладательница премии «Оскар», трёх премий «Золотой глобус» (первая актриса в истории, три года подряд выигравшая премию) и двух «Премий Гильдии киноактёров США».'''

Разберём сначала truncatewords - он выводит указанное количество слов в тексте.
т.е. применив этот тег с параметром 20 - truncatewords:20 - в браузере отобразиться только первые двадцать слов текста
- linebreaks - переносит текст вместе с символоми переноса строк. без этого фильтра символа переноса не будет и строки склеются
- autoescape - это шаблонный тег. в нашем тексте есть экранирование текста в формате html <h1>Анджелина Джоли</h1>, и html при передачи такой строки через {{ данные }} не переводит этот текст в нужный формат сам.
Что бы html видел теги как теги а не как текст, нужно весь текст обернуть в шаблонный тег autoescape с параметром off
    {% autoescape off %}
    {{p.content|linebreaks|truncatewords:40}}
    {% endautoescape %}