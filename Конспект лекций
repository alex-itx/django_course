УСТАНОВКА ДЖАНГО, СОЗДАНИЕ ПРОЕКТА, ПРЕДСТАВЛЕНИЯ И МАРШРУТИЗАЦИЯ


Урок 1 УСТАНОВКА ДЖАНГО

для запуска проекта на джанго сначала нам нужно создать репозиторий проекта и в нём поставить виртуальное окружение venv
далее ставим джанго внутри окружения ~ pip install django==4.2.1 
можно посмотреть какие команды доступны в ядре джанго ~ django-admin 
далее создаём сайт на котором будем работать ~ django-admin startproject <имя сайта>
после создания, видим внутри проекта папку с названием сайта и в нём python файлы, включая manage.py
чтобы запустить сервер сайта нужно выполнить команду внутри папки сайта ~ python manage.py runserver 
при обновлении програмного кода, браузер может не подгрузить изменения, тогда нам нужно отключить соединение в терминале и подключиться снова



Урок 2 СОЗДАНИЕ ПРИЛОЖЕНИЯ В ДЖАНГО

сначала напомним что происходит под капотом сайта когда пользователь делает запрос на сайт:
- на сервер приходит запрос и он ищет щаблоны схожие с запросом пользователя
- при нахождении шаблона активируется представление в джанге
- представление это функция или класс в питоне, которые при активации дастаёт необходимые данные из бд и шаблонов html, объединяет их и отрправляет пользователю в виде html страницы

на сайте может быть реализованно множество логических независимых приложений, каждое из них является программой внутри сайта и все эти программы хранятся в нашем проекте джанго. Каждая из них должна быть зарегестрированна (прописана) в settings.py внутри INSTALLED_APPS

приложение создаётся в терминале внутри проекта джанго ~ python manage.py startapp <имя приложения> 



УРОК 3 СОЗДАНИЕ ФУНКЦИЙ-ПРЕДСТАВЛЕНИЙ И ИХ МАРШРУТИЗАЦИЯ 

Как уже говорилось ранее представление это функция или класс которая возвращает данные, как правило, в виде html страницы
Сами представления создаются и хранятся в файле views.py внутри репозитория приложения

Но чтобы эта функция вернулась пользователю её нужно как-то передать. Процесс передачи называется - маршрутизация
Маршрутизация осуществляется при помощи джанговой функции path() из джанговой библиотеки, она принимает "суфикс" урл котороый будет в адресе той страницы на которую мы переходим и функцию (или класс) - представление, которая и возвращает страницую

все маршруты хранятся в переменной urlpatterns как элементы списка, внутри файла urls.py
Такой файл по дефолту есть только в основном приложении, а для созданных приложений его нужно создавать отдельно.
Если мы используем маршрут из созданного приложения, маршрут нужно прописывать urls.py самого приложеия, а в urls.py основного приложения принимать все пути при помощи функции include() ~ path(<первоначальный суфикс>, include('<имя приложения>.urls')),



УРОК 4 ОТЛАДКА ПРОЕКТА В ПАЙЧАРМ

Если подключаться к серверу через терминал, мы теряем возможность его отлаживать, а еще это не очень удобно.
Мы можем подключаться к нему по кнопке (зелёной, что запускает скрипт) в пайчарме.
Для этого возле той самой кнопки, нажимаем на настройки и в окне указываем: название скрипта, рабочую директорию, интерпритатор пайтон, в котором работает проект и команду скрипта (в этом примере runserver)
После настройки можно: подключаться к серверу по кнопке, а не командой в терминале и делать отладку функций. 
А ещё больше не нужно перезапускать сервер при изменение кода



УРОК 5 ДИНАМИЧЕСКИЕ URL И КОНВЕРТЕРЫ

Динамические урл это урл с несколькими раздаелами пути, где последующие разделы, после основного, могут динамически изменятся и тем самым изменять данные, которые возвращаются в ответе сервера.
эти разделы отображаются при написании представлений и маршрутов динамических урл
Для представлений, если оно выполненно в виде функции, подраздел будет дополнительным аргументов функции, который можно использовать в теле или выводе этой функции.
    def categories_by_slug(request, cat_slug):
        return HttpResponse(f"<h1>Статьи по категориям</h1><p >slug:{ cat_slug }</p>")
В маршруте, подраздел отображается как часть пути, но не статичной строкой, а спец. синтаксисом <тип данных:имя аргумента представления>, а называется это - конвертер
    path('cats/<int:cat_id>/', views.categories),



Для динамичных путей можно использовать несколько типов данных:
    str – любая не пустая строка, исключая символ ‘/’;
    int – любое положительное целое число, включая 0;
    slug – слаг, то есть, латиница ASCII таблицы, цифры, символы дефиса и подчеркивания;
    uuid – цифры, малые латинские символы ASCII, дефис;
    path – любая не пустая строка, включая символ ‘/’. 

Но если нам их не хватает, можно определить свой тип данных и воспользоваться регуляркой.
В таком случае путь в маршруте будет указываться функцией re_path(), а регулярка будет прописана в пути
    re_path(r'^archive/(?P<year>[0-9]{4})/', views.archive),
Но это выглядит не очень, поэтому можно поступить намного круче:
Вместо того чтобы того чтобы прописывать конвертер внутри path можно прописать его в отдельном файле converters.py, предворительно создав его внутри нашего приложения.
В этом файле мы будем хранить все наши конвертеры, а реализовывать их можно в классе и это выглядит очень красиво и удобно:
    class FourDigitYearConverter:
        regex = "[0-9]{4}"  # наша регулярочка
     
        def to_python(self, value):
            return int(value)   # функция делает из строки число (я так понимаю для проверки)
     
        def to_url(self, value):
            return "%04d" % value       # возвращает строку обратно, чтобы использовать в path

И теперь мы можем можем использовать этот конвертер в path().
Причем именно в path, а не re_path
Но перед использованием конвертера, его нужно снасала зарегестрировать в файле urls.py, ну и импортировать конечно же
Чтобы зарегестрировать конвертер нужно воспользоваться функцией register_converter(), которую тоже нужно импортировать из django.urls.
В функцию летит имя конвертера и произвольное имя типа данных который он возваращает
    register_converter(converters.FourDigitYearConverter, "year4")
после этого можно использовать конвертер в path и лицезреть красивый код
    path('archive/<year4:year>/', views.archive),

подробности обо всём этом тут:
https://docs.djangoproject.com/en/4.2/topics/http/urls/


Ещё момент про urlpatterns (список наших урлов)
При запросе всегда отработает тот шаблон, в котором, первым, было найдено совпадение запроса. Т.Е. елси запрос может отработать в нескольких маршрутах, отработает, тот что записон в списке раньше остальных (имеет меньший индекс). 



УРОК 6 GET И POST ЗАПРОСЫ, ОБРАБОТКА ИСКЛЮЧЕНИЙ

УРЛ запросы могут содержать дополнительные параметры в виде GET и POST запросов.
http://127.0.0.1:8000/?name=Gagarina&cat=music 
?name=Gagarina&cat=music  - вот эта часть и есть пост запрос.
Эти запросы можно обрабатывать в джанге, например, в самой вьюшке можно словить его ~ request.GET и далее с ним работать
С пост запросом всё идентично ~ request.POST

ОБРАБОТКА ИСКЛЮЧЕНИЙ:
Порой при запросе, запросе пользователь может словить исключение, разберем на примере 404, когда запрос не находит совпадений в маршрутах и не может ничего вернуть
Если самому сделать подобный запрос, джанго выдаст страницу исключения 404 с данными подсказывающие нам об исключение.
Это происходит потомучто в файле setting.py в папке главного приложения есть переменная DEBUG с параметром TRUE.
Если её отключить (поменять на False) при исключении мы будем получать стандартный вывод 404 браузера
Но помимо отключения дебага нам нужно будет еще прописать хост локального сервера в ALLOWED_HOSTS = [], иначе мы не подключимся к нему и получим ошибку
    ALLOWED_HOSTS = ['127.0.0.1']
Вывод исключений браузера не очень удобный и информативный для пользователя
Мы можем написать собственный обработчик исключений и выводить собственный html в подобных случаях
пишем его в urls.py основного приложения ~ handler404 = page_not_found
обработчик это вызов функции page_not_found сама же функция будет находится во вьюшке приложения women
    def page_not_found(request, exception):
        return HttpResponseNotFound('<h1>Страница не найдена</h1>')
функция принимает запрос и ошибку из джанги и возвращает класс HttpResponseNotFound который мы импортируем из django.http
Теперь при ошибки 404 мы выводим собственный html для пользователя.

обрабатывать запросы можно и в самих вьюшках:
    def archive(request, year):
        if year > 2023:
            raise Http404()
        return HttpResponse(f"<h1>Архив по годам</h1><p >{year}</p>")
Здесь по условию мы генерим исключение Http404(). оно импортируется из django.http. при срабатывание этого исключения сработает наш обработчик 404

Обрабатывать можно не только 404 исключение, но и другие, для каждого нужно писать свой обработчик.
Подробнее тут:
https://docs.djangoproject.com/en/4.2/ref/urls/



УРОК 7 GET И POST ЗАПРОСЫ, ОБРАБОТКА ИСКЛЮЧЕНИЙ

При развитии сайта очень часто некоторые страницы переезжают на други урл адреса.
Чтобы не потерять эти страницы, поисковой системе нужно явно указывать что страница переехала.
После того как мы это сделали, переходя по старому адресу сайт перенаправит нас на новый урл а запрос получит ответ 301 или 302
    301 – страница перемещена на другой постоянный URL-адрес;
    302 – страница перемещена временно на другой URL-адрес. 

В джанго переезд можно оформить функцией redirect(), предварительно импортируя её из django.shortcuts
    from django.shortcuts import render, redirect
функцию мы вставляем в return представления и передаём в неё адрес на которое будет переход
    def archive(request, year):
        if year > 2023:
            return redirect('/')
Вместо указания адреса напрямую можно указать имя функции представления return redirect(index)
По дефолту перенаправление происходит с ответом 302, т.е. временно, чтобы сработал ответ 301, в redirect нужно добавить дополнительный аргумент - permanent со значением True
    return redirect(index, permanent=True)
Писать путь напрямую или имя функции, считается хардкодингом.
Помимо этих двух вариантов функция redirect принимает еще и имя маршрута. И это самый лучший вариант в визуальном стили кода.
Но это имя в маршруте должно присутствовать.
Для этого в маршрут передаём еще один параметр name='имя маршрута'
    path('', views.index, name='home'),
    path('cats/<slug:cat_slug>/', views.categories_by_slug, name='cats'),
и после этого в redirect можно передовать это имя
    return redirect('home', permanent=True)
Если же маршрут перенаправления содержит несколько параметров - в redirect эти параметры также нужно указать
    return redirect('cats', 'music')

Маршрут перенаправления можно вычеслить заранее, до функции redirect используя функцию revers, предворительно, импортируя её из django.urls
В revers можно передать имя маршрута и коллекцию дополнительных подрозделов.
А после передаём функцию в redirect
        url_redirect = reverse('cats', args=('sport',))
        return redirect(url_redirect)

Помимо redirect можно использовать классы HttpResponseRedirect и HttpResponsePermanentRedirect
Работает они почти аналогично redirect(). первый вызывает ответ 302, второй 301
Чем пользоваться тоже, особо разницы нет.
Разница в работе заключается в том, что в классы нельзя передовать названия функций представлений, а ещё redirect может сам вычислять маршрут динамически



ШАБЛОНЫ


УРОК 1 ШАБЛОНЫ, render(), render_to_string()

Шаблоны это готовы html страницы.
До этого мы передовали захардкоженную html внутри функций представления. Но так конечно же делать неправильно
Все шаблоны храняться внутри нашего приложения в директории под названием templates.
Внутри этой директории также необходимо создать директорию с названием нашего приложения и уже в ней хранить наши html файлы
Это делается потому-что, чтобы вытащить html документ, мы должны передать его путь.
Джанго не требует передовать весь путь, он подразумевает, что в каждом приложении, у нас есть папка templates и сам будет искать там html.
Вот только джанго будет проходить по всем приложениям и если у нас в разных приложениях будут храниться html с одинаковыми названиями джанго возьмёт первый найденный.
Для этого и создаётся подпапка в templates, так мы указываем более подробный путь, который не будет совпадать с другими приложениями.

Как же передать этот путь во вьюшке?:
Для этого нам понадобиться функция render_to_string(), которую мы импортируем из django.template.loader.
в неё мы и передадим путь к файлу html, а её саму передадим в вывод вьюшки
    def index(request):
        t = render_to_string('women/index.html')
        return HttpResponse(t)
Но можно сократить эти две строки в одну используя функцию render() из django.shortcuts
В неё передаём request и путь к html
    def about(request):
        return render(request, 'women/about.html')

Теперь а самом шаблонизаторе джанго:
Мы можем изменять его настройки в основной директории приложения в файле settings.py
Там есть коллекция TEMPLATES. она хранит в себе такие ключи: BACKEND, DIRS, APP_DIRS, OPTIONS
'BACKEND': 'django.template.backends.django.DjangoTemplates', - в нём прописан стандартный шаблонизатор джанги
'DIRS': [], - в Этой коллекции мы можем хранить дополнительные пути для поиска шаблонов, если это требуется
'APP_DIRS': True, - этот ключ отвечает, за то что джанго понимает что ей нужно искать в папке templates в каждом приложении.
точнее не в каждом приложении а в каждом инсталированном. т.е. находящийся в коллекции INSTALLED_APPS, в этом же файле
    'women.apps.WomenConfig',



УРОК 2 ПЕРЕДАЧА ДАННЫХ (ПЕРЕМЕННЫХ) В ШАБЛОНЫ

Шаблону не обязательно быть статичным. т.е. данные в нём не обязательно должны быть строго вшиты в html.
Мы можем передовать данные из переменных в коде в html страницу.
Для этого нужно поправить сам html документ и в место куда мы хотим хотим поставить вставлять данные прописать {{}}, а внутрь кавычек вписать имя переменной, значение которой будем вставлять. 
вместо этого
    <title>Главная страница</title>
вот так
    <title>{{title}}</title>
А в коде нам нужно создать данные с таким же названием.
Например, создать словарь с ключём title и значением которое мы хотим подставить html
    data = {'title': 'Главная страница'}
Этот словарь можно создать внутри представления страницы в которую мы будем подставлять данные и передать словарь третим аргументом в функцию рендер, или через именнованный аргумент context
    def index(request):
        data = {'title': 'Главная страница'}
        return render(request, 'women/index.html', data)
А можно создать прямо внутри аргумента напрямую
    def about(request):
        return render(request, 'women/about.html', context={'title' : 'О сайте'})

В html может находиться множество данных, которые нужно подставлять из кода, тогда и словарь будет с множеством ключей.
     data = {
        'title': 'Главная страница',
        'menu': menu,
        'float': 28.56,
        'lst': [1, 2, 'abc', True],
        'set': {1, 1, 2, 3, 2, 5},
        'dict': {'key_1': 'value_1', 'key_2': 'value_2'},
        'obj': MyClass(10, 20),
    }
Тип данных может быть любым, но в html выводиться строковое представление переданных данных
Можно передовать даже коллекции, как целиком, так и части этих коллекций.
Но чтобы передать элемент коллекции в html, нужно это указать в самом html.
И делается это не привычным синтаксисом пайтон
    <p >{dict[key_1]}}</p>
а немного измененным
    <p >{{dict.key_1}}</p>
    <p >{{obj.a}}</p>
В одни фигурные скобки, можно засовывать только один элемент. Если мы хотим передать в тег несколько элементов - каждый нужно обернуть в скобки отдельно
    <p >{{ dict.key_1 }} {{ dict.key_2 }}</p>
Если в html есть имя данных которые мы не передали в render, при выводе страницы в браузере мы не получим ошибку.
В таком случае данные будут просто проигнорированны. т.е. на месте данных ничего не будет

Как вытаскивать элементы из списков и кортежей, будет в дальнейших уроках

















