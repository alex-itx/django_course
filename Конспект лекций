Урок 1 УСТАНОВКА ДЖАНГО

для запуска проекта на джанго сначала нам нужно создать репозиторий проекта и в нём поставить виртуальное окружение venv
далее ставим джанго внутри окружения ~ pip install django==4.2.1 
можно посмотреть какие команды доступны в ядре джанго ~ django-admin 
далее создаём сайт на котором будем работать ~ django-admin startproject <имя сайта>
после создания, видим внутри проекта папку с названием сайта и в нём python файлы, включая manage.py
чтобы запустить сервер сайта нужно выполнить команду внутри папки сайта ~ python manage.py runserver 
при обновлении програмного кода, браузер может не подгрузить изменения, тогда нам нужно отключить соединение в терминале и подключиться снова



Урок 2 СОЗДАНИЕ ПРИЛОЖЕНИЯ В ДЖАНГО

сначала напомним что происходит под капотом сайта когда пользователь делает запрос на сайт:
- на сервер приходит запрос и он ищет щаблоны схожие с запросом пользователя
- при нахождении шаблона активируется представление в джанге
- представление это функция или класс в питоне, которые при активации дастаёт необходимые данные из бд и шаблонов html, объединяет их и отрправляет пользователю в виде html страницы

на сайте может быть реализованно множество логических независимых приложений, каждое из них является программой внутри сайта и все эти программы хранятся в нашем проекте джанго. Каждая из них должна быть зарегестрированна (прописана) в manage.py внутри INSTALLED_APPS

приложение создаётся в терминале внутри проекта джанго ~ python manage.py startapp <имя приложения> 



УРОК 3 СОЗДАНИЕ ФУНКЦИЙ-ПРЕДСТАВЛЕНИЙ И ИХ МАРШРУТИЗАЦИЯ 

Как уже говорилось ранее представление это функция или класс которая возвращает данные, как правило, в виде html страницы
Сами представления создаются и хранятся в файле views.py внутри репозитория приложения

Но чтобы эта функция вернулась пользователю её нужно как-то передать. Процесс передачи называется - маршрутизация
Маршрутизация осуществляется при помощи джанговой функции path() из джанговой библиотеки, она принимает "суфикс" урл котороый будет в адресе той страницы на которую мы переходим и функцию (или класс) - представление, которая и возвращает страницую

все маршруты хранятся в переменной urlpatterns как элементы списка, внутри файла urls.py
Такой файл по дефолту есть только в основном приложении, а для созданных приложений его нужно создавать отдельно.
Если мы используем маршрут из созданного приложения, маршрут нужно прописывать urls.py самого приложеия, а в urls.py основного приложения принимать все пути при помощи функции include() ~ path(<первоначальный суфикс>, include('<имя приложения>.urls')),



УРОК 4 ОТЛАДКА ПРОЕКТА В ПАЙЧАРМ

Если подключаться к серверу через терминал, мы теряем возможность его отлаживать, а еще это не очень удобно.
Мы можем подключаться к нему по кнопке (зелёной, что запускает скрипт) в пайчарме.
Для этого возле той самой кнопки, нажимаем на настройки и в окне указываем: название скрипта, рабочую директорию, интерпритатор пайтон, в котором работает проект и команду скрипта (в этом примере runserver)
После настройки можно: подключаться к серверу по кнопке, а не командой в терминале и делать отладку функций. 
А ещё больше не нужно перезапускать сервер при изменение кода



УРОК 5 ДИНАМИЧЕСКИЕ URL И КОНВЕРТЕРЫ

Динамические урл это урл с несколькими раздаелами пути, где последующие разделы, после основного, могут динамически изменятся и тем самым изменять данные, которые возвращаются в ответе сервера.
эти разделы отображаются при написании представлений и маршрутов динамических урл
Для представлений, если оно выполненно в виде функции, подраздел будет дополнительным аргументов функции, который можно использовать в теле или выводе этой функции.
    def categories_by_slug(request, cat_slug):
        return HttpResponse(f"<h1>Статьи по категориям</h1><p >slug:{ cat_slug }</p>")
В маршруте, подраздел отображается как часть пути, но не статичной строкой, а спец. синтаксисом <тип данных:имя аргумента представления>, а называется это - конвертер
    path('cats/<int:cat_id>/', views.categories),



Для динамичных путей можно использовать несколько типов данных:
    str – любая не пустая строка, исключая символ ‘/’;
    int – любое положительное целое число, включая 0;
    slug – слаг, то есть, латиница ASCII таблицы, цифры, символы дефиса и подчеркивания;
    uuid – цифры, малые латинские символы ASCII, дефис;
    path – любая не пустая строка, включая символ ‘/’. 

Но если нам их не хватает, можно определить свой тип данных и воспользоваться регуляркой.
В таком случае путь в маршруте будет указываться функцией re_path(), а регулярка будет прописана в пути
    re_path(r'^archive/(?P<year>[0-9]{4})/', views.archive),
Но это выглядит не очень, поэтому можно поступить намного круче:
Вместо того чтобы того чтобы прописывать конвертер внутри path можно прописать его в отдельном файле converters.py, предворительно создав его внутри нашего приложения.
В этом файле мы будем хранить все наши конвертеры, а реализовывать их можно в классе и это выглядит очень красиво и удобно:
    class FourDigitYearConverter:
        regex = "[0-9]{4}"  # наша регулярочка
     
        def to_python(self, value):
            return int(value)   # функция делает из строки число (я так понимаю для проверки)
     
        def to_url(self, value):
            return "%04d" % value       # возвращает строку обратно, чтобы использовать в path

И теперь мы можем можем использовать этот конвертер в path().
Причем именно в path, а не re_path
Но перед использованием конвертера, его нужно снасала зарегестрировать в файле urls.py, ну и импортировать конечно же
Чтобы зарегестрировать конвертер нужно воспользоваться функцией register_converter(), которую тоже нужно импортировать из django.urls.
В функцию летит имя конвертера и произвольное имя типа данных который он возваращает
    register_converter(converters.FourDigitYearConverter, "year4")
после этого можно использовать конвертер в path и лицезреть красивый код
    path('archive/<year4:year>/', views.archive),

подробности обо всём этом тут:
https://docs.djangoproject.com/en/4.2/topics/http/urls/


Ещё момент про urlpatterns (список наших урлов)
При запросе всегда отработает тот шаблон, в котором, первым, было найдено совпадение запроса. Т.Е. елси запрос может отработать в нескольких маршрутах, отработает, тот что записон в списке раньше остальных (имеет меньший индекс). 



УРОК 6 GET И POST ЗАПРОСЫ, ОБРАБОТКА ИСКЛЮЧЕНИЙ

УРЛ запросы могут содержать дополнительные параметры в виде GET и POST запросов.
http://127.0.0.1:8000/?name=Gagarina&cat=music 
?name=Gagarina&cat=music  - вот эта часть и есть пост запрос.
Эти запросы можно обрабатывать в джанге, например, в самой вьюшке можно словить его ~ request.GET и далее с ним работать
С пост запросом всё идентично ~ request.POST

ОБРАБОТКА ИСКЛЮЧЕНИЙ:
Порой при запросе, запросе пользователь может словить исключение, разберем на примере 404, когда запрос не находит совпадений в маршрутах и не может ничего вернуть
Если самому сделать подобный запрос, джанго выдаст страницу исключения 404 с данными подсказывающие нам об исключение.
Это происходит потомучто в файле setting.py в папке главного приложения есть переменная DEBUG с параметром TRUE.
Если её отключить (поменять на False) при исключении мы будем получать стандартный вывод 404 браузера
Но помимо отключения дебага нам нужно будет еще прописать хост локального сервера в ALLOWED_HOSTS = [], иначе мы не подключимся к нему и получим ошибку
    ALLOWED_HOSTS = ['127.0.0.1']
Вывод исключений браузера не очень удобный и информативный для пользователя
Мы можем написать собственный обработчик исключений и выводить собственный html в подобных случаях
пишем его в urls.py основного приложения ~ handler404 = page_not_found
обработчик это вызов функции page_not_found сама же функция будет находится во вьюшке приложения women
    def page_not_found(request, exception):
        return HttpResponseNotFound('<h1>Страница не найдена</h1>')
функция принимает запрос и ошибку из джанги и возвращает класс HttpResponseNotFound который мы импортируем из django.http
Теперь при ошибки 404 мы выводим собственный html для пользователя.

обрабатывать запросы можно и в самих вьюшках:
    def archive(request, year):
        if year > 2023:
            raise Http404()
        return HttpResponse(f"<h1>Архив по годам</h1><p >{year}</p>")
Здесь по условию мы генерим исключение Http404(). оно импортируется из django.http. при срабатывание этого исключения сработает наш обработчик 404

Обрабатывать можно не только 404 исключение, но и другие, для каждого нужно писать свой обработчик.
Подробнее тут:
https://docs.djangoproject.com/en/4.2/ref/urls/

















